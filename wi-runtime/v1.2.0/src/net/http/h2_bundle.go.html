<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<meta name="theme-color" content="#375EAB">

  <title>src/net/http/h2_bundle.go - The Go Programming Language</title>

<link type="text/css" rel="stylesheet" href="../../../lib/godoc/style.css">

<link rel="stylesheet" href="../../../lib/godoc/jquery.treeview.css">
<script type="text/javascript">window.initFuncs = [];</script>
</head>
<body>

<div id='lowframe' style="position: fixed; bottom: 0; left: 0; height: 0; width: 100%; border-top: thin solid grey; background-color: white; overflow: auto;">
...
</div><!-- #lowframe -->

<div id="topbar" class="wide"><div class="container">
<div class="top-heading" id="heading-wide"><a href="http://localhost:6060/">The Go Programming Language</a></div>
<div class="top-heading" id="heading-narrow"><a href="http://localhost:6060/">Go</a></div>
<a href="h2_bundle.go.html#" id="menu-button"><span id="menu-button-arrow">&#9661;</span></a>
<form method="GET" action="http://localhost:6060/search">
<div id="menu">
<a href="http://localhost:6060/doc/">Documents</a>
<a href="http://localhost:6060/pkg/">Packages</a>
<a href="http://localhost:6060/project/">The Project</a>
<a href="http://localhost:6060/help/">Help</a>
<a href="http://localhost:6060/blog/">Blog</a>

<input type="text" id="search" name="q" class="inactive" value="Search" placeholder="Search">
</div>
</form>

</div></div>



<div id="page" class="wide">
<div class="container">


  <h1>Source file src/net/http/h2_bundle.go</h1>




<div id="nav"></div>


<script type='text/javascript'>document.ANALYSIS_DATA = null;</script>
<pre><span id="L1" class="ln">     1	</span><span class="comment">// Code generated by golang.org/x/tools/cmd/bundle.</span>
<span id="L2" class="ln">     2	</span><span class="comment">//go:generate bundle -o h2_bundle.go -prefix http2 -underscore golang.org/x/net/http2</span>
<span id="L3" class="ln">     3	</span>
<span id="L4" class="ln">     4	</span><span class="comment">// Package http2 implements the HTTP/2 protocol.</span>
<span id="L5" class="ln">     5	</span><span class="comment">//</span>
<span id="L6" class="ln">     6	</span><span class="comment">// This package is low-level and intended to be used directly by very</span>
<span id="L7" class="ln">     7	</span><span class="comment">// few people. Most users will use it indirectly through the automatic</span>
<span id="L8" class="ln">     8	</span><span class="comment">// use by the net/http package (from Go 1.6 and later).</span>
<span id="L9" class="ln">     9	</span><span class="comment">// For use in earlier Go versions see ConfigureServer. (Transport support</span>
<span id="L10" class="ln">    10	</span><span class="comment">// requires Go 1.6 or later)</span>
<span id="L11" class="ln">    11	</span><span class="comment">//</span>
<span id="L12" class="ln">    12	</span><span class="comment">// See https://http2.github.io/ for more information on HTTP/2.</span>
<span id="L13" class="ln">    13	</span><span class="comment">//</span>
<span id="L14" class="ln">    14	</span><span class="comment">// See https://http2.golang.org/ for a test server running this code.</span>
<span id="L15" class="ln">    15	</span><span class="comment">//</span>
<span id="L16" class="ln">    16	</span>
<span id="L17" class="ln">    17	</span>package http
<span id="L18" class="ln">    18	</span>
<span id="L19" class="ln">    19	</span>import (
<span id="L20" class="ln">    20	</span>	&#34;bufio&#34;
<span id="L21" class="ln">    21	</span>	&#34;bytes&#34;
<span id="L22" class="ln">    22	</span>	&#34;compress/gzip&#34;
<span id="L23" class="ln">    23	</span>	&#34;context&#34;
<span id="L24" class="ln">    24	</span>	&#34;crypto/rand&#34;
<span id="L25" class="ln">    25	</span>	&#34;crypto/tls&#34;
<span id="L26" class="ln">    26	</span>	&#34;encoding/binary&#34;
<span id="L27" class="ln">    27	</span>	&#34;errors&#34;
<span id="L28" class="ln">    28	</span>	&#34;fmt&#34;
<span id="L29" class="ln">    29	</span>	&#34;io&#34;
<span id="L30" class="ln">    30	</span>	&#34;io/ioutil&#34;
<span id="L31" class="ln">    31	</span>	&#34;log&#34;
<span id="L32" class="ln">    32	</span>	&#34;math&#34;
<span id="L33" class="ln">    33	</span>	&#34;net&#34;
<span id="L34" class="ln">    34	</span>	&#34;net/http/httptrace&#34;
<span id="L35" class="ln">    35	</span>	&#34;net/textproto&#34;
<span id="L36" class="ln">    36	</span>	&#34;net/url&#34;
<span id="L37" class="ln">    37	</span>	&#34;os&#34;
<span id="L38" class="ln">    38	</span>	&#34;reflect&#34;
<span id="L39" class="ln">    39	</span>	&#34;runtime&#34;
<span id="L40" class="ln">    40	</span>	&#34;sort&#34;
<span id="L41" class="ln">    41	</span>	&#34;strconv&#34;
<span id="L42" class="ln">    42	</span>	&#34;strings&#34;
<span id="L43" class="ln">    43	</span>	&#34;sync&#34;
<span id="L44" class="ln">    44	</span>	&#34;time&#34;
<span id="L45" class="ln">    45	</span>
<span id="L46" class="ln">    46	</span>	&#34;golang_org/x/net/http2/hpack&#34;
<span id="L47" class="ln">    47	</span>	&#34;golang_org/x/net/idna&#34;
<span id="L48" class="ln">    48	</span>	&#34;golang_org/x/net/lex/httplex&#34;
<span id="L49" class="ln">    49	</span>)
<span id="L50" class="ln">    50	</span>
<span id="L51" class="ln">    51	</span><span class="comment">// ClientConnPool manages a pool of HTTP/2 client connections.</span>
<span id="L52" class="ln">    52	</span>type http2ClientConnPool interface {
<span id="L53" class="ln">    53	</span>	GetClientConn(req *Request, addr string) (*http2ClientConn, error)
<span id="L54" class="ln">    54	</span>	MarkDead(*http2ClientConn)
<span id="L55" class="ln">    55	</span>}
<span id="L56" class="ln">    56	</span>
<span id="L57" class="ln">    57	</span><span class="comment">// clientConnPoolIdleCloser is the interface implemented by ClientConnPool</span>
<span id="L58" class="ln">    58	</span><span class="comment">// implementations which can close their idle connections.</span>
<span id="L59" class="ln">    59	</span>type http2clientConnPoolIdleCloser interface {
<span id="L60" class="ln">    60	</span>	http2ClientConnPool
<span id="L61" class="ln">    61	</span>	closeIdleConnections()
<span id="L62" class="ln">    62	</span>}
<span id="L63" class="ln">    63	</span>
<span id="L64" class="ln">    64	</span>var (
<span id="L65" class="ln">    65	</span>	_ http2clientConnPoolIdleCloser = (*http2clientConnPool)(nil)
<span id="L66" class="ln">    66	</span>	_ http2clientConnPoolIdleCloser = http2noDialClientConnPool{}
<span id="L67" class="ln">    67	</span>)
<span id="L68" class="ln">    68	</span>
<span id="L69" class="ln">    69	</span><span class="comment">// TODO: use singleflight for dialing and addConnCalls?</span>
<span id="L70" class="ln">    70	</span>type http2clientConnPool struct {
<span id="L71" class="ln">    71	</span>	t *http2Transport
<span id="L72" class="ln">    72	</span>
<span id="L73" class="ln">    73	</span>	mu sync.Mutex <span class="comment">// TODO: maybe switch to RWMutex</span>
<span id="L74" class="ln">    74	</span>	<span class="comment">// TODO: add support for sharing conns based on cert names</span>
<span id="L75" class="ln">    75	</span>	<span class="comment">// (e.g. share conn for googleapis.com and appspot.com)</span>
<span id="L76" class="ln">    76	</span>	conns        map[string][]*http2ClientConn <span class="comment">// key is host:port</span>
<span id="L77" class="ln">    77	</span>	dialing      map[string]*http2dialCall     <span class="comment">// currently in-flight dials</span>
<span id="L78" class="ln">    78	</span>	keys         map[*http2ClientConn][]string
<span id="L79" class="ln">    79	</span>	addConnCalls map[string]*http2addConnCall <span class="comment">// in-flight addConnIfNeede calls</span>
<span id="L80" class="ln">    80	</span>}
<span id="L81" class="ln">    81	</span>
<span id="L82" class="ln">    82	</span>func (p *http2clientConnPool) GetClientConn(req *Request, addr string) (*http2ClientConn, error) {
<span id="L83" class="ln">    83	</span>	return p.getClientConn(req, addr, http2dialOnMiss)
<span id="L84" class="ln">    84	</span>}
<span id="L85" class="ln">    85	</span>
<span id="L86" class="ln">    86	</span>const (
<span id="L87" class="ln">    87	</span>	http2dialOnMiss   = true
<span id="L88" class="ln">    88	</span>	http2noDialOnMiss = false
<span id="L89" class="ln">    89	</span>)
<span id="L90" class="ln">    90	</span>
<span id="L91" class="ln">    91	</span>func (p *http2clientConnPool) getClientConn(req *Request, addr string, dialOnMiss bool) (*http2ClientConn, error) {
<span id="L92" class="ln">    92	</span>	if http2isConnectionCloseRequest(req) &amp;&amp; dialOnMiss {
<span id="L93" class="ln">    93	</span>		<span class="comment">// It gets its own connection.</span>
<span id="L94" class="ln">    94	</span>		const singleUse = true
<span id="L95" class="ln">    95	</span>		cc, err := p.t.dialClientConn(addr, singleUse)
<span id="L96" class="ln">    96	</span>		if err != nil {
<span id="L97" class="ln">    97	</span>			return nil, err
<span id="L98" class="ln">    98	</span>		}
<span id="L99" class="ln">    99	</span>		return cc, nil
<span id="L100" class="ln">   100	</span>	}
<span id="L101" class="ln">   101	</span>	p.mu.Lock()
<span id="L102" class="ln">   102	</span>	for _, cc := range p.conns[addr] {
<span id="L103" class="ln">   103	</span>		if cc.CanTakeNewRequest() {
<span id="L104" class="ln">   104	</span>			p.mu.Unlock()
<span id="L105" class="ln">   105	</span>			return cc, nil
<span id="L106" class="ln">   106	</span>		}
<span id="L107" class="ln">   107	</span>	}
<span id="L108" class="ln">   108	</span>	if !dialOnMiss {
<span id="L109" class="ln">   109	</span>		p.mu.Unlock()
<span id="L110" class="ln">   110	</span>		return nil, http2ErrNoCachedConn
<span id="L111" class="ln">   111	</span>	}
<span id="L112" class="ln">   112	</span>	call := p.getStartDialLocked(addr)
<span id="L113" class="ln">   113	</span>	p.mu.Unlock()
<span id="L114" class="ln">   114	</span>	&lt;-call.done
<span id="L115" class="ln">   115	</span>	return call.res, call.err
<span id="L116" class="ln">   116	</span>}
<span id="L117" class="ln">   117	</span>
<span id="L118" class="ln">   118	</span><span class="comment">// dialCall is an in-flight Transport dial call to a host.</span>
<span id="L119" class="ln">   119	</span>type http2dialCall struct {
<span id="L120" class="ln">   120	</span>	p    *http2clientConnPool
<span id="L121" class="ln">   121	</span>	done chan struct{}    <span class="comment">// closed when done</span>
<span id="L122" class="ln">   122	</span>	res  *http2ClientConn <span class="comment">// valid after done is closed</span>
<span id="L123" class="ln">   123	</span>	err  error            <span class="comment">// valid after done is closed</span>
<span id="L124" class="ln">   124	</span>}
<span id="L125" class="ln">   125	</span>
<span id="L126" class="ln">   126	</span><span class="comment">// requires p.mu is held.</span>
<span id="L127" class="ln">   127	</span>func (p *http2clientConnPool) getStartDialLocked(addr string) *http2dialCall {
<span id="L128" class="ln">   128	</span>	if call, ok := p.dialing[addr]; ok {
<span id="L129" class="ln">   129	</span>
<span id="L130" class="ln">   130	</span>		return call
<span id="L131" class="ln">   131	</span>	}
<span id="L132" class="ln">   132	</span>	call := &amp;http2dialCall{p: p, done: make(chan struct{})}
<span id="L133" class="ln">   133	</span>	if p.dialing == nil {
<span id="L134" class="ln">   134	</span>		p.dialing = make(map[string]*http2dialCall)
<span id="L135" class="ln">   135	</span>	}
<span id="L136" class="ln">   136	</span>	p.dialing[addr] = call
<span id="L137" class="ln">   137	</span>	go call.dial(addr)
<span id="L138" class="ln">   138	</span>	return call
<span id="L139" class="ln">   139	</span>}
<span id="L140" class="ln">   140	</span>
<span id="L141" class="ln">   141	</span><span class="comment">// run in its own goroutine.</span>
<span id="L142" class="ln">   142	</span>func (c *http2dialCall) dial(addr string) {
<span id="L143" class="ln">   143	</span>	const singleUse = false <span class="comment">// shared conn</span>
<span id="L144" class="ln">   144	</span>	c.res, c.err = c.p.t.dialClientConn(addr, singleUse)
<span id="L145" class="ln">   145	</span>	close(c.done)
<span id="L146" class="ln">   146	</span>
<span id="L147" class="ln">   147	</span>	c.p.mu.Lock()
<span id="L148" class="ln">   148	</span>	delete(c.p.dialing, addr)
<span id="L149" class="ln">   149	</span>	if c.err == nil {
<span id="L150" class="ln">   150	</span>		c.p.addConnLocked(addr, c.res)
<span id="L151" class="ln">   151	</span>	}
<span id="L152" class="ln">   152	</span>	c.p.mu.Unlock()
<span id="L153" class="ln">   153	</span>}
<span id="L154" class="ln">   154	</span>
<span id="L155" class="ln">   155	</span><span class="comment">// addConnIfNeeded makes a NewClientConn out of c if a connection for key doesn&#39;t</span>
<span id="L156" class="ln">   156	</span><span class="comment">// already exist. It coalesces concurrent calls with the same key.</span>
<span id="L157" class="ln">   157	</span><span class="comment">// This is used by the http1 Transport code when it creates a new connection. Because</span>
<span id="L158" class="ln">   158	</span><span class="comment">// the http1 Transport doesn&#39;t de-dup TCP dials to outbound hosts (because it doesn&#39;t know</span>
<span id="L159" class="ln">   159	</span><span class="comment">// the protocol), it can get into a situation where it has multiple TLS connections.</span>
<span id="L160" class="ln">   160	</span><span class="comment">// This code decides which ones live or die.</span>
<span id="L161" class="ln">   161	</span><span class="comment">// The return value used is whether c was used.</span>
<span id="L162" class="ln">   162	</span><span class="comment">// c is never closed.</span>
<span id="L163" class="ln">   163	</span>func (p *http2clientConnPool) addConnIfNeeded(key string, t *http2Transport, c *tls.Conn) (used bool, err error) {
<span id="L164" class="ln">   164	</span>	p.mu.Lock()
<span id="L165" class="ln">   165	</span>	for _, cc := range p.conns[key] {
<span id="L166" class="ln">   166	</span>		if cc.CanTakeNewRequest() {
<span id="L167" class="ln">   167	</span>			p.mu.Unlock()
<span id="L168" class="ln">   168	</span>			return false, nil
<span id="L169" class="ln">   169	</span>		}
<span id="L170" class="ln">   170	</span>	}
<span id="L171" class="ln">   171	</span>	call, dup := p.addConnCalls[key]
<span id="L172" class="ln">   172	</span>	if !dup {
<span id="L173" class="ln">   173	</span>		if p.addConnCalls == nil {
<span id="L174" class="ln">   174	</span>			p.addConnCalls = make(map[string]*http2addConnCall)
<span id="L175" class="ln">   175	</span>		}
<span id="L176" class="ln">   176	</span>		call = &amp;http2addConnCall{
<span id="L177" class="ln">   177	</span>			p:    p,
<span id="L178" class="ln">   178	</span>			done: make(chan struct{}),
<span id="L179" class="ln">   179	</span>		}
<span id="L180" class="ln">   180	</span>		p.addConnCalls[key] = call
<span id="L181" class="ln">   181	</span>		go call.run(t, key, c)
<span id="L182" class="ln">   182	</span>	}
<span id="L183" class="ln">   183	</span>	p.mu.Unlock()
<span id="L184" class="ln">   184	</span>
<span id="L185" class="ln">   185	</span>	&lt;-call.done
<span id="L186" class="ln">   186	</span>	if call.err != nil {
<span id="L187" class="ln">   187	</span>		return false, call.err
<span id="L188" class="ln">   188	</span>	}
<span id="L189" class="ln">   189	</span>	return !dup, nil
<span id="L190" class="ln">   190	</span>}
<span id="L191" class="ln">   191	</span>
<span id="L192" class="ln">   192	</span>type http2addConnCall struct {
<span id="L193" class="ln">   193	</span>	p    *http2clientConnPool
<span id="L194" class="ln">   194	</span>	done chan struct{} <span class="comment">// closed when done</span>
<span id="L195" class="ln">   195	</span>	err  error
<span id="L196" class="ln">   196	</span>}
<span id="L197" class="ln">   197	</span>
<span id="L198" class="ln">   198	</span>func (c *http2addConnCall) run(t *http2Transport, key string, tc *tls.Conn) {
<span id="L199" class="ln">   199	</span>	cc, err := t.NewClientConn(tc)
<span id="L200" class="ln">   200	</span>
<span id="L201" class="ln">   201	</span>	p := c.p
<span id="L202" class="ln">   202	</span>	p.mu.Lock()
<span id="L203" class="ln">   203	</span>	if err != nil {
<span id="L204" class="ln">   204	</span>		c.err = err
<span id="L205" class="ln">   205	</span>	} else {
<span id="L206" class="ln">   206	</span>		p.addConnLocked(key, cc)
<span id="L207" class="ln">   207	</span>	}
<span id="L208" class="ln">   208	</span>	delete(p.addConnCalls, key)
<span id="L209" class="ln">   209	</span>	p.mu.Unlock()
<span id="L210" class="ln">   210	</span>	close(c.done)
<span id="L211" class="ln">   211	</span>}
<span id="L212" class="ln">   212	</span>
<span id="L213" class="ln">   213	</span>func (p *http2clientConnPool) addConn(key string, cc *http2ClientConn) {
<span id="L214" class="ln">   214	</span>	p.mu.Lock()
<span id="L215" class="ln">   215	</span>	p.addConnLocked(key, cc)
<span id="L216" class="ln">   216	</span>	p.mu.Unlock()
<span id="L217" class="ln">   217	</span>}
<span id="L218" class="ln">   218	</span>
<span id="L219" class="ln">   219	</span><span class="comment">// p.mu must be held</span>
<span id="L220" class="ln">   220	</span>func (p *http2clientConnPool) addConnLocked(key string, cc *http2ClientConn) {
<span id="L221" class="ln">   221	</span>	for _, v := range p.conns[key] {
<span id="L222" class="ln">   222	</span>		if v == cc {
<span id="L223" class="ln">   223	</span>			return
<span id="L224" class="ln">   224	</span>		}
<span id="L225" class="ln">   225	</span>	}
<span id="L226" class="ln">   226	</span>	if p.conns == nil {
<span id="L227" class="ln">   227	</span>		p.conns = make(map[string][]*http2ClientConn)
<span id="L228" class="ln">   228	</span>	}
<span id="L229" class="ln">   229	</span>	if p.keys == nil {
<span id="L230" class="ln">   230	</span>		p.keys = make(map[*http2ClientConn][]string)
<span id="L231" class="ln">   231	</span>	}
<span id="L232" class="ln">   232	</span>	p.conns[key] = append(p.conns[key], cc)
<span id="L233" class="ln">   233	</span>	p.keys[cc] = append(p.keys[cc], key)
<span id="L234" class="ln">   234	</span>}
<span id="L235" class="ln">   235	</span>
<span id="L236" class="ln">   236	</span>func (p *http2clientConnPool) MarkDead(cc *http2ClientConn) {
<span id="L237" class="ln">   237	</span>	p.mu.Lock()
<span id="L238" class="ln">   238	</span>	defer p.mu.Unlock()
<span id="L239" class="ln">   239	</span>	for _, key := range p.keys[cc] {
<span id="L240" class="ln">   240	</span>		vv, ok := p.conns[key]
<span id="L241" class="ln">   241	</span>		if !ok {
<span id="L242" class="ln">   242	</span>			continue
<span id="L243" class="ln">   243	</span>		}
<span id="L244" class="ln">   244	</span>		newList := http2filterOutClientConn(vv, cc)
<span id="L245" class="ln">   245	</span>		if len(newList) &gt; 0 {
<span id="L246" class="ln">   246	</span>			p.conns[key] = newList
<span id="L247" class="ln">   247	</span>		} else {
<span id="L248" class="ln">   248	</span>			delete(p.conns, key)
<span id="L249" class="ln">   249	</span>		}
<span id="L250" class="ln">   250	</span>	}
<span id="L251" class="ln">   251	</span>	delete(p.keys, cc)
<span id="L252" class="ln">   252	</span>}
<span id="L253" class="ln">   253	</span>
<span id="L254" class="ln">   254	</span>func (p *http2clientConnPool) closeIdleConnections() {
<span id="L255" class="ln">   255	</span>	p.mu.Lock()
<span id="L256" class="ln">   256	</span>	defer p.mu.Unlock()
<span id="L257" class="ln">   257	</span>
<span id="L258" class="ln">   258	</span>	for _, vv := range p.conns {
<span id="L259" class="ln">   259	</span>		for _, cc := range vv {
<span id="L260" class="ln">   260	</span>			cc.closeIfIdle()
<span id="L261" class="ln">   261	</span>		}
<span id="L262" class="ln">   262	</span>	}
<span id="L263" class="ln">   263	</span>}
<span id="L264" class="ln">   264	</span>
<span id="L265" class="ln">   265	</span>func http2filterOutClientConn(in []*http2ClientConn, exclude *http2ClientConn) []*http2ClientConn {
<span id="L266" class="ln">   266	</span>	out := in[:0]
<span id="L267" class="ln">   267	</span>	for _, v := range in {
<span id="L268" class="ln">   268	</span>		if v != exclude {
<span id="L269" class="ln">   269	</span>			out = append(out, v)
<span id="L270" class="ln">   270	</span>		}
<span id="L271" class="ln">   271	</span>	}
<span id="L272" class="ln">   272	</span>
<span id="L273" class="ln">   273	</span>	if len(in) != len(out) {
<span id="L274" class="ln">   274	</span>		in[len(in)-1] = nil
<span id="L275" class="ln">   275	</span>	}
<span id="L276" class="ln">   276	</span>	return out
<span id="L277" class="ln">   277	</span>}
<span id="L278" class="ln">   278	</span>
<span id="L279" class="ln">   279	</span><span class="comment">// noDialClientConnPool is an implementation of http2.ClientConnPool</span>
<span id="L280" class="ln">   280	</span><span class="comment">// which never dials.  We let the HTTP/1.1 client dial and use its TLS</span>
<span id="L281" class="ln">   281	</span><span class="comment">// connection instead.</span>
<span id="L282" class="ln">   282	</span>type http2noDialClientConnPool struct{ *http2clientConnPool }
<span id="L283" class="ln">   283	</span>
<span id="L284" class="ln">   284	</span>func (p http2noDialClientConnPool) GetClientConn(req *Request, addr string) (*http2ClientConn, error) {
<span id="L285" class="ln">   285	</span>	return p.getClientConn(req, addr, http2noDialOnMiss)
<span id="L286" class="ln">   286	</span>}
<span id="L287" class="ln">   287	</span>
<span id="L288" class="ln">   288	</span>func http2configureTransport(t1 *Transport) (*http2Transport, error) {
<span id="L289" class="ln">   289	</span>	connPool := new(http2clientConnPool)
<span id="L290" class="ln">   290	</span>	t2 := &amp;http2Transport{
<span id="L291" class="ln">   291	</span>		ConnPool: http2noDialClientConnPool{connPool},
<span id="L292" class="ln">   292	</span>		t1:       t1,
<span id="L293" class="ln">   293	</span>	}
<span id="L294" class="ln">   294	</span>	connPool.t = t2
<span id="L295" class="ln">   295	</span>	if err := http2registerHTTPSProtocol(t1, http2noDialH2RoundTripper{t2}); err != nil {
<span id="L296" class="ln">   296	</span>		return nil, err
<span id="L297" class="ln">   297	</span>	}
<span id="L298" class="ln">   298	</span>	if t1.TLSClientConfig == nil {
<span id="L299" class="ln">   299	</span>		t1.TLSClientConfig = new(tls.Config)
<span id="L300" class="ln">   300	</span>	}
<span id="L301" class="ln">   301	</span>	if !http2strSliceContains(t1.TLSClientConfig.NextProtos, &#34;h2&#34;) {
<span id="L302" class="ln">   302	</span>		t1.TLSClientConfig.NextProtos = append([]string{&#34;h2&#34;}, t1.TLSClientConfig.NextProtos...)
<span id="L303" class="ln">   303	</span>	}
<span id="L304" class="ln">   304	</span>	if !http2strSliceContains(t1.TLSClientConfig.NextProtos, &#34;http/1.1&#34;) {
<span id="L305" class="ln">   305	</span>		t1.TLSClientConfig.NextProtos = append(t1.TLSClientConfig.NextProtos, &#34;http/1.1&#34;)
<span id="L306" class="ln">   306	</span>	}
<span id="L307" class="ln">   307	</span>	upgradeFn := func(authority string, c *tls.Conn) RoundTripper {
<span id="L308" class="ln">   308	</span>		addr := http2authorityAddr(&#34;https&#34;, authority)
<span id="L309" class="ln">   309	</span>		if used, err := connPool.addConnIfNeeded(addr, t2, c); err != nil {
<span id="L310" class="ln">   310	</span>			go c.Close()
<span id="L311" class="ln">   311	</span>			return http2erringRoundTripper{err}
<span id="L312" class="ln">   312	</span>		} else if !used {
<span id="L313" class="ln">   313	</span>
<span id="L314" class="ln">   314	</span>			go c.Close()
<span id="L315" class="ln">   315	</span>		}
<span id="L316" class="ln">   316	</span>		return t2
<span id="L317" class="ln">   317	</span>	}
<span id="L318" class="ln">   318	</span>	if m := t1.TLSNextProto; len(m) == 0 {
<span id="L319" class="ln">   319	</span>		t1.TLSNextProto = map[string]func(string, *tls.Conn) RoundTripper{
<span id="L320" class="ln">   320	</span>			&#34;h2&#34;: upgradeFn,
<span id="L321" class="ln">   321	</span>		}
<span id="L322" class="ln">   322	</span>	} else {
<span id="L323" class="ln">   323	</span>		m[&#34;h2&#34;] = upgradeFn
<span id="L324" class="ln">   324	</span>	}
<span id="L325" class="ln">   325	</span>	return t2, nil
<span id="L326" class="ln">   326	</span>}
<span id="L327" class="ln">   327	</span>
<span id="L328" class="ln">   328	</span><span class="comment">// registerHTTPSProtocol calls Transport.RegisterProtocol but</span>
<span id="L329" class="ln">   329	</span><span class="comment">// convering panics into errors.</span>
<span id="L330" class="ln">   330	</span>func http2registerHTTPSProtocol(t *Transport, rt RoundTripper) (err error) {
<span id="L331" class="ln">   331	</span>	defer func() {
<span id="L332" class="ln">   332	</span>		if e := recover(); e != nil {
<span id="L333" class="ln">   333	</span>			err = fmt.Errorf(&#34;%v&#34;, e)
<span id="L334" class="ln">   334	</span>		}
<span id="L335" class="ln">   335	</span>	}()
<span id="L336" class="ln">   336	</span>	t.RegisterProtocol(&#34;https&#34;, rt)
<span id="L337" class="ln">   337	</span>	return nil
<span id="L338" class="ln">   338	</span>}
<span id="L339" class="ln">   339	</span>
<span id="L340" class="ln">   340	</span><span class="comment">// noDialH2RoundTripper is a RoundTripper which only tries to complete the request</span>
<span id="L341" class="ln">   341	</span><span class="comment">// if there&#39;s already has a cached connection to the host.</span>
<span id="L342" class="ln">   342	</span>type http2noDialH2RoundTripper struct{ t *http2Transport }
<span id="L343" class="ln">   343	</span>
<span id="L344" class="ln">   344	</span>func (rt http2noDialH2RoundTripper) RoundTrip(req *Request) (*Response, error) {
<span id="L345" class="ln">   345	</span>	res, err := rt.t.RoundTrip(req)
<span id="L346" class="ln">   346	</span>	if err == http2ErrNoCachedConn {
<span id="L347" class="ln">   347	</span>		return nil, ErrSkipAltProtocol
<span id="L348" class="ln">   348	</span>	}
<span id="L349" class="ln">   349	</span>	return res, err
<span id="L350" class="ln">   350	</span>}
<span id="L351" class="ln">   351	</span>
<span id="L352" class="ln">   352	</span><span class="comment">// An ErrCode is an unsigned 32-bit error code as defined in the HTTP/2 spec.</span>
<span id="L353" class="ln">   353	</span>type http2ErrCode uint32
<span id="L354" class="ln">   354	</span>
<span id="L355" class="ln">   355	</span>const (
<span id="L356" class="ln">   356	</span>	http2ErrCodeNo                 http2ErrCode = 0x0
<span id="L357" class="ln">   357	</span>	http2ErrCodeProtocol           http2ErrCode = 0x1
<span id="L358" class="ln">   358	</span>	http2ErrCodeInternal           http2ErrCode = 0x2
<span id="L359" class="ln">   359	</span>	http2ErrCodeFlowControl        http2ErrCode = 0x3
<span id="L360" class="ln">   360	</span>	http2ErrCodeSettingsTimeout    http2ErrCode = 0x4
<span id="L361" class="ln">   361	</span>	http2ErrCodeStreamClosed       http2ErrCode = 0x5
<span id="L362" class="ln">   362	</span>	http2ErrCodeFrameSize          http2ErrCode = 0x6
<span id="L363" class="ln">   363	</span>	http2ErrCodeRefusedStream      http2ErrCode = 0x7
<span id="L364" class="ln">   364	</span>	http2ErrCodeCancel             http2ErrCode = 0x8
<span id="L365" class="ln">   365	</span>	http2ErrCodeCompression        http2ErrCode = 0x9
<span id="L366" class="ln">   366	</span>	http2ErrCodeConnect            http2ErrCode = 0xa
<span id="L367" class="ln">   367	</span>	http2ErrCodeEnhanceYourCalm    http2ErrCode = 0xb
<span id="L368" class="ln">   368	</span>	http2ErrCodeInadequateSecurity http2ErrCode = 0xc
<span id="L369" class="ln">   369	</span>	http2ErrCodeHTTP11Required     http2ErrCode = 0xd
<span id="L370" class="ln">   370	</span>)
<span id="L371" class="ln">   371	</span>
<span id="L372" class="ln">   372	</span>var http2errCodeName = map[http2ErrCode]string{
<span id="L373" class="ln">   373	</span>	http2ErrCodeNo:                 &#34;NO_ERROR&#34;,
<span id="L374" class="ln">   374	</span>	http2ErrCodeProtocol:           &#34;PROTOCOL_ERROR&#34;,
<span id="L375" class="ln">   375	</span>	http2ErrCodeInternal:           &#34;INTERNAL_ERROR&#34;,
<span id="L376" class="ln">   376	</span>	http2ErrCodeFlowControl:        &#34;FLOW_CONTROL_ERROR&#34;,
<span id="L377" class="ln">   377	</span>	http2ErrCodeSettingsTimeout:    &#34;SETTINGS_TIMEOUT&#34;,
<span id="L378" class="ln">   378	</span>	http2ErrCodeStreamClosed:       &#34;STREAM_CLOSED&#34;,
<span id="L379" class="ln">   379	</span>	http2ErrCodeFrameSize:          &#34;FRAME_SIZE_ERROR&#34;,
<span id="L380" class="ln">   380	</span>	http2ErrCodeRefusedStream:      &#34;REFUSED_STREAM&#34;,
<span id="L381" class="ln">   381	</span>	http2ErrCodeCancel:             &#34;CANCEL&#34;,
<span id="L382" class="ln">   382	</span>	http2ErrCodeCompression:        &#34;COMPRESSION_ERROR&#34;,
<span id="L383" class="ln">   383	</span>	http2ErrCodeConnect:            &#34;CONNECT_ERROR&#34;,
<span id="L384" class="ln">   384	</span>	http2ErrCodeEnhanceYourCalm:    &#34;ENHANCE_YOUR_CALM&#34;,
<span id="L385" class="ln">   385	</span>	http2ErrCodeInadequateSecurity: &#34;INADEQUATE_SECURITY&#34;,
<span id="L386" class="ln">   386	</span>	http2ErrCodeHTTP11Required:     &#34;HTTP_1_1_REQUIRED&#34;,
<span id="L387" class="ln">   387	</span>}
<span id="L388" class="ln">   388	</span>
<span id="L389" class="ln">   389	</span>func (e http2ErrCode) String() string {
<span id="L390" class="ln">   390	</span>	if s, ok := http2errCodeName[e]; ok {
<span id="L391" class="ln">   391	</span>		return s
<span id="L392" class="ln">   392	</span>	}
<span id="L393" class="ln">   393	</span>	return fmt.Sprintf(&#34;unknown error code 0x%x&#34;, uint32(e))
<span id="L394" class="ln">   394	</span>}
<span id="L395" class="ln">   395	</span>
<span id="L396" class="ln">   396	</span><span class="comment">// ConnectionError is an error that results in the termination of the</span>
<span id="L397" class="ln">   397	</span><span class="comment">// entire connection.</span>
<span id="L398" class="ln">   398	</span>type http2ConnectionError http2ErrCode
<span id="L399" class="ln">   399	</span>
<span id="L400" class="ln">   400	</span>func (e http2ConnectionError) Error() string {
<span id="L401" class="ln">   401	</span>	return fmt.Sprintf(&#34;connection error: %s&#34;, http2ErrCode(e))
<span id="L402" class="ln">   402	</span>}
<span id="L403" class="ln">   403	</span>
<span id="L404" class="ln">   404	</span><span class="comment">// StreamError is an error that only affects one stream within an</span>
<span id="L405" class="ln">   405	</span><span class="comment">// HTTP/2 connection.</span>
<span id="L406" class="ln">   406	</span>type http2StreamError struct {
<span id="L407" class="ln">   407	</span>	StreamID uint32
<span id="L408" class="ln">   408	</span>	Code     http2ErrCode
<span id="L409" class="ln">   409	</span>	Cause    error <span class="comment">// optional additional detail</span>
<span id="L410" class="ln">   410	</span>}
<span id="L411" class="ln">   411	</span>
<span id="L412" class="ln">   412	</span>func http2streamError(id uint32, code http2ErrCode) http2StreamError {
<span id="L413" class="ln">   413	</span>	return http2StreamError{StreamID: id, Code: code}
<span id="L414" class="ln">   414	</span>}
<span id="L415" class="ln">   415	</span>
<span id="L416" class="ln">   416	</span>func (e http2StreamError) Error() string {
<span id="L417" class="ln">   417	</span>	if e.Cause != nil {
<span id="L418" class="ln">   418	</span>		return fmt.Sprintf(&#34;stream error: stream ID %d; %v; %v&#34;, e.StreamID, e.Code, e.Cause)
<span id="L419" class="ln">   419	</span>	}
<span id="L420" class="ln">   420	</span>	return fmt.Sprintf(&#34;stream error: stream ID %d; %v&#34;, e.StreamID, e.Code)
<span id="L421" class="ln">   421	</span>}
<span id="L422" class="ln">   422	</span>
<span id="L423" class="ln">   423	</span><span class="comment">// 6.9.1 The Flow Control Window</span>
<span id="L424" class="ln">   424	</span><span class="comment">// &#34;If a sender receives a WINDOW_UPDATE that causes a flow control</span>
<span id="L425" class="ln">   425	</span><span class="comment">// window to exceed this maximum it MUST terminate either the stream</span>
<span id="L426" class="ln">   426	</span><span class="comment">// or the connection, as appropriate. For streams, [...]; for the</span>
<span id="L427" class="ln">   427	</span><span class="comment">// connection, a GOAWAY frame with a FLOW_CONTROL_ERROR code.&#34;</span>
<span id="L428" class="ln">   428	</span>type http2goAwayFlowError struct{}
<span id="L429" class="ln">   429	</span>
<span id="L430" class="ln">   430	</span>func (http2goAwayFlowError) Error() string { return &#34;connection exceeded flow control window size&#34; }
<span id="L431" class="ln">   431	</span>
<span id="L432" class="ln">   432	</span><span class="comment">// Errors of this type are only returned by the frame parser functions</span>
<span id="L433" class="ln">   433	</span><span class="comment">// and converted into ConnectionError(ErrCodeProtocol).</span>
<span id="L434" class="ln">   434	</span>type http2connError struct {
<span id="L435" class="ln">   435	</span>	Code   http2ErrCode
<span id="L436" class="ln">   436	</span>	Reason string
<span id="L437" class="ln">   437	</span>}
<span id="L438" class="ln">   438	</span>
<span id="L439" class="ln">   439	</span>func (e http2connError) Error() string {
<span id="L440" class="ln">   440	</span>	return fmt.Sprintf(&#34;http2: connection error: %v: %v&#34;, e.Code, e.Reason)
<span id="L441" class="ln">   441	</span>}
<span id="L442" class="ln">   442	</span>
<span id="L443" class="ln">   443	</span>type http2pseudoHeaderError string
<span id="L444" class="ln">   444	</span>
<span id="L445" class="ln">   445	</span>func (e http2pseudoHeaderError) Error() string {
<span id="L446" class="ln">   446	</span>	return fmt.Sprintf(&#34;invalid pseudo-header %q&#34;, string(e))
<span id="L447" class="ln">   447	</span>}
<span id="L448" class="ln">   448	</span>
<span id="L449" class="ln">   449	</span>type http2duplicatePseudoHeaderError string
<span id="L450" class="ln">   450	</span>
<span id="L451" class="ln">   451	</span>func (e http2duplicatePseudoHeaderError) Error() string {
<span id="L452" class="ln">   452	</span>	return fmt.Sprintf(&#34;duplicate pseudo-header %q&#34;, string(e))
<span id="L453" class="ln">   453	</span>}
<span id="L454" class="ln">   454	</span>
<span id="L455" class="ln">   455	</span>type http2headerFieldNameError string
<span id="L456" class="ln">   456	</span>
<span id="L457" class="ln">   457	</span>func (e http2headerFieldNameError) Error() string {
<span id="L458" class="ln">   458	</span>	return fmt.Sprintf(&#34;invalid header field name %q&#34;, string(e))
<span id="L459" class="ln">   459	</span>}
<span id="L460" class="ln">   460	</span>
<span id="L461" class="ln">   461	</span>type http2headerFieldValueError string
<span id="L462" class="ln">   462	</span>
<span id="L463" class="ln">   463	</span>func (e http2headerFieldValueError) Error() string {
<span id="L464" class="ln">   464	</span>	return fmt.Sprintf(&#34;invalid header field value %q&#34;, string(e))
<span id="L465" class="ln">   465	</span>}
<span id="L466" class="ln">   466	</span>
<span id="L467" class="ln">   467	</span>var (
<span id="L468" class="ln">   468	</span>	http2errMixPseudoHeaderTypes = errors.New(&#34;mix of request and response pseudo headers&#34;)
<span id="L469" class="ln">   469	</span>	http2errPseudoAfterRegular   = errors.New(&#34;pseudo header field after regular&#34;)
<span id="L470" class="ln">   470	</span>)
<span id="L471" class="ln">   471	</span>
<span id="L472" class="ln">   472	</span><span class="comment">// fixedBuffer is an io.ReadWriter backed by a fixed size buffer.</span>
<span id="L473" class="ln">   473	</span><span class="comment">// It never allocates, but moves old data as new data is written.</span>
<span id="L474" class="ln">   474	</span>type http2fixedBuffer struct {
<span id="L475" class="ln">   475	</span>	buf  []byte
<span id="L476" class="ln">   476	</span>	r, w int
<span id="L477" class="ln">   477	</span>}
<span id="L478" class="ln">   478	</span>
<span id="L479" class="ln">   479	</span>var (
<span id="L480" class="ln">   480	</span>	http2errReadEmpty = errors.New(&#34;read from empty fixedBuffer&#34;)
<span id="L481" class="ln">   481	</span>	http2errWriteFull = errors.New(&#34;write on full fixedBuffer&#34;)
<span id="L482" class="ln">   482	</span>)
<span id="L483" class="ln">   483	</span>
<span id="L484" class="ln">   484	</span><span class="comment">// Read copies bytes from the buffer into p.</span>
<span id="L485" class="ln">   485	</span><span class="comment">// It is an error to read when no data is available.</span>
<span id="L486" class="ln">   486	</span>func (b *http2fixedBuffer) Read(p []byte) (n int, err error) {
<span id="L487" class="ln">   487	</span>	if b.r == b.w {
<span id="L488" class="ln">   488	</span>		return 0, http2errReadEmpty
<span id="L489" class="ln">   489	</span>	}
<span id="L490" class="ln">   490	</span>	n = copy(p, b.buf[b.r:b.w])
<span id="L491" class="ln">   491	</span>	b.r += n
<span id="L492" class="ln">   492	</span>	if b.r == b.w {
<span id="L493" class="ln">   493	</span>		b.r = 0
<span id="L494" class="ln">   494	</span>		b.w = 0
<span id="L495" class="ln">   495	</span>	}
<span id="L496" class="ln">   496	</span>	return n, nil
<span id="L497" class="ln">   497	</span>}
<span id="L498" class="ln">   498	</span>
<span id="L499" class="ln">   499	</span><span class="comment">// Len returns the number of bytes of the unread portion of the buffer.</span>
<span id="L500" class="ln">   500	</span>func (b *http2fixedBuffer) Len() int {
<span id="L501" class="ln">   501	</span>	return b.w - b.r
<span id="L502" class="ln">   502	</span>}
<span id="L503" class="ln">   503	</span>
<span id="L504" class="ln">   504	</span><span class="comment">// Write copies bytes from p into the buffer.</span>
<span id="L505" class="ln">   505	</span><span class="comment">// It is an error to write more data than the buffer can hold.</span>
<span id="L506" class="ln">   506	</span>func (b *http2fixedBuffer) Write(p []byte) (n int, err error) {
<span id="L507" class="ln">   507	</span>
<span id="L508" class="ln">   508	</span>	if b.r &gt; 0 &amp;&amp; len(p) &gt; len(b.buf)-b.w {
<span id="L509" class="ln">   509	</span>		copy(b.buf, b.buf[b.r:b.w])
<span id="L510" class="ln">   510	</span>		b.w -= b.r
<span id="L511" class="ln">   511	</span>		b.r = 0
<span id="L512" class="ln">   512	</span>	}
<span id="L513" class="ln">   513	</span>
<span id="L514" class="ln">   514	</span>	n = copy(b.buf[b.w:], p)
<span id="L515" class="ln">   515	</span>	b.w += n
<span id="L516" class="ln">   516	</span>	if n &lt; len(p) {
<span id="L517" class="ln">   517	</span>		err = http2errWriteFull
<span id="L518" class="ln">   518	</span>	}
<span id="L519" class="ln">   519	</span>	return n, err
<span id="L520" class="ln">   520	</span>}
<span id="L521" class="ln">   521	</span>
<span id="L522" class="ln">   522	</span><span class="comment">// flow is the flow control window&#39;s size.</span>
<span id="L523" class="ln">   523	</span>type http2flow struct {
<span id="L524" class="ln">   524	</span>	<span class="comment">// n is the number of DATA bytes we&#39;re allowed to send.</span>
<span id="L525" class="ln">   525	</span>	<span class="comment">// A flow is kept both on a conn and a per-stream.</span>
<span id="L526" class="ln">   526	</span>	n int32
<span id="L527" class="ln">   527	</span>
<span id="L528" class="ln">   528	</span>	<span class="comment">// conn points to the shared connection-level flow that is</span>
<span id="L529" class="ln">   529	</span>	<span class="comment">// shared by all streams on that conn. It is nil for the flow</span>
<span id="L530" class="ln">   530	</span>	<span class="comment">// that&#39;s on the conn directly.</span>
<span id="L531" class="ln">   531	</span>	conn *http2flow
<span id="L532" class="ln">   532	</span>}
<span id="L533" class="ln">   533	</span>
<span id="L534" class="ln">   534	</span>func (f *http2flow) setConnFlow(cf *http2flow) { f.conn = cf }
<span id="L535" class="ln">   535	</span>
<span id="L536" class="ln">   536	</span>func (f *http2flow) available() int32 {
<span id="L537" class="ln">   537	</span>	n := f.n
<span id="L538" class="ln">   538	</span>	if f.conn != nil &amp;&amp; f.conn.n &lt; n {
<span id="L539" class="ln">   539	</span>		n = f.conn.n
<span id="L540" class="ln">   540	</span>	}
<span id="L541" class="ln">   541	</span>	return n
<span id="L542" class="ln">   542	</span>}
<span id="L543" class="ln">   543	</span>
<span id="L544" class="ln">   544	</span>func (f *http2flow) take(n int32) {
<span id="L545" class="ln">   545	</span>	if n &gt; f.available() {
<span id="L546" class="ln">   546	</span>		panic(&#34;internal error: took too much&#34;)
<span id="L547" class="ln">   547	</span>	}
<span id="L548" class="ln">   548	</span>	f.n -= n
<span id="L549" class="ln">   549	</span>	if f.conn != nil {
<span id="L550" class="ln">   550	</span>		f.conn.n -= n
<span id="L551" class="ln">   551	</span>	}
<span id="L552" class="ln">   552	</span>}
<span id="L553" class="ln">   553	</span>
<span id="L554" class="ln">   554	</span><span class="comment">// add adds n bytes (positive or negative) to the flow control window.</span>
<span id="L555" class="ln">   555	</span><span class="comment">// It returns false if the sum would exceed 2^31-1.</span>
<span id="L556" class="ln">   556	</span>func (f *http2flow) add(n int32) bool {
<span id="L557" class="ln">   557	</span>	remain := (1&lt;&lt;31 - 1) - f.n
<span id="L558" class="ln">   558	</span>	if n &gt; remain {
<span id="L559" class="ln">   559	</span>		return false
<span id="L560" class="ln">   560	</span>	}
<span id="L561" class="ln">   561	</span>	f.n += n
<span id="L562" class="ln">   562	</span>	return true
<span id="L563" class="ln">   563	</span>}
<span id="L564" class="ln">   564	</span>
<span id="L565" class="ln">   565	</span>const http2frameHeaderLen = 9
<span id="L566" class="ln">   566	</span>
<span id="L567" class="ln">   567	</span>var http2padZeros = make([]byte, 255) <span class="comment">// zeros for padding</span>
<span id="L568" class="ln">   568	</span>
<span id="L569" class="ln">   569	</span><span class="comment">// A FrameType is a registered frame type as defined in</span>
<span id="L570" class="ln">   570	</span><span class="comment">// http://http2.github.io/http2-spec/#rfc.section.11.2</span>
<span id="L571" class="ln">   571	</span>type http2FrameType uint8
<span id="L572" class="ln">   572	</span>
<span id="L573" class="ln">   573	</span>const (
<span id="L574" class="ln">   574	</span>	http2FrameData         http2FrameType = 0x0
<span id="L575" class="ln">   575	</span>	http2FrameHeaders      http2FrameType = 0x1
<span id="L576" class="ln">   576	</span>	http2FramePriority     http2FrameType = 0x2
<span id="L577" class="ln">   577	</span>	http2FrameRSTStream    http2FrameType = 0x3
<span id="L578" class="ln">   578	</span>	http2FrameSettings     http2FrameType = 0x4
<span id="L579" class="ln">   579	</span>	http2FramePushPromise  http2FrameType = 0x5
<span id="L580" class="ln">   580	</span>	http2FramePing         http2FrameType = 0x6
<span id="L581" class="ln">   581	</span>	http2FrameGoAway       http2FrameType = 0x7
<span id="L582" class="ln">   582	</span>	http2FrameWindowUpdate http2FrameType = 0x8
<span id="L583" class="ln">   583	</span>	http2FrameContinuation http2FrameType = 0x9
<span id="L584" class="ln">   584	</span>)
<span id="L585" class="ln">   585	</span>
<span id="L586" class="ln">   586	</span>var http2frameName = map[http2FrameType]string{
<span id="L587" class="ln">   587	</span>	http2FrameData:         &#34;DATA&#34;,
<span id="L588" class="ln">   588	</span>	http2FrameHeaders:      &#34;HEADERS&#34;,
<span id="L589" class="ln">   589	</span>	http2FramePriority:     &#34;PRIORITY&#34;,
<span id="L590" class="ln">   590	</span>	http2FrameRSTStream:    &#34;RST_STREAM&#34;,
<span id="L591" class="ln">   591	</span>	http2FrameSettings:     &#34;SETTINGS&#34;,
<span id="L592" class="ln">   592	</span>	http2FramePushPromise:  &#34;PUSH_PROMISE&#34;,
<span id="L593" class="ln">   593	</span>	http2FramePing:         &#34;PING&#34;,
<span id="L594" class="ln">   594	</span>	http2FrameGoAway:       &#34;GOAWAY&#34;,
<span id="L595" class="ln">   595	</span>	http2FrameWindowUpdate: &#34;WINDOW_UPDATE&#34;,
<span id="L596" class="ln">   596	</span>	http2FrameContinuation: &#34;CONTINUATION&#34;,
<span id="L597" class="ln">   597	</span>}
<span id="L598" class="ln">   598	</span>
<span id="L599" class="ln">   599	</span>func (t http2FrameType) String() string {
<span id="L600" class="ln">   600	</span>	if s, ok := http2frameName[t]; ok {
<span id="L601" class="ln">   601	</span>		return s
<span id="L602" class="ln">   602	</span>	}
<span id="L603" class="ln">   603	</span>	return fmt.Sprintf(&#34;UNKNOWN_FRAME_TYPE_%d&#34;, uint8(t))
<span id="L604" class="ln">   604	</span>}
<span id="L605" class="ln">   605	</span>
<span id="L606" class="ln">   606	</span><span class="comment">// Flags is a bitmask of HTTP/2 flags.</span>
<span id="L607" class="ln">   607	</span><span class="comment">// The meaning of flags varies depending on the frame type.</span>
<span id="L608" class="ln">   608	</span>type http2Flags uint8
<span id="L609" class="ln">   609	</span>
<span id="L610" class="ln">   610	</span><span class="comment">// Has reports whether f contains all (0 or more) flags in v.</span>
<span id="L611" class="ln">   611	</span>func (f http2Flags) Has(v http2Flags) bool {
<span id="L612" class="ln">   612	</span>	return (f &amp; v) == v
<span id="L613" class="ln">   613	</span>}
<span id="L614" class="ln">   614	</span>
<span id="L615" class="ln">   615	</span><span class="comment">// Frame-specific FrameHeader flag bits.</span>
<span id="L616" class="ln">   616	</span>const (
<span id="L617" class="ln">   617	</span>	<span class="comment">// Data Frame</span>
<span id="L618" class="ln">   618	</span>	http2FlagDataEndStream http2Flags = 0x1
<span id="L619" class="ln">   619	</span>	http2FlagDataPadded    http2Flags = 0x8
<span id="L620" class="ln">   620	</span>
<span id="L621" class="ln">   621	</span>	<span class="comment">// Headers Frame</span>
<span id="L622" class="ln">   622	</span>	http2FlagHeadersEndStream  http2Flags = 0x1
<span id="L623" class="ln">   623	</span>	http2FlagHeadersEndHeaders http2Flags = 0x4
<span id="L624" class="ln">   624	</span>	http2FlagHeadersPadded     http2Flags = 0x8
<span id="L625" class="ln">   625	</span>	http2FlagHeadersPriority   http2Flags = 0x20
<span id="L626" class="ln">   626	</span>
<span id="L627" class="ln">   627	</span>	<span class="comment">// Settings Frame</span>
<span id="L628" class="ln">   628	</span>	http2FlagSettingsAck http2Flags = 0x1
<span id="L629" class="ln">   629	</span>
<span id="L630" class="ln">   630	</span>	<span class="comment">// Ping Frame</span>
<span id="L631" class="ln">   631	</span>	http2FlagPingAck http2Flags = 0x1
<span id="L632" class="ln">   632	</span>
<span id="L633" class="ln">   633	</span>	<span class="comment">// Continuation Frame</span>
<span id="L634" class="ln">   634	</span>	http2FlagContinuationEndHeaders http2Flags = 0x4
<span id="L635" class="ln">   635	</span>
<span id="L636" class="ln">   636	</span>	http2FlagPushPromiseEndHeaders http2Flags = 0x4
<span id="L637" class="ln">   637	</span>	http2FlagPushPromisePadded     http2Flags = 0x8
<span id="L638" class="ln">   638	</span>)
<span id="L639" class="ln">   639	</span>
<span id="L640" class="ln">   640	</span>var http2flagName = map[http2FrameType]map[http2Flags]string{
<span id="L641" class="ln">   641	</span>	http2FrameData: {
<span id="L642" class="ln">   642	</span>		http2FlagDataEndStream: &#34;END_STREAM&#34;,
<span id="L643" class="ln">   643	</span>		http2FlagDataPadded:    &#34;PADDED&#34;,
<span id="L644" class="ln">   644	</span>	},
<span id="L645" class="ln">   645	</span>	http2FrameHeaders: {
<span id="L646" class="ln">   646	</span>		http2FlagHeadersEndStream:  &#34;END_STREAM&#34;,
<span id="L647" class="ln">   647	</span>		http2FlagHeadersEndHeaders: &#34;END_HEADERS&#34;,
<span id="L648" class="ln">   648	</span>		http2FlagHeadersPadded:     &#34;PADDED&#34;,
<span id="L649" class="ln">   649	</span>		http2FlagHeadersPriority:   &#34;PRIORITY&#34;,
<span id="L650" class="ln">   650	</span>	},
<span id="L651" class="ln">   651	</span>	http2FrameSettings: {
<span id="L652" class="ln">   652	</span>		http2FlagSettingsAck: &#34;ACK&#34;,
<span id="L653" class="ln">   653	</span>	},
<span id="L654" class="ln">   654	</span>	http2FramePing: {
<span id="L655" class="ln">   655	</span>		http2FlagPingAck: &#34;ACK&#34;,
<span id="L656" class="ln">   656	</span>	},
<span id="L657" class="ln">   657	</span>	http2FrameContinuation: {
<span id="L658" class="ln">   658	</span>		http2FlagContinuationEndHeaders: &#34;END_HEADERS&#34;,
<span id="L659" class="ln">   659	</span>	},
<span id="L660" class="ln">   660	</span>	http2FramePushPromise: {
<span id="L661" class="ln">   661	</span>		http2FlagPushPromiseEndHeaders: &#34;END_HEADERS&#34;,
<span id="L662" class="ln">   662	</span>		http2FlagPushPromisePadded:     &#34;PADDED&#34;,
<span id="L663" class="ln">   663	</span>	},
<span id="L664" class="ln">   664	</span>}
<span id="L665" class="ln">   665	</span>
<span id="L666" class="ln">   666	</span><span class="comment">// a frameParser parses a frame given its FrameHeader and payload</span>
<span id="L667" class="ln">   667	</span><span class="comment">// bytes. The length of payload will always equal fh.Length (which</span>
<span id="L668" class="ln">   668	</span><span class="comment">// might be 0).</span>
<span id="L669" class="ln">   669	</span>type http2frameParser func(fh http2FrameHeader, payload []byte) (http2Frame, error)
<span id="L670" class="ln">   670	</span>
<span id="L671" class="ln">   671	</span>var http2frameParsers = map[http2FrameType]http2frameParser{
<span id="L672" class="ln">   672	</span>	http2FrameData:         http2parseDataFrame,
<span id="L673" class="ln">   673	</span>	http2FrameHeaders:      http2parseHeadersFrame,
<span id="L674" class="ln">   674	</span>	http2FramePriority:     http2parsePriorityFrame,
<span id="L675" class="ln">   675	</span>	http2FrameRSTStream:    http2parseRSTStreamFrame,
<span id="L676" class="ln">   676	</span>	http2FrameSettings:     http2parseSettingsFrame,
<span id="L677" class="ln">   677	</span>	http2FramePushPromise:  http2parsePushPromise,
<span id="L678" class="ln">   678	</span>	http2FramePing:         http2parsePingFrame,
<span id="L679" class="ln">   679	</span>	http2FrameGoAway:       http2parseGoAwayFrame,
<span id="L680" class="ln">   680	</span>	http2FrameWindowUpdate: http2parseWindowUpdateFrame,
<span id="L681" class="ln">   681	</span>	http2FrameContinuation: http2parseContinuationFrame,
<span id="L682" class="ln">   682	</span>}
<span id="L683" class="ln">   683	</span>
<span id="L684" class="ln">   684	</span>func http2typeFrameParser(t http2FrameType) http2frameParser {
<span id="L685" class="ln">   685	</span>	if f := http2frameParsers[t]; f != nil {
<span id="L686" class="ln">   686	</span>		return f
<span id="L687" class="ln">   687	</span>	}
<span id="L688" class="ln">   688	</span>	return http2parseUnknownFrame
<span id="L689" class="ln">   689	</span>}
<span id="L690" class="ln">   690	</span>
<span id="L691" class="ln">   691	</span><span class="comment">// A FrameHeader is the 9 byte header of all HTTP/2 frames.</span>
<span id="L692" class="ln">   692	</span><span class="comment">//</span>
<span id="L693" class="ln">   693	</span><span class="comment">// See http://http2.github.io/http2-spec/#FrameHeader</span>
<span id="L694" class="ln">   694	</span>type http2FrameHeader struct {
<span id="L695" class="ln">   695	</span>	valid bool <span class="comment">// caller can access []byte fields in the Frame</span>
<span id="L696" class="ln">   696	</span>
<span id="L697" class="ln">   697	</span>	<span class="comment">// Type is the 1 byte frame type. There are ten standard frame</span>
<span id="L698" class="ln">   698	</span>	<span class="comment">// types, but extension frame types may be written by WriteRawFrame</span>
<span id="L699" class="ln">   699	</span>	<span class="comment">// and will be returned by ReadFrame (as UnknownFrame).</span>
<span id="L700" class="ln">   700	</span>	Type http2FrameType
<span id="L701" class="ln">   701	</span>
<span id="L702" class="ln">   702	</span>	<span class="comment">// Flags are the 1 byte of 8 potential bit flags per frame.</span>
<span id="L703" class="ln">   703	</span>	<span class="comment">// They are specific to the frame type.</span>
<span id="L704" class="ln">   704	</span>	Flags http2Flags
<span id="L705" class="ln">   705	</span>
<span id="L706" class="ln">   706	</span>	<span class="comment">// Length is the length of the frame, not including the 9 byte header.</span>
<span id="L707" class="ln">   707	</span>	<span class="comment">// The maximum size is one byte less than 16MB (uint24), but only</span>
<span id="L708" class="ln">   708	</span>	<span class="comment">// frames up to 16KB are allowed without peer agreement.</span>
<span id="L709" class="ln">   709	</span>	Length uint32
<span id="L710" class="ln">   710	</span>
<span id="L711" class="ln">   711	</span>	<span class="comment">// StreamID is which stream this frame is for. Certain frames</span>
<span id="L712" class="ln">   712	</span>	<span class="comment">// are not stream-specific, in which case this field is 0.</span>
<span id="L713" class="ln">   713	</span>	StreamID uint32
<span id="L714" class="ln">   714	</span>}
<span id="L715" class="ln">   715	</span>
<span id="L716" class="ln">   716	</span><span class="comment">// Header returns h. It exists so FrameHeaders can be embedded in other</span>
<span id="L717" class="ln">   717	</span><span class="comment">// specific frame types and implement the Frame interface.</span>
<span id="L718" class="ln">   718	</span>func (h http2FrameHeader) Header() http2FrameHeader { return h }
<span id="L719" class="ln">   719	</span>
<span id="L720" class="ln">   720	</span>func (h http2FrameHeader) String() string {
<span id="L721" class="ln">   721	</span>	var buf bytes.Buffer
<span id="L722" class="ln">   722	</span>	buf.WriteString(&#34;[FrameHeader &#34;)
<span id="L723" class="ln">   723	</span>	h.writeDebug(&amp;buf)
<span id="L724" class="ln">   724	</span>	buf.WriteByte(&#39;]&#39;)
<span id="L725" class="ln">   725	</span>	return buf.String()
<span id="L726" class="ln">   726	</span>}
<span id="L727" class="ln">   727	</span>
<span id="L728" class="ln">   728	</span>func (h http2FrameHeader) writeDebug(buf *bytes.Buffer) {
<span id="L729" class="ln">   729	</span>	buf.WriteString(h.Type.String())
<span id="L730" class="ln">   730	</span>	if h.Flags != 0 {
<span id="L731" class="ln">   731	</span>		buf.WriteString(&#34; flags=&#34;)
<span id="L732" class="ln">   732	</span>		set := 0
<span id="L733" class="ln">   733	</span>		for i := uint8(0); i &lt; 8; i++ {
<span id="L734" class="ln">   734	</span>			if h.Flags&amp;(1&lt;&lt;i) == 0 {
<span id="L735" class="ln">   735	</span>				continue
<span id="L736" class="ln">   736	</span>			}
<span id="L737" class="ln">   737	</span>			set++
<span id="L738" class="ln">   738	</span>			if set &gt; 1 {
<span id="L739" class="ln">   739	</span>				buf.WriteByte(&#39;|&#39;)
<span id="L740" class="ln">   740	</span>			}
<span id="L741" class="ln">   741	</span>			name := http2flagName[h.Type][http2Flags(1&lt;&lt;i)]
<span id="L742" class="ln">   742	</span>			if name != &#34;&#34; {
<span id="L743" class="ln">   743	</span>				buf.WriteString(name)
<span id="L744" class="ln">   744	</span>			} else {
<span id="L745" class="ln">   745	</span>				fmt.Fprintf(buf, &#34;0x%x&#34;, 1&lt;&lt;i)
<span id="L746" class="ln">   746	</span>			}
<span id="L747" class="ln">   747	</span>		}
<span id="L748" class="ln">   748	</span>	}
<span id="L749" class="ln">   749	</span>	if h.StreamID != 0 {
<span id="L750" class="ln">   750	</span>		fmt.Fprintf(buf, &#34; stream=%d&#34;, h.StreamID)
<span id="L751" class="ln">   751	</span>	}
<span id="L752" class="ln">   752	</span>	fmt.Fprintf(buf, &#34; len=%d&#34;, h.Length)
<span id="L753" class="ln">   753	</span>}
<span id="L754" class="ln">   754	</span>
<span id="L755" class="ln">   755	</span>func (h *http2FrameHeader) checkValid() {
<span id="L756" class="ln">   756	</span>	if !h.valid {
<span id="L757" class="ln">   757	</span>		panic(&#34;Frame accessor called on non-owned Frame&#34;)
<span id="L758" class="ln">   758	</span>	}
<span id="L759" class="ln">   759	</span>}
<span id="L760" class="ln">   760	</span>
<span id="L761" class="ln">   761	</span>func (h *http2FrameHeader) invalidate() { h.valid = false }
<span id="L762" class="ln">   762	</span>
<span id="L763" class="ln">   763	</span><span class="comment">// frame header bytes.</span>
<span id="L764" class="ln">   764	</span><span class="comment">// Used only by ReadFrameHeader.</span>
<span id="L765" class="ln">   765	</span>var http2fhBytes = sync.Pool{
<span id="L766" class="ln">   766	</span>	New: func() interface{} {
<span id="L767" class="ln">   767	</span>		buf := make([]byte, http2frameHeaderLen)
<span id="L768" class="ln">   768	</span>		return &amp;buf
<span id="L769" class="ln">   769	</span>	},
<span id="L770" class="ln">   770	</span>}
<span id="L771" class="ln">   771	</span>
<span id="L772" class="ln">   772	</span><span class="comment">// ReadFrameHeader reads 9 bytes from r and returns a FrameHeader.</span>
<span id="L773" class="ln">   773	</span><span class="comment">// Most users should use Framer.ReadFrame instead.</span>
<span id="L774" class="ln">   774	</span>func http2ReadFrameHeader(r io.Reader) (http2FrameHeader, error) {
<span id="L775" class="ln">   775	</span>	bufp := http2fhBytes.Get().(*[]byte)
<span id="L776" class="ln">   776	</span>	defer http2fhBytes.Put(bufp)
<span id="L777" class="ln">   777	</span>	return http2readFrameHeader(*bufp, r)
<span id="L778" class="ln">   778	</span>}
<span id="L779" class="ln">   779	</span>
<span id="L780" class="ln">   780	</span>func http2readFrameHeader(buf []byte, r io.Reader) (http2FrameHeader, error) {
<span id="L781" class="ln">   781	</span>	_, err := io.ReadFull(r, buf[:http2frameHeaderLen])
<span id="L782" class="ln">   782	</span>	if err != nil {
<span id="L783" class="ln">   783	</span>		return http2FrameHeader{}, err
<span id="L784" class="ln">   784	</span>	}
<span id="L785" class="ln">   785	</span>	return http2FrameHeader{
<span id="L786" class="ln">   786	</span>		Length:   (uint32(buf[0])&lt;&lt;16 | uint32(buf[1])&lt;&lt;8 | uint32(buf[2])),
<span id="L787" class="ln">   787	</span>		Type:     http2FrameType(buf[3]),
<span id="L788" class="ln">   788	</span>		Flags:    http2Flags(buf[4]),
<span id="L789" class="ln">   789	</span>		StreamID: binary.BigEndian.Uint32(buf[5:]) &amp; (1&lt;&lt;31 - 1),
<span id="L790" class="ln">   790	</span>		valid:    true,
<span id="L791" class="ln">   791	</span>	}, nil
<span id="L792" class="ln">   792	</span>}
<span id="L793" class="ln">   793	</span>
<span id="L794" class="ln">   794	</span><span class="comment">// A Frame is the base interface implemented by all frame types.</span>
<span id="L795" class="ln">   795	</span><span class="comment">// Callers will generally type-assert the specific frame type:</span>
<span id="L796" class="ln">   796	</span><span class="comment">// *HeadersFrame, *SettingsFrame, *WindowUpdateFrame, etc.</span>
<span id="L797" class="ln">   797	</span><span class="comment">//</span>
<span id="L798" class="ln">   798	</span><span class="comment">// Frames are only valid until the next call to Framer.ReadFrame.</span>
<span id="L799" class="ln">   799	</span>type http2Frame interface {
<span id="L800" class="ln">   800	</span>	Header() http2FrameHeader
<span id="L801" class="ln">   801	</span>
<span id="L802" class="ln">   802	</span>	<span class="comment">// invalidate is called by Framer.ReadFrame to make this</span>
<span id="L803" class="ln">   803	</span>	<span class="comment">// frame&#39;s buffers as being invalid, since the subsequent</span>
<span id="L804" class="ln">   804	</span>	<span class="comment">// frame will reuse them.</span>
<span id="L805" class="ln">   805	</span>	invalidate()
<span id="L806" class="ln">   806	</span>}
<span id="L807" class="ln">   807	</span>
<span id="L808" class="ln">   808	</span><span class="comment">// A Framer reads and writes Frames.</span>
<span id="L809" class="ln">   809	</span>type http2Framer struct {
<span id="L810" class="ln">   810	</span>	r         io.Reader
<span id="L811" class="ln">   811	</span>	lastFrame http2Frame
<span id="L812" class="ln">   812	</span>	errDetail error
<span id="L813" class="ln">   813	</span>
<span id="L814" class="ln">   814	</span>	<span class="comment">// lastHeaderStream is non-zero if the last frame was an</span>
<span id="L815" class="ln">   815	</span>	<span class="comment">// unfinished HEADERS/CONTINUATION.</span>
<span id="L816" class="ln">   816	</span>	lastHeaderStream uint32
<span id="L817" class="ln">   817	</span>
<span id="L818" class="ln">   818	</span>	maxReadSize uint32
<span id="L819" class="ln">   819	</span>	headerBuf   [http2frameHeaderLen]byte
<span id="L820" class="ln">   820	</span>
<span id="L821" class="ln">   821	</span>	<span class="comment">// TODO: let getReadBuf be configurable, and use a less memory-pinning</span>
<span id="L822" class="ln">   822	</span>	<span class="comment">// allocator in server.go to minimize memory pinned for many idle conns.</span>
<span id="L823" class="ln">   823	</span>	<span class="comment">// Will probably also need to make frame invalidation have a hook too.</span>
<span id="L824" class="ln">   824	</span>	getReadBuf func(size uint32) []byte
<span id="L825" class="ln">   825	</span>	readBuf    []byte <span class="comment">// cache for default getReadBuf</span>
<span id="L826" class="ln">   826	</span>
<span id="L827" class="ln">   827	</span>	maxWriteSize uint32 <span class="comment">// zero means unlimited; TODO: implement</span>
<span id="L828" class="ln">   828	</span>
<span id="L829" class="ln">   829	</span>	w    io.Writer
<span id="L830" class="ln">   830	</span>	wbuf []byte
<span id="L831" class="ln">   831	</span>
<span id="L832" class="ln">   832	</span>	<span class="comment">// AllowIllegalWrites permits the Framer&#39;s Write methods to</span>
<span id="L833" class="ln">   833	</span>	<span class="comment">// write frames that do not conform to the HTTP/2 spec. This</span>
<span id="L834" class="ln">   834	</span>	<span class="comment">// permits using the Framer to test other HTTP/2</span>
<span id="L835" class="ln">   835	</span>	<span class="comment">// implementations&#39; conformance to the spec.</span>
<span id="L836" class="ln">   836	</span>	<span class="comment">// If false, the Write methods will prefer to return an error</span>
<span id="L837" class="ln">   837	</span>	<span class="comment">// rather than comply.</span>
<span id="L838" class="ln">   838	</span>	AllowIllegalWrites bool
<span id="L839" class="ln">   839	</span>
<span id="L840" class="ln">   840	</span>	<span class="comment">// AllowIllegalReads permits the Framer&#39;s ReadFrame method</span>
<span id="L841" class="ln">   841	</span>	<span class="comment">// to return non-compliant frames or frame orders.</span>
<span id="L842" class="ln">   842	</span>	<span class="comment">// This is for testing and permits using the Framer to test</span>
<span id="L843" class="ln">   843	</span>	<span class="comment">// other HTTP/2 implementations&#39; conformance to the spec.</span>
<span id="L844" class="ln">   844	</span>	<span class="comment">// It is not compatible with ReadMetaHeaders.</span>
<span id="L845" class="ln">   845	</span>	AllowIllegalReads bool
<span id="L846" class="ln">   846	</span>
<span id="L847" class="ln">   847	</span>	<span class="comment">// ReadMetaHeaders if non-nil causes ReadFrame to merge</span>
<span id="L848" class="ln">   848	</span>	<span class="comment">// HEADERS and CONTINUATION frames together and return</span>
<span id="L849" class="ln">   849	</span>	<span class="comment">// MetaHeadersFrame instead.</span>
<span id="L850" class="ln">   850	</span>	ReadMetaHeaders *hpack.Decoder
<span id="L851" class="ln">   851	</span>
<span id="L852" class="ln">   852	</span>	<span class="comment">// MaxHeaderListSize is the http2 MAX_HEADER_LIST_SIZE.</span>
<span id="L853" class="ln">   853	</span>	<span class="comment">// It&#39;s used only if ReadMetaHeaders is set; 0 means a sane default</span>
<span id="L854" class="ln">   854	</span>	<span class="comment">// (currently 16MB)</span>
<span id="L855" class="ln">   855	</span>	<span class="comment">// If the limit is hit, MetaHeadersFrame.Truncated is set true.</span>
<span id="L856" class="ln">   856	</span>	MaxHeaderListSize uint32
<span id="L857" class="ln">   857	</span>
<span id="L858" class="ln">   858	</span>	logReads, logWrites bool
<span id="L859" class="ln">   859	</span>
<span id="L860" class="ln">   860	</span>	debugFramer       *http2Framer <span class="comment">// only use for logging written writes</span>
<span id="L861" class="ln">   861	</span>	debugFramerBuf    *bytes.Buffer
<span id="L862" class="ln">   862	</span>	debugReadLoggerf  func(string, ...interface{})
<span id="L863" class="ln">   863	</span>	debugWriteLoggerf func(string, ...interface{})
<span id="L864" class="ln">   864	</span>}
<span id="L865" class="ln">   865	</span>
<span id="L866" class="ln">   866	</span>func (fr *http2Framer) maxHeaderListSize() uint32 {
<span id="L867" class="ln">   867	</span>	if fr.MaxHeaderListSize == 0 {
<span id="L868" class="ln">   868	</span>		return 16 &lt;&lt; 20
<span id="L869" class="ln">   869	</span>	}
<span id="L870" class="ln">   870	</span>	return fr.MaxHeaderListSize
<span id="L871" class="ln">   871	</span>}
<span id="L872" class="ln">   872	</span>
<span id="L873" class="ln">   873	</span>func (f *http2Framer) startWrite(ftype http2FrameType, flags http2Flags, streamID uint32) {
<span id="L874" class="ln">   874	</span>
<span id="L875" class="ln">   875	</span>	f.wbuf = append(f.wbuf[:0],
<span id="L876" class="ln">   876	</span>		0,
<span id="L877" class="ln">   877	</span>		0,
<span id="L878" class="ln">   878	</span>		0,
<span id="L879" class="ln">   879	</span>		byte(ftype),
<span id="L880" class="ln">   880	</span>		byte(flags),
<span id="L881" class="ln">   881	</span>		byte(streamID&gt;&gt;24),
<span id="L882" class="ln">   882	</span>		byte(streamID&gt;&gt;16),
<span id="L883" class="ln">   883	</span>		byte(streamID&gt;&gt;8),
<span id="L884" class="ln">   884	</span>		byte(streamID))
<span id="L885" class="ln">   885	</span>}
<span id="L886" class="ln">   886	</span>
<span id="L887" class="ln">   887	</span>func (f *http2Framer) endWrite() error {
<span id="L888" class="ln">   888	</span>
<span id="L889" class="ln">   889	</span>	length := len(f.wbuf) - http2frameHeaderLen
<span id="L890" class="ln">   890	</span>	if length &gt;= (1 &lt;&lt; 24) {
<span id="L891" class="ln">   891	</span>		return http2ErrFrameTooLarge
<span id="L892" class="ln">   892	</span>	}
<span id="L893" class="ln">   893	</span>	_ = append(f.wbuf[:0],
<span id="L894" class="ln">   894	</span>		byte(length&gt;&gt;16),
<span id="L895" class="ln">   895	</span>		byte(length&gt;&gt;8),
<span id="L896" class="ln">   896	</span>		byte(length))
<span id="L897" class="ln">   897	</span>	if f.logWrites {
<span id="L898" class="ln">   898	</span>		f.logWrite()
<span id="L899" class="ln">   899	</span>	}
<span id="L900" class="ln">   900	</span>
<span id="L901" class="ln">   901	</span>	n, err := f.w.Write(f.wbuf)
<span id="L902" class="ln">   902	</span>	if err == nil &amp;&amp; n != len(f.wbuf) {
<span id="L903" class="ln">   903	</span>		err = io.ErrShortWrite
<span id="L904" class="ln">   904	</span>	}
<span id="L905" class="ln">   905	</span>	return err
<span id="L906" class="ln">   906	</span>}
<span id="L907" class="ln">   907	</span>
<span id="L908" class="ln">   908	</span>func (f *http2Framer) logWrite() {
<span id="L909" class="ln">   909	</span>	if f.debugFramer == nil {
<span id="L910" class="ln">   910	</span>		f.debugFramerBuf = new(bytes.Buffer)
<span id="L911" class="ln">   911	</span>		f.debugFramer = http2NewFramer(nil, f.debugFramerBuf)
<span id="L912" class="ln">   912	</span>		f.debugFramer.logReads = false
<span id="L913" class="ln">   913	</span>
<span id="L914" class="ln">   914	</span>		f.debugFramer.AllowIllegalReads = true
<span id="L915" class="ln">   915	</span>	}
<span id="L916" class="ln">   916	</span>	f.debugFramerBuf.Write(f.wbuf)
<span id="L917" class="ln">   917	</span>	fr, err := f.debugFramer.ReadFrame()
<span id="L918" class="ln">   918	</span>	if err != nil {
<span id="L919" class="ln">   919	</span>		f.debugWriteLoggerf(&#34;http2: Framer %p: failed to decode just-written frame&#34;, f)
<span id="L920" class="ln">   920	</span>		return
<span id="L921" class="ln">   921	</span>	}
<span id="L922" class="ln">   922	</span>	f.debugWriteLoggerf(&#34;http2: Framer %p: wrote %v&#34;, f, http2summarizeFrame(fr))
<span id="L923" class="ln">   923	</span>}
<span id="L924" class="ln">   924	</span>
<span id="L925" class="ln">   925	</span>func (f *http2Framer) writeByte(v byte) { f.wbuf = append(f.wbuf, v) }
<span id="L926" class="ln">   926	</span>
<span id="L927" class="ln">   927	</span>func (f *http2Framer) writeBytes(v []byte) { f.wbuf = append(f.wbuf, v...) }
<span id="L928" class="ln">   928	</span>
<span id="L929" class="ln">   929	</span>func (f *http2Framer) writeUint16(v uint16) { f.wbuf = append(f.wbuf, byte(v&gt;&gt;8), byte(v)) }
<span id="L930" class="ln">   930	</span>
<span id="L931" class="ln">   931	</span>func (f *http2Framer) writeUint32(v uint32) {
<span id="L932" class="ln">   932	</span>	f.wbuf = append(f.wbuf, byte(v&gt;&gt;24), byte(v&gt;&gt;16), byte(v&gt;&gt;8), byte(v))
<span id="L933" class="ln">   933	</span>}
<span id="L934" class="ln">   934	</span>
<span id="L935" class="ln">   935	</span>const (
<span id="L936" class="ln">   936	</span>	http2minMaxFrameSize = 1 &lt;&lt; 14
<span id="L937" class="ln">   937	</span>	http2maxFrameSize    = 1&lt;&lt;24 - 1
<span id="L938" class="ln">   938	</span>)
<span id="L939" class="ln">   939	</span>
<span id="L940" class="ln">   940	</span><span class="comment">// NewFramer returns a Framer that writes frames to w and reads them from r.</span>
<span id="L941" class="ln">   941	</span>func http2NewFramer(w io.Writer, r io.Reader) *http2Framer {
<span id="L942" class="ln">   942	</span>	fr := &amp;http2Framer{
<span id="L943" class="ln">   943	</span>		w:                 w,
<span id="L944" class="ln">   944	</span>		r:                 r,
<span id="L945" class="ln">   945	</span>		logReads:          http2logFrameReads,
<span id="L946" class="ln">   946	</span>		logWrites:         http2logFrameWrites,
<span id="L947" class="ln">   947	</span>		debugReadLoggerf:  log.Printf,
<span id="L948" class="ln">   948	</span>		debugWriteLoggerf: log.Printf,
<span id="L949" class="ln">   949	</span>	}
<span id="L950" class="ln">   950	</span>	fr.getReadBuf = func(size uint32) []byte {
<span id="L951" class="ln">   951	</span>		if cap(fr.readBuf) &gt;= int(size) {
<span id="L952" class="ln">   952	</span>			return fr.readBuf[:size]
<span id="L953" class="ln">   953	</span>		}
<span id="L954" class="ln">   954	</span>		fr.readBuf = make([]byte, size)
<span id="L955" class="ln">   955	</span>		return fr.readBuf
<span id="L956" class="ln">   956	</span>	}
<span id="L957" class="ln">   957	</span>	fr.SetMaxReadFrameSize(http2maxFrameSize)
<span id="L958" class="ln">   958	</span>	return fr
<span id="L959" class="ln">   959	</span>}
<span id="L960" class="ln">   960	</span>
<span id="L961" class="ln">   961	</span><span class="comment">// SetMaxReadFrameSize sets the maximum size of a frame</span>
<span id="L962" class="ln">   962	</span><span class="comment">// that will be read by a subsequent call to ReadFrame.</span>
<span id="L963" class="ln">   963	</span><span class="comment">// It is the caller&#39;s responsibility to advertise this</span>
<span id="L964" class="ln">   964	</span><span class="comment">// limit with a SETTINGS frame.</span>
<span id="L965" class="ln">   965	</span>func (fr *http2Framer) SetMaxReadFrameSize(v uint32) {
<span id="L966" class="ln">   966	</span>	if v &gt; http2maxFrameSize {
<span id="L967" class="ln">   967	</span>		v = http2maxFrameSize
<span id="L968" class="ln">   968	</span>	}
<span id="L969" class="ln">   969	</span>	fr.maxReadSize = v
<span id="L970" class="ln">   970	</span>}
<span id="L971" class="ln">   971	</span>
<span id="L972" class="ln">   972	</span><span class="comment">// ErrorDetail returns a more detailed error of the last error</span>
<span id="L973" class="ln">   973	</span><span class="comment">// returned by Framer.ReadFrame. For instance, if ReadFrame</span>
<span id="L974" class="ln">   974	</span><span class="comment">// returns a StreamError with code PROTOCOL_ERROR, ErrorDetail</span>
<span id="L975" class="ln">   975	</span><span class="comment">// will say exactly what was invalid. ErrorDetail is not guaranteed</span>
<span id="L976" class="ln">   976	</span><span class="comment">// to return a non-nil value and like the rest of the http2 package,</span>
<span id="L977" class="ln">   977	</span><span class="comment">// its return value is not protected by an API compatibility promise.</span>
<span id="L978" class="ln">   978	</span><span class="comment">// ErrorDetail is reset after the next call to ReadFrame.</span>
<span id="L979" class="ln">   979	</span>func (fr *http2Framer) ErrorDetail() error {
<span id="L980" class="ln">   980	</span>	return fr.errDetail
<span id="L981" class="ln">   981	</span>}
<span id="L982" class="ln">   982	</span>
<span id="L983" class="ln">   983	</span><span class="comment">// ErrFrameTooLarge is returned from Framer.ReadFrame when the peer</span>
<span id="L984" class="ln">   984	</span><span class="comment">// sends a frame that is larger than declared with SetMaxReadFrameSize.</span>
<span id="L985" class="ln">   985	</span>var http2ErrFrameTooLarge = errors.New(&#34;http2: frame too large&#34;)
<span id="L986" class="ln">   986	</span>
<span id="L987" class="ln">   987	</span><span class="comment">// terminalReadFrameError reports whether err is an unrecoverable</span>
<span id="L988" class="ln">   988	</span><span class="comment">// error from ReadFrame and no other frames should be read.</span>
<span id="L989" class="ln">   989	</span>func http2terminalReadFrameError(err error) bool {
<span id="L990" class="ln">   990	</span>	if _, ok := err.(http2StreamError); ok {
<span id="L991" class="ln">   991	</span>		return false
<span id="L992" class="ln">   992	</span>	}
<span id="L993" class="ln">   993	</span>	return err != nil
<span id="L994" class="ln">   994	</span>}
<span id="L995" class="ln">   995	</span>
<span id="L996" class="ln">   996	</span><span class="comment">// ReadFrame reads a single frame. The returned Frame is only valid</span>
<span id="L997" class="ln">   997	</span><span class="comment">// until the next call to ReadFrame.</span>
<span id="L998" class="ln">   998	</span><span class="comment">//</span>
<span id="L999" class="ln">   999	</span><span class="comment">// If the frame is larger than previously set with SetMaxReadFrameSize, the</span>
<span id="L1000" class="ln">  1000	</span><span class="comment">// returned error is ErrFrameTooLarge. Other errors may be of type</span>
<span id="L1001" class="ln">  1001	</span><span class="comment">// ConnectionError, StreamError, or anything else from the underlying</span>
<span id="L1002" class="ln">  1002	</span><span class="comment">// reader.</span>
<span id="L1003" class="ln">  1003	</span>func (fr *http2Framer) ReadFrame() (http2Frame, error) {
<span id="L1004" class="ln">  1004	</span>	fr.errDetail = nil
<span id="L1005" class="ln">  1005	</span>	if fr.lastFrame != nil {
<span id="L1006" class="ln">  1006	</span>		fr.lastFrame.invalidate()
<span id="L1007" class="ln">  1007	</span>	}
<span id="L1008" class="ln">  1008	</span>	fh, err := http2readFrameHeader(fr.headerBuf[:], fr.r)
<span id="L1009" class="ln">  1009	</span>	if err != nil {
<span id="L1010" class="ln">  1010	</span>		return nil, err
<span id="L1011" class="ln">  1011	</span>	}
<span id="L1012" class="ln">  1012	</span>	if fh.Length &gt; fr.maxReadSize {
<span id="L1013" class="ln">  1013	</span>		return nil, http2ErrFrameTooLarge
<span id="L1014" class="ln">  1014	</span>	}
<span id="L1015" class="ln">  1015	</span>	payload := fr.getReadBuf(fh.Length)
<span id="L1016" class="ln">  1016	</span>	if _, err := io.ReadFull(fr.r, payload); err != nil {
<span id="L1017" class="ln">  1017	</span>		return nil, err
<span id="L1018" class="ln">  1018	</span>	}
<span id="L1019" class="ln">  1019	</span>	f, err := http2typeFrameParser(fh.Type)(fh, payload)
<span id="L1020" class="ln">  1020	</span>	if err != nil {
<span id="L1021" class="ln">  1021	</span>		if ce, ok := err.(http2connError); ok {
<span id="L1022" class="ln">  1022	</span>			return nil, fr.connError(ce.Code, ce.Reason)
<span id="L1023" class="ln">  1023	</span>		}
<span id="L1024" class="ln">  1024	</span>		return nil, err
<span id="L1025" class="ln">  1025	</span>	}
<span id="L1026" class="ln">  1026	</span>	if err := fr.checkFrameOrder(f); err != nil {
<span id="L1027" class="ln">  1027	</span>		return nil, err
<span id="L1028" class="ln">  1028	</span>	}
<span id="L1029" class="ln">  1029	</span>	if fr.logReads {
<span id="L1030" class="ln">  1030	</span>		fr.debugReadLoggerf(&#34;http2: Framer %p: read %v&#34;, fr, http2summarizeFrame(f))
<span id="L1031" class="ln">  1031	</span>	}
<span id="L1032" class="ln">  1032	</span>	if fh.Type == http2FrameHeaders &amp;&amp; fr.ReadMetaHeaders != nil {
<span id="L1033" class="ln">  1033	</span>		return fr.readMetaFrame(f.(*http2HeadersFrame))
<span id="L1034" class="ln">  1034	</span>	}
<span id="L1035" class="ln">  1035	</span>	return f, nil
<span id="L1036" class="ln">  1036	</span>}
<span id="L1037" class="ln">  1037	</span>
<span id="L1038" class="ln">  1038	</span><span class="comment">// connError returns ConnectionError(code) but first</span>
<span id="L1039" class="ln">  1039	</span><span class="comment">// stashes away a public reason to the caller can optionally relay it</span>
<span id="L1040" class="ln">  1040	</span><span class="comment">// to the peer before hanging up on them. This might help others debug</span>
<span id="L1041" class="ln">  1041	</span><span class="comment">// their implementations.</span>
<span id="L1042" class="ln">  1042	</span>func (fr *http2Framer) connError(code http2ErrCode, reason string) error {
<span id="L1043" class="ln">  1043	</span>	fr.errDetail = errors.New(reason)
<span id="L1044" class="ln">  1044	</span>	return http2ConnectionError(code)
<span id="L1045" class="ln">  1045	</span>}
<span id="L1046" class="ln">  1046	</span>
<span id="L1047" class="ln">  1047	</span><span class="comment">// checkFrameOrder reports an error if f is an invalid frame to return</span>
<span id="L1048" class="ln">  1048	</span><span class="comment">// next from ReadFrame. Mostly it checks whether HEADERS and</span>
<span id="L1049" class="ln">  1049	</span><span class="comment">// CONTINUATION frames are contiguous.</span>
<span id="L1050" class="ln">  1050	</span>func (fr *http2Framer) checkFrameOrder(f http2Frame) error {
<span id="L1051" class="ln">  1051	</span>	last := fr.lastFrame
<span id="L1052" class="ln">  1052	</span>	fr.lastFrame = f
<span id="L1053" class="ln">  1053	</span>	if fr.AllowIllegalReads {
<span id="L1054" class="ln">  1054	</span>		return nil
<span id="L1055" class="ln">  1055	</span>	}
<span id="L1056" class="ln">  1056	</span>
<span id="L1057" class="ln">  1057	</span>	fh := f.Header()
<span id="L1058" class="ln">  1058	</span>	if fr.lastHeaderStream != 0 {
<span id="L1059" class="ln">  1059	</span>		if fh.Type != http2FrameContinuation {
<span id="L1060" class="ln">  1060	</span>			return fr.connError(http2ErrCodeProtocol,
<span id="L1061" class="ln">  1061	</span>				fmt.Sprintf(&#34;got %s for stream %d; expected CONTINUATION following %s for stream %d&#34;,
<span id="L1062" class="ln">  1062	</span>					fh.Type, fh.StreamID,
<span id="L1063" class="ln">  1063	</span>					last.Header().Type, fr.lastHeaderStream))
<span id="L1064" class="ln">  1064	</span>		}
<span id="L1065" class="ln">  1065	</span>		if fh.StreamID != fr.lastHeaderStream {
<span id="L1066" class="ln">  1066	</span>			return fr.connError(http2ErrCodeProtocol,
<span id="L1067" class="ln">  1067	</span>				fmt.Sprintf(&#34;got CONTINUATION for stream %d; expected stream %d&#34;,
<span id="L1068" class="ln">  1068	</span>					fh.StreamID, fr.lastHeaderStream))
<span id="L1069" class="ln">  1069	</span>		}
<span id="L1070" class="ln">  1070	</span>	} else if fh.Type == http2FrameContinuation {
<span id="L1071" class="ln">  1071	</span>		return fr.connError(http2ErrCodeProtocol, fmt.Sprintf(&#34;unexpected CONTINUATION for stream %d&#34;, fh.StreamID))
<span id="L1072" class="ln">  1072	</span>	}
<span id="L1073" class="ln">  1073	</span>
<span id="L1074" class="ln">  1074	</span>	switch fh.Type {
<span id="L1075" class="ln">  1075	</span>	case http2FrameHeaders, http2FrameContinuation:
<span id="L1076" class="ln">  1076	</span>		if fh.Flags.Has(http2FlagHeadersEndHeaders) {
<span id="L1077" class="ln">  1077	</span>			fr.lastHeaderStream = 0
<span id="L1078" class="ln">  1078	</span>		} else {
<span id="L1079" class="ln">  1079	</span>			fr.lastHeaderStream = fh.StreamID
<span id="L1080" class="ln">  1080	</span>		}
<span id="L1081" class="ln">  1081	</span>	}
<span id="L1082" class="ln">  1082	</span>
<span id="L1083" class="ln">  1083	</span>	return nil
<span id="L1084" class="ln">  1084	</span>}
<span id="L1085" class="ln">  1085	</span>
<span id="L1086" class="ln">  1086	</span><span class="comment">// A DataFrame conveys arbitrary, variable-length sequences of octets</span>
<span id="L1087" class="ln">  1087	</span><span class="comment">// associated with a stream.</span>
<span id="L1088" class="ln">  1088	</span><span class="comment">// See http://http2.github.io/http2-spec/#rfc.section.6.1</span>
<span id="L1089" class="ln">  1089	</span>type http2DataFrame struct {
<span id="L1090" class="ln">  1090	</span>	http2FrameHeader
<span id="L1091" class="ln">  1091	</span>	data []byte
<span id="L1092" class="ln">  1092	</span>}
<span id="L1093" class="ln">  1093	</span>
<span id="L1094" class="ln">  1094	</span>func (f *http2DataFrame) StreamEnded() bool {
<span id="L1095" class="ln">  1095	</span>	return f.http2FrameHeader.Flags.Has(http2FlagDataEndStream)
<span id="L1096" class="ln">  1096	</span>}
<span id="L1097" class="ln">  1097	</span>
<span id="L1098" class="ln">  1098	</span><span class="comment">// Data returns the frame&#39;s data octets, not including any padding</span>
<span id="L1099" class="ln">  1099	</span><span class="comment">// size byte or padding suffix bytes.</span>
<span id="L1100" class="ln">  1100	</span><span class="comment">// The caller must not retain the returned memory past the next</span>
<span id="L1101" class="ln">  1101	</span><span class="comment">// call to ReadFrame.</span>
<span id="L1102" class="ln">  1102	</span>func (f *http2DataFrame) Data() []byte {
<span id="L1103" class="ln">  1103	</span>	f.checkValid()
<span id="L1104" class="ln">  1104	</span>	return f.data
<span id="L1105" class="ln">  1105	</span>}
<span id="L1106" class="ln">  1106	</span>
<span id="L1107" class="ln">  1107	</span>func http2parseDataFrame(fh http2FrameHeader, payload []byte) (http2Frame, error) {
<span id="L1108" class="ln">  1108	</span>	if fh.StreamID == 0 {
<span id="L1109" class="ln">  1109	</span>
<span id="L1110" class="ln">  1110	</span>		return nil, http2connError{http2ErrCodeProtocol, &#34;DATA frame with stream ID 0&#34;}
<span id="L1111" class="ln">  1111	</span>	}
<span id="L1112" class="ln">  1112	</span>	f := &amp;http2DataFrame{
<span id="L1113" class="ln">  1113	</span>		http2FrameHeader: fh,
<span id="L1114" class="ln">  1114	</span>	}
<span id="L1115" class="ln">  1115	</span>	var padSize byte
<span id="L1116" class="ln">  1116	</span>	if fh.Flags.Has(http2FlagDataPadded) {
<span id="L1117" class="ln">  1117	</span>		var err error
<span id="L1118" class="ln">  1118	</span>		payload, padSize, err = http2readByte(payload)
<span id="L1119" class="ln">  1119	</span>		if err != nil {
<span id="L1120" class="ln">  1120	</span>			return nil, err
<span id="L1121" class="ln">  1121	</span>		}
<span id="L1122" class="ln">  1122	</span>	}
<span id="L1123" class="ln">  1123	</span>	if int(padSize) &gt; len(payload) {
<span id="L1124" class="ln">  1124	</span>
<span id="L1125" class="ln">  1125	</span>		return nil, http2connError{http2ErrCodeProtocol, &#34;pad size larger than data payload&#34;}
<span id="L1126" class="ln">  1126	</span>	}
<span id="L1127" class="ln">  1127	</span>	f.data = payload[:len(payload)-int(padSize)]
<span id="L1128" class="ln">  1128	</span>	return f, nil
<span id="L1129" class="ln">  1129	</span>}
<span id="L1130" class="ln">  1130	</span>
<span id="L1131" class="ln">  1131	</span>var (
<span id="L1132" class="ln">  1132	</span>	http2errStreamID    = errors.New(&#34;invalid stream ID&#34;)
<span id="L1133" class="ln">  1133	</span>	http2errDepStreamID = errors.New(&#34;invalid dependent stream ID&#34;)
<span id="L1134" class="ln">  1134	</span>	http2errPadLength   = errors.New(&#34;pad length too large&#34;)
<span id="L1135" class="ln">  1135	</span>)
<span id="L1136" class="ln">  1136	</span>
<span id="L1137" class="ln">  1137	</span>func http2validStreamIDOrZero(streamID uint32) bool {
<span id="L1138" class="ln">  1138	</span>	return streamID&amp;(1&lt;&lt;31) == 0
<span id="L1139" class="ln">  1139	</span>}
<span id="L1140" class="ln">  1140	</span>
<span id="L1141" class="ln">  1141	</span>func http2validStreamID(streamID uint32) bool {
<span id="L1142" class="ln">  1142	</span>	return streamID != 0 &amp;&amp; streamID&amp;(1&lt;&lt;31) == 0
<span id="L1143" class="ln">  1143	</span>}
<span id="L1144" class="ln">  1144	</span>
<span id="L1145" class="ln">  1145	</span><span class="comment">// WriteData writes a DATA frame.</span>
<span id="L1146" class="ln">  1146	</span><span class="comment">//</span>
<span id="L1147" class="ln">  1147	</span><span class="comment">// It will perform exactly one Write to the underlying Writer.</span>
<span id="L1148" class="ln">  1148	</span><span class="comment">// It is the caller&#39;s responsibility not to violate the maximum frame size</span>
<span id="L1149" class="ln">  1149	</span><span class="comment">// and to not call other Write methods concurrently.</span>
<span id="L1150" class="ln">  1150	</span>func (f *http2Framer) WriteData(streamID uint32, endStream bool, data []byte) error {
<span id="L1151" class="ln">  1151	</span>	return f.WriteDataPadded(streamID, endStream, data, nil)
<span id="L1152" class="ln">  1152	</span>}
<span id="L1153" class="ln">  1153	</span>
<span id="L1154" class="ln">  1154	</span><span class="comment">// WriteData writes a DATA frame with optional padding.</span>
<span id="L1155" class="ln">  1155	</span><span class="comment">//</span>
<span id="L1156" class="ln">  1156	</span><span class="comment">// If pad is nil, the padding bit is not sent.</span>
<span id="L1157" class="ln">  1157	</span><span class="comment">// The length of pad must not exceed 255 bytes.</span>
<span id="L1158" class="ln">  1158	</span><span class="comment">//</span>
<span id="L1159" class="ln">  1159	</span><span class="comment">// It will perform exactly one Write to the underlying Writer.</span>
<span id="L1160" class="ln">  1160	</span><span class="comment">// It is the caller&#39;s responsibility not to violate the maximum frame size</span>
<span id="L1161" class="ln">  1161	</span><span class="comment">// and to not call other Write methods concurrently.</span>
<span id="L1162" class="ln">  1162	</span>func (f *http2Framer) WriteDataPadded(streamID uint32, endStream bool, data, pad []byte) error {
<span id="L1163" class="ln">  1163	</span>	if !http2validStreamID(streamID) &amp;&amp; !f.AllowIllegalWrites {
<span id="L1164" class="ln">  1164	</span>		return http2errStreamID
<span id="L1165" class="ln">  1165	</span>	}
<span id="L1166" class="ln">  1166	</span>	if len(pad) &gt; 255 {
<span id="L1167" class="ln">  1167	</span>		return http2errPadLength
<span id="L1168" class="ln">  1168	</span>	}
<span id="L1169" class="ln">  1169	</span>	var flags http2Flags
<span id="L1170" class="ln">  1170	</span>	if endStream {
<span id="L1171" class="ln">  1171	</span>		flags |= http2FlagDataEndStream
<span id="L1172" class="ln">  1172	</span>	}
<span id="L1173" class="ln">  1173	</span>	if pad != nil {
<span id="L1174" class="ln">  1174	</span>		flags |= http2FlagDataPadded
<span id="L1175" class="ln">  1175	</span>	}
<span id="L1176" class="ln">  1176	</span>	f.startWrite(http2FrameData, flags, streamID)
<span id="L1177" class="ln">  1177	</span>	if pad != nil {
<span id="L1178" class="ln">  1178	</span>		f.wbuf = append(f.wbuf, byte(len(pad)))
<span id="L1179" class="ln">  1179	</span>	}
<span id="L1180" class="ln">  1180	</span>	f.wbuf = append(f.wbuf, data...)
<span id="L1181" class="ln">  1181	</span>	f.wbuf = append(f.wbuf, pad...)
<span id="L1182" class="ln">  1182	</span>	return f.endWrite()
<span id="L1183" class="ln">  1183	</span>}
<span id="L1184" class="ln">  1184	</span>
<span id="L1185" class="ln">  1185	</span><span class="comment">// A SettingsFrame conveys configuration parameters that affect how</span>
<span id="L1186" class="ln">  1186	</span><span class="comment">// endpoints communicate, such as preferences and constraints on peer</span>
<span id="L1187" class="ln">  1187	</span><span class="comment">// behavior.</span>
<span id="L1188" class="ln">  1188	</span><span class="comment">//</span>
<span id="L1189" class="ln">  1189	</span><span class="comment">// See http://http2.github.io/http2-spec/#SETTINGS</span>
<span id="L1190" class="ln">  1190	</span>type http2SettingsFrame struct {
<span id="L1191" class="ln">  1191	</span>	http2FrameHeader
<span id="L1192" class="ln">  1192	</span>	p []byte
<span id="L1193" class="ln">  1193	</span>}
<span id="L1194" class="ln">  1194	</span>
<span id="L1195" class="ln">  1195	</span>func http2parseSettingsFrame(fh http2FrameHeader, p []byte) (http2Frame, error) {
<span id="L1196" class="ln">  1196	</span>	if fh.Flags.Has(http2FlagSettingsAck) &amp;&amp; fh.Length &gt; 0 {
<span id="L1197" class="ln">  1197	</span>
<span id="L1198" class="ln">  1198	</span>		return nil, http2ConnectionError(http2ErrCodeFrameSize)
<span id="L1199" class="ln">  1199	</span>	}
<span id="L1200" class="ln">  1200	</span>	if fh.StreamID != 0 {
<span id="L1201" class="ln">  1201	</span>
<span id="L1202" class="ln">  1202	</span>		return nil, http2ConnectionError(http2ErrCodeProtocol)
<span id="L1203" class="ln">  1203	</span>	}
<span id="L1204" class="ln">  1204	</span>	if len(p)%6 != 0 {
<span id="L1205" class="ln">  1205	</span>
<span id="L1206" class="ln">  1206	</span>		return nil, http2ConnectionError(http2ErrCodeFrameSize)
<span id="L1207" class="ln">  1207	</span>	}
<span id="L1208" class="ln">  1208	</span>	f := &amp;http2SettingsFrame{http2FrameHeader: fh, p: p}
<span id="L1209" class="ln">  1209	</span>	if v, ok := f.Value(http2SettingInitialWindowSize); ok &amp;&amp; v &gt; (1&lt;&lt;31)-1 {
<span id="L1210" class="ln">  1210	</span>
<span id="L1211" class="ln">  1211	</span>		return nil, http2ConnectionError(http2ErrCodeFlowControl)
<span id="L1212" class="ln">  1212	</span>	}
<span id="L1213" class="ln">  1213	</span>	return f, nil
<span id="L1214" class="ln">  1214	</span>}
<span id="L1215" class="ln">  1215	</span>
<span id="L1216" class="ln">  1216	</span>func (f *http2SettingsFrame) IsAck() bool {
<span id="L1217" class="ln">  1217	</span>	return f.http2FrameHeader.Flags.Has(http2FlagSettingsAck)
<span id="L1218" class="ln">  1218	</span>}
<span id="L1219" class="ln">  1219	</span>
<span id="L1220" class="ln">  1220	</span>func (f *http2SettingsFrame) Value(s http2SettingID) (v uint32, ok bool) {
<span id="L1221" class="ln">  1221	</span>	f.checkValid()
<span id="L1222" class="ln">  1222	</span>	buf := f.p
<span id="L1223" class="ln">  1223	</span>	for len(buf) &gt; 0 {
<span id="L1224" class="ln">  1224	</span>		settingID := http2SettingID(binary.BigEndian.Uint16(buf[:2]))
<span id="L1225" class="ln">  1225	</span>		if settingID == s {
<span id="L1226" class="ln">  1226	</span>			return binary.BigEndian.Uint32(buf[2:6]), true
<span id="L1227" class="ln">  1227	</span>		}
<span id="L1228" class="ln">  1228	</span>		buf = buf[6:]
<span id="L1229" class="ln">  1229	</span>	}
<span id="L1230" class="ln">  1230	</span>	return 0, false
<span id="L1231" class="ln">  1231	</span>}
<span id="L1232" class="ln">  1232	</span>
<span id="L1233" class="ln">  1233	</span><span class="comment">// ForeachSetting runs fn for each setting.</span>
<span id="L1234" class="ln">  1234	</span><span class="comment">// It stops and returns the first error.</span>
<span id="L1235" class="ln">  1235	</span>func (f *http2SettingsFrame) ForeachSetting(fn func(http2Setting) error) error {
<span id="L1236" class="ln">  1236	</span>	f.checkValid()
<span id="L1237" class="ln">  1237	</span>	buf := f.p
<span id="L1238" class="ln">  1238	</span>	for len(buf) &gt; 0 {
<span id="L1239" class="ln">  1239	</span>		if err := fn(http2Setting{
<span id="L1240" class="ln">  1240	</span>			http2SettingID(binary.BigEndian.Uint16(buf[:2])),
<span id="L1241" class="ln">  1241	</span>			binary.BigEndian.Uint32(buf[2:6]),
<span id="L1242" class="ln">  1242	</span>		}); err != nil {
<span id="L1243" class="ln">  1243	</span>			return err
<span id="L1244" class="ln">  1244	</span>		}
<span id="L1245" class="ln">  1245	</span>		buf = buf[6:]
<span id="L1246" class="ln">  1246	</span>	}
<span id="L1247" class="ln">  1247	</span>	return nil
<span id="L1248" class="ln">  1248	</span>}
<span id="L1249" class="ln">  1249	</span>
<span id="L1250" class="ln">  1250	</span><span class="comment">// WriteSettings writes a SETTINGS frame with zero or more settings</span>
<span id="L1251" class="ln">  1251	</span><span class="comment">// specified and the ACK bit not set.</span>
<span id="L1252" class="ln">  1252	</span><span class="comment">//</span>
<span id="L1253" class="ln">  1253	</span><span class="comment">// It will perform exactly one Write to the underlying Writer.</span>
<span id="L1254" class="ln">  1254	</span><span class="comment">// It is the caller&#39;s responsibility to not call other Write methods concurrently.</span>
<span id="L1255" class="ln">  1255	</span>func (f *http2Framer) WriteSettings(settings ...http2Setting) error {
<span id="L1256" class="ln">  1256	</span>	f.startWrite(http2FrameSettings, 0, 0)
<span id="L1257" class="ln">  1257	</span>	for _, s := range settings {
<span id="L1258" class="ln">  1258	</span>		f.writeUint16(uint16(s.ID))
<span id="L1259" class="ln">  1259	</span>		f.writeUint32(s.Val)
<span id="L1260" class="ln">  1260	</span>	}
<span id="L1261" class="ln">  1261	</span>	return f.endWrite()
<span id="L1262" class="ln">  1262	</span>}
<span id="L1263" class="ln">  1263	</span>
<span id="L1264" class="ln">  1264	</span><span class="comment">// WriteSettingsAck writes an empty SETTINGS frame with the ACK bit set.</span>
<span id="L1265" class="ln">  1265	</span><span class="comment">//</span>
<span id="L1266" class="ln">  1266	</span><span class="comment">// It will perform exactly one Write to the underlying Writer.</span>
<span id="L1267" class="ln">  1267	</span><span class="comment">// It is the caller&#39;s responsibility to not call other Write methods concurrently.</span>
<span id="L1268" class="ln">  1268	</span>func (f *http2Framer) WriteSettingsAck() error {
<span id="L1269" class="ln">  1269	</span>	f.startWrite(http2FrameSettings, http2FlagSettingsAck, 0)
<span id="L1270" class="ln">  1270	</span>	return f.endWrite()
<span id="L1271" class="ln">  1271	</span>}
<span id="L1272" class="ln">  1272	</span>
<span id="L1273" class="ln">  1273	</span><span class="comment">// A PingFrame is a mechanism for measuring a minimal round trip time</span>
<span id="L1274" class="ln">  1274	</span><span class="comment">// from the sender, as well as determining whether an idle connection</span>
<span id="L1275" class="ln">  1275	</span><span class="comment">// is still functional.</span>
<span id="L1276" class="ln">  1276	</span><span class="comment">// See http://http2.github.io/http2-spec/#rfc.section.6.7</span>
<span id="L1277" class="ln">  1277	</span>type http2PingFrame struct {
<span id="L1278" class="ln">  1278	</span>	http2FrameHeader
<span id="L1279" class="ln">  1279	</span>	Data [8]byte
<span id="L1280" class="ln">  1280	</span>}
<span id="L1281" class="ln">  1281	</span>
<span id="L1282" class="ln">  1282	</span>func (f *http2PingFrame) IsAck() bool { return f.Flags.Has(http2FlagPingAck) }
<span id="L1283" class="ln">  1283	</span>
<span id="L1284" class="ln">  1284	</span>func http2parsePingFrame(fh http2FrameHeader, payload []byte) (http2Frame, error) {
<span id="L1285" class="ln">  1285	</span>	if len(payload) != 8 {
<span id="L1286" class="ln">  1286	</span>		return nil, http2ConnectionError(http2ErrCodeFrameSize)
<span id="L1287" class="ln">  1287	</span>	}
<span id="L1288" class="ln">  1288	</span>	if fh.StreamID != 0 {
<span id="L1289" class="ln">  1289	</span>		return nil, http2ConnectionError(http2ErrCodeProtocol)
<span id="L1290" class="ln">  1290	</span>	}
<span id="L1291" class="ln">  1291	</span>	f := &amp;http2PingFrame{http2FrameHeader: fh}
<span id="L1292" class="ln">  1292	</span>	copy(f.Data[:], payload)
<span id="L1293" class="ln">  1293	</span>	return f, nil
<span id="L1294" class="ln">  1294	</span>}
<span id="L1295" class="ln">  1295	</span>
<span id="L1296" class="ln">  1296	</span>func (f *http2Framer) WritePing(ack bool, data [8]byte) error {
<span id="L1297" class="ln">  1297	</span>	var flags http2Flags
<span id="L1298" class="ln">  1298	</span>	if ack {
<span id="L1299" class="ln">  1299	</span>		flags = http2FlagPingAck
<span id="L1300" class="ln">  1300	</span>	}
<span id="L1301" class="ln">  1301	</span>	f.startWrite(http2FramePing, flags, 0)
<span id="L1302" class="ln">  1302	</span>	f.writeBytes(data[:])
<span id="L1303" class="ln">  1303	</span>	return f.endWrite()
<span id="L1304" class="ln">  1304	</span>}
<span id="L1305" class="ln">  1305	</span>
<span id="L1306" class="ln">  1306	</span><span class="comment">// A GoAwayFrame informs the remote peer to stop creating streams on this connection.</span>
<span id="L1307" class="ln">  1307	</span><span class="comment">// See http://http2.github.io/http2-spec/#rfc.section.6.8</span>
<span id="L1308" class="ln">  1308	</span>type http2GoAwayFrame struct {
<span id="L1309" class="ln">  1309	</span>	http2FrameHeader
<span id="L1310" class="ln">  1310	</span>	LastStreamID uint32
<span id="L1311" class="ln">  1311	</span>	ErrCode      http2ErrCode
<span id="L1312" class="ln">  1312	</span>	debugData    []byte
<span id="L1313" class="ln">  1313	</span>}
<span id="L1314" class="ln">  1314	</span>
<span id="L1315" class="ln">  1315	</span><span class="comment">// DebugData returns any debug data in the GOAWAY frame. Its contents</span>
<span id="L1316" class="ln">  1316	</span><span class="comment">// are not defined.</span>
<span id="L1317" class="ln">  1317	</span><span class="comment">// The caller must not retain the returned memory past the next</span>
<span id="L1318" class="ln">  1318	</span><span class="comment">// call to ReadFrame.</span>
<span id="L1319" class="ln">  1319	</span>func (f *http2GoAwayFrame) DebugData() []byte {
<span id="L1320" class="ln">  1320	</span>	f.checkValid()
<span id="L1321" class="ln">  1321	</span>	return f.debugData
<span id="L1322" class="ln">  1322	</span>}
<span id="L1323" class="ln">  1323	</span>
<span id="L1324" class="ln">  1324	</span>func http2parseGoAwayFrame(fh http2FrameHeader, p []byte) (http2Frame, error) {
<span id="L1325" class="ln">  1325	</span>	if fh.StreamID != 0 {
<span id="L1326" class="ln">  1326	</span>		return nil, http2ConnectionError(http2ErrCodeProtocol)
<span id="L1327" class="ln">  1327	</span>	}
<span id="L1328" class="ln">  1328	</span>	if len(p) &lt; 8 {
<span id="L1329" class="ln">  1329	</span>		return nil, http2ConnectionError(http2ErrCodeFrameSize)
<span id="L1330" class="ln">  1330	</span>	}
<span id="L1331" class="ln">  1331	</span>	return &amp;http2GoAwayFrame{
<span id="L1332" class="ln">  1332	</span>		http2FrameHeader: fh,
<span id="L1333" class="ln">  1333	</span>		LastStreamID:     binary.BigEndian.Uint32(p[:4]) &amp; (1&lt;&lt;31 - 1),
<span id="L1334" class="ln">  1334	</span>		ErrCode:          http2ErrCode(binary.BigEndian.Uint32(p[4:8])),
<span id="L1335" class="ln">  1335	</span>		debugData:        p[8:],
<span id="L1336" class="ln">  1336	</span>	}, nil
<span id="L1337" class="ln">  1337	</span>}
<span id="L1338" class="ln">  1338	</span>
<span id="L1339" class="ln">  1339	</span>func (f *http2Framer) WriteGoAway(maxStreamID uint32, code http2ErrCode, debugData []byte) error {
<span id="L1340" class="ln">  1340	</span>	f.startWrite(http2FrameGoAway, 0, 0)
<span id="L1341" class="ln">  1341	</span>	f.writeUint32(maxStreamID &amp; (1&lt;&lt;31 - 1))
<span id="L1342" class="ln">  1342	</span>	f.writeUint32(uint32(code))
<span id="L1343" class="ln">  1343	</span>	f.writeBytes(debugData)
<span id="L1344" class="ln">  1344	</span>	return f.endWrite()
<span id="L1345" class="ln">  1345	</span>}
<span id="L1346" class="ln">  1346	</span>
<span id="L1347" class="ln">  1347	</span><span class="comment">// An UnknownFrame is the frame type returned when the frame type is unknown</span>
<span id="L1348" class="ln">  1348	</span><span class="comment">// or no specific frame type parser exists.</span>
<span id="L1349" class="ln">  1349	</span>type http2UnknownFrame struct {
<span id="L1350" class="ln">  1350	</span>	http2FrameHeader
<span id="L1351" class="ln">  1351	</span>	p []byte
<span id="L1352" class="ln">  1352	</span>}
<span id="L1353" class="ln">  1353	</span>
<span id="L1354" class="ln">  1354	</span><span class="comment">// Payload returns the frame&#39;s payload (after the header).  It is not</span>
<span id="L1355" class="ln">  1355	</span><span class="comment">// valid to call this method after a subsequent call to</span>
<span id="L1356" class="ln">  1356	</span><span class="comment">// Framer.ReadFrame, nor is it valid to retain the returned slice.</span>
<span id="L1357" class="ln">  1357	</span><span class="comment">// The memory is owned by the Framer and is invalidated when the next</span>
<span id="L1358" class="ln">  1358	</span><span class="comment">// frame is read.</span>
<span id="L1359" class="ln">  1359	</span>func (f *http2UnknownFrame) Payload() []byte {
<span id="L1360" class="ln">  1360	</span>	f.checkValid()
<span id="L1361" class="ln">  1361	</span>	return f.p
<span id="L1362" class="ln">  1362	</span>}
<span id="L1363" class="ln">  1363	</span>
<span id="L1364" class="ln">  1364	</span>func http2parseUnknownFrame(fh http2FrameHeader, p []byte) (http2Frame, error) {
<span id="L1365" class="ln">  1365	</span>	return &amp;http2UnknownFrame{fh, p}, nil
<span id="L1366" class="ln">  1366	</span>}
<span id="L1367" class="ln">  1367	</span>
<span id="L1368" class="ln">  1368	</span><span class="comment">// A WindowUpdateFrame is used to implement flow control.</span>
<span id="L1369" class="ln">  1369	</span><span class="comment">// See http://http2.github.io/http2-spec/#rfc.section.6.9</span>
<span id="L1370" class="ln">  1370	</span>type http2WindowUpdateFrame struct {
<span id="L1371" class="ln">  1371	</span>	http2FrameHeader
<span id="L1372" class="ln">  1372	</span>	Increment uint32 <span class="comment">// never read with high bit set</span>
<span id="L1373" class="ln">  1373	</span>}
<span id="L1374" class="ln">  1374	</span>
<span id="L1375" class="ln">  1375	</span>func http2parseWindowUpdateFrame(fh http2FrameHeader, p []byte) (http2Frame, error) {
<span id="L1376" class="ln">  1376	</span>	if len(p) != 4 {
<span id="L1377" class="ln">  1377	</span>		return nil, http2ConnectionError(http2ErrCodeFrameSize)
<span id="L1378" class="ln">  1378	</span>	}
<span id="L1379" class="ln">  1379	</span>	inc := binary.BigEndian.Uint32(p[:4]) &amp; 0x7fffffff
<span id="L1380" class="ln">  1380	</span>	if inc == 0 {
<span id="L1381" class="ln">  1381	</span>
<span id="L1382" class="ln">  1382	</span>		if fh.StreamID == 0 {
<span id="L1383" class="ln">  1383	</span>			return nil, http2ConnectionError(http2ErrCodeProtocol)
<span id="L1384" class="ln">  1384	</span>		}
<span id="L1385" class="ln">  1385	</span>		return nil, http2streamError(fh.StreamID, http2ErrCodeProtocol)
<span id="L1386" class="ln">  1386	</span>	}
<span id="L1387" class="ln">  1387	</span>	return &amp;http2WindowUpdateFrame{
<span id="L1388" class="ln">  1388	</span>		http2FrameHeader: fh,
<span id="L1389" class="ln">  1389	</span>		Increment:        inc,
<span id="L1390" class="ln">  1390	</span>	}, nil
<span id="L1391" class="ln">  1391	</span>}
<span id="L1392" class="ln">  1392	</span>
<span id="L1393" class="ln">  1393	</span><span class="comment">// WriteWindowUpdate writes a WINDOW_UPDATE frame.</span>
<span id="L1394" class="ln">  1394	</span><span class="comment">// The increment value must be between 1 and 2,147,483,647, inclusive.</span>
<span id="L1395" class="ln">  1395	</span><span class="comment">// If the Stream ID is zero, the window update applies to the</span>
<span id="L1396" class="ln">  1396	</span><span class="comment">// connection as a whole.</span>
<span id="L1397" class="ln">  1397	</span>func (f *http2Framer) WriteWindowUpdate(streamID, incr uint32) error {
<span id="L1398" class="ln">  1398	</span>
<span id="L1399" class="ln">  1399	</span>	if (incr &lt; 1 || incr &gt; 2147483647) &amp;&amp; !f.AllowIllegalWrites {
<span id="L1400" class="ln">  1400	</span>		return errors.New(&#34;illegal window increment value&#34;)
<span id="L1401" class="ln">  1401	</span>	}
<span id="L1402" class="ln">  1402	</span>	f.startWrite(http2FrameWindowUpdate, 0, streamID)
<span id="L1403" class="ln">  1403	</span>	f.writeUint32(incr)
<span id="L1404" class="ln">  1404	</span>	return f.endWrite()
<span id="L1405" class="ln">  1405	</span>}
<span id="L1406" class="ln">  1406	</span>
<span id="L1407" class="ln">  1407	</span><span class="comment">// A HeadersFrame is used to open a stream and additionally carries a</span>
<span id="L1408" class="ln">  1408	</span><span class="comment">// header block fragment.</span>
<span id="L1409" class="ln">  1409	</span>type http2HeadersFrame struct {
<span id="L1410" class="ln">  1410	</span>	http2FrameHeader
<span id="L1411" class="ln">  1411	</span>
<span id="L1412" class="ln">  1412	</span>	<span class="comment">// Priority is set if FlagHeadersPriority is set in the FrameHeader.</span>
<span id="L1413" class="ln">  1413	</span>	Priority http2PriorityParam
<span id="L1414" class="ln">  1414	</span>
<span id="L1415" class="ln">  1415	</span>	headerFragBuf []byte <span class="comment">// not owned</span>
<span id="L1416" class="ln">  1416	</span>}
<span id="L1417" class="ln">  1417	</span>
<span id="L1418" class="ln">  1418	</span>func (f *http2HeadersFrame) HeaderBlockFragment() []byte {
<span id="L1419" class="ln">  1419	</span>	f.checkValid()
<span id="L1420" class="ln">  1420	</span>	return f.headerFragBuf
<span id="L1421" class="ln">  1421	</span>}
<span id="L1422" class="ln">  1422	</span>
<span id="L1423" class="ln">  1423	</span>func (f *http2HeadersFrame) HeadersEnded() bool {
<span id="L1424" class="ln">  1424	</span>	return f.http2FrameHeader.Flags.Has(http2FlagHeadersEndHeaders)
<span id="L1425" class="ln">  1425	</span>}
<span id="L1426" class="ln">  1426	</span>
<span id="L1427" class="ln">  1427	</span>func (f *http2HeadersFrame) StreamEnded() bool {
<span id="L1428" class="ln">  1428	</span>	return f.http2FrameHeader.Flags.Has(http2FlagHeadersEndStream)
<span id="L1429" class="ln">  1429	</span>}
<span id="L1430" class="ln">  1430	</span>
<span id="L1431" class="ln">  1431	</span>func (f *http2HeadersFrame) HasPriority() bool {
<span id="L1432" class="ln">  1432	</span>	return f.http2FrameHeader.Flags.Has(http2FlagHeadersPriority)
<span id="L1433" class="ln">  1433	</span>}
<span id="L1434" class="ln">  1434	</span>
<span id="L1435" class="ln">  1435	</span>func http2parseHeadersFrame(fh http2FrameHeader, p []byte) (_ http2Frame, err error) {
<span id="L1436" class="ln">  1436	</span>	hf := &amp;http2HeadersFrame{
<span id="L1437" class="ln">  1437	</span>		http2FrameHeader: fh,
<span id="L1438" class="ln">  1438	</span>	}
<span id="L1439" class="ln">  1439	</span>	if fh.StreamID == 0 {
<span id="L1440" class="ln">  1440	</span>
<span id="L1441" class="ln">  1441	</span>		return nil, http2connError{http2ErrCodeProtocol, &#34;HEADERS frame with stream ID 0&#34;}
<span id="L1442" class="ln">  1442	</span>	}
<span id="L1443" class="ln">  1443	</span>	var padLength uint8
<span id="L1444" class="ln">  1444	</span>	if fh.Flags.Has(http2FlagHeadersPadded) {
<span id="L1445" class="ln">  1445	</span>		if p, padLength, err = http2readByte(p); err != nil {
<span id="L1446" class="ln">  1446	</span>			return
<span id="L1447" class="ln">  1447	</span>		}
<span id="L1448" class="ln">  1448	</span>	}
<span id="L1449" class="ln">  1449	</span>	if fh.Flags.Has(http2FlagHeadersPriority) {
<span id="L1450" class="ln">  1450	</span>		var v uint32
<span id="L1451" class="ln">  1451	</span>		p, v, err = http2readUint32(p)
<span id="L1452" class="ln">  1452	</span>		if err != nil {
<span id="L1453" class="ln">  1453	</span>			return nil, err
<span id="L1454" class="ln">  1454	</span>		}
<span id="L1455" class="ln">  1455	</span>		hf.Priority.StreamDep = v &amp; 0x7fffffff
<span id="L1456" class="ln">  1456	</span>		hf.Priority.Exclusive = (v != hf.Priority.StreamDep)
<span id="L1457" class="ln">  1457	</span>		p, hf.Priority.Weight, err = http2readByte(p)
<span id="L1458" class="ln">  1458	</span>		if err != nil {
<span id="L1459" class="ln">  1459	</span>			return nil, err
<span id="L1460" class="ln">  1460	</span>		}
<span id="L1461" class="ln">  1461	</span>	}
<span id="L1462" class="ln">  1462	</span>	if len(p)-int(padLength) &lt;= 0 {
<span id="L1463" class="ln">  1463	</span>		return nil, http2streamError(fh.StreamID, http2ErrCodeProtocol)
<span id="L1464" class="ln">  1464	</span>	}
<span id="L1465" class="ln">  1465	</span>	hf.headerFragBuf = p[:len(p)-int(padLength)]
<span id="L1466" class="ln">  1466	</span>	return hf, nil
<span id="L1467" class="ln">  1467	</span>}
<span id="L1468" class="ln">  1468	</span>
<span id="L1469" class="ln">  1469	</span><span class="comment">// HeadersFrameParam are the parameters for writing a HEADERS frame.</span>
<span id="L1470" class="ln">  1470	</span>type http2HeadersFrameParam struct {
<span id="L1471" class="ln">  1471	</span>	<span class="comment">// StreamID is the required Stream ID to initiate.</span>
<span id="L1472" class="ln">  1472	</span>	StreamID uint32
<span id="L1473" class="ln">  1473	</span>	<span class="comment">// BlockFragment is part (or all) of a Header Block.</span>
<span id="L1474" class="ln">  1474	</span>	BlockFragment []byte
<span id="L1475" class="ln">  1475	</span>
<span id="L1476" class="ln">  1476	</span>	<span class="comment">// EndStream indicates that the header block is the last that</span>
<span id="L1477" class="ln">  1477	</span>	<span class="comment">// the endpoint will send for the identified stream. Setting</span>
<span id="L1478" class="ln">  1478	</span>	<span class="comment">// this flag causes the stream to enter one of &#34;half closed&#34;</span>
<span id="L1479" class="ln">  1479	</span>	<span class="comment">// states.</span>
<span id="L1480" class="ln">  1480	</span>	EndStream bool
<span id="L1481" class="ln">  1481	</span>
<span id="L1482" class="ln">  1482	</span>	<span class="comment">// EndHeaders indicates that this frame contains an entire</span>
<span id="L1483" class="ln">  1483	</span>	<span class="comment">// header block and is not followed by any</span>
<span id="L1484" class="ln">  1484	</span>	<span class="comment">// CONTINUATION frames.</span>
<span id="L1485" class="ln">  1485	</span>	EndHeaders bool
<span id="L1486" class="ln">  1486	</span>
<span id="L1487" class="ln">  1487	</span>	<span class="comment">// PadLength is the optional number of bytes of zeros to add</span>
<span id="L1488" class="ln">  1488	</span>	<span class="comment">// to this frame.</span>
<span id="L1489" class="ln">  1489	</span>	PadLength uint8
<span id="L1490" class="ln">  1490	</span>
<span id="L1491" class="ln">  1491	</span>	<span class="comment">// Priority, if non-zero, includes stream priority information</span>
<span id="L1492" class="ln">  1492	</span>	<span class="comment">// in the HEADER frame.</span>
<span id="L1493" class="ln">  1493	</span>	Priority http2PriorityParam
<span id="L1494" class="ln">  1494	</span>}
<span id="L1495" class="ln">  1495	</span>
<span id="L1496" class="ln">  1496	</span><span class="comment">// WriteHeaders writes a single HEADERS frame.</span>
<span id="L1497" class="ln">  1497	</span><span class="comment">//</span>
<span id="L1498" class="ln">  1498	</span><span class="comment">// This is a low-level header writing method. Encoding headers and</span>
<span id="L1499" class="ln">  1499	</span><span class="comment">// splitting them into any necessary CONTINUATION frames is handled</span>
<span id="L1500" class="ln">  1500	</span><span class="comment">// elsewhere.</span>
<span id="L1501" class="ln">  1501	</span><span class="comment">//</span>
<span id="L1502" class="ln">  1502	</span><span class="comment">// It will perform exactly one Write to the underlying Writer.</span>
<span id="L1503" class="ln">  1503	</span><span class="comment">// It is the caller&#39;s responsibility to not call other Write methods concurrently.</span>
<span id="L1504" class="ln">  1504	</span>func (f *http2Framer) WriteHeaders(p http2HeadersFrameParam) error {
<span id="L1505" class="ln">  1505	</span>	if !http2validStreamID(p.StreamID) &amp;&amp; !f.AllowIllegalWrites {
<span id="L1506" class="ln">  1506	</span>		return http2errStreamID
<span id="L1507" class="ln">  1507	</span>	}
<span id="L1508" class="ln">  1508	</span>	var flags http2Flags
<span id="L1509" class="ln">  1509	</span>	if p.PadLength != 0 {
<span id="L1510" class="ln">  1510	</span>		flags |= http2FlagHeadersPadded
<span id="L1511" class="ln">  1511	</span>	}
<span id="L1512" class="ln">  1512	</span>	if p.EndStream {
<span id="L1513" class="ln">  1513	</span>		flags |= http2FlagHeadersEndStream
<span id="L1514" class="ln">  1514	</span>	}
<span id="L1515" class="ln">  1515	</span>	if p.EndHeaders {
<span id="L1516" class="ln">  1516	</span>		flags |= http2FlagHeadersEndHeaders
<span id="L1517" class="ln">  1517	</span>	}
<span id="L1518" class="ln">  1518	</span>	if !p.Priority.IsZero() {
<span id="L1519" class="ln">  1519	</span>		flags |= http2FlagHeadersPriority
<span id="L1520" class="ln">  1520	</span>	}
<span id="L1521" class="ln">  1521	</span>	f.startWrite(http2FrameHeaders, flags, p.StreamID)
<span id="L1522" class="ln">  1522	</span>	if p.PadLength != 0 {
<span id="L1523" class="ln">  1523	</span>		f.writeByte(p.PadLength)
<span id="L1524" class="ln">  1524	</span>	}
<span id="L1525" class="ln">  1525	</span>	if !p.Priority.IsZero() {
<span id="L1526" class="ln">  1526	</span>		v := p.Priority.StreamDep
<span id="L1527" class="ln">  1527	</span>		if !http2validStreamIDOrZero(v) &amp;&amp; !f.AllowIllegalWrites {
<span id="L1528" class="ln">  1528	</span>			return http2errDepStreamID
<span id="L1529" class="ln">  1529	</span>		}
<span id="L1530" class="ln">  1530	</span>		if p.Priority.Exclusive {
<span id="L1531" class="ln">  1531	</span>			v |= 1 &lt;&lt; 31
<span id="L1532" class="ln">  1532	</span>		}
<span id="L1533" class="ln">  1533	</span>		f.writeUint32(v)
<span id="L1534" class="ln">  1534	</span>		f.writeByte(p.Priority.Weight)
<span id="L1535" class="ln">  1535	</span>	}
<span id="L1536" class="ln">  1536	</span>	f.wbuf = append(f.wbuf, p.BlockFragment...)
<span id="L1537" class="ln">  1537	</span>	f.wbuf = append(f.wbuf, http2padZeros[:p.PadLength]...)
<span id="L1538" class="ln">  1538	</span>	return f.endWrite()
<span id="L1539" class="ln">  1539	</span>}
<span id="L1540" class="ln">  1540	</span>
<span id="L1541" class="ln">  1541	</span><span class="comment">// A PriorityFrame specifies the sender-advised priority of a stream.</span>
<span id="L1542" class="ln">  1542	</span><span class="comment">// See http://http2.github.io/http2-spec/#rfc.section.6.3</span>
<span id="L1543" class="ln">  1543	</span>type http2PriorityFrame struct {
<span id="L1544" class="ln">  1544	</span>	http2FrameHeader
<span id="L1545" class="ln">  1545	</span>	http2PriorityParam
<span id="L1546" class="ln">  1546	</span>}
<span id="L1547" class="ln">  1547	</span>
<span id="L1548" class="ln">  1548	</span><span class="comment">// PriorityParam are the stream prioritzation parameters.</span>
<span id="L1549" class="ln">  1549	</span>type http2PriorityParam struct {
<span id="L1550" class="ln">  1550	</span>	<span class="comment">// StreamDep is a 31-bit stream identifier for the</span>
<span id="L1551" class="ln">  1551	</span>	<span class="comment">// stream that this stream depends on. Zero means no</span>
<span id="L1552" class="ln">  1552	</span>	<span class="comment">// dependency.</span>
<span id="L1553" class="ln">  1553	</span>	StreamDep uint32
<span id="L1554" class="ln">  1554	</span>
<span id="L1555" class="ln">  1555	</span>	<span class="comment">// Exclusive is whether the dependency is exclusive.</span>
<span id="L1556" class="ln">  1556	</span>	Exclusive bool
<span id="L1557" class="ln">  1557	</span>
<span id="L1558" class="ln">  1558	</span>	<span class="comment">// Weight is the stream&#39;s zero-indexed weight. It should be</span>
<span id="L1559" class="ln">  1559	</span>	<span class="comment">// set together with StreamDep, or neither should be set.  Per</span>
<span id="L1560" class="ln">  1560	</span>	<span class="comment">// the spec, &#34;Add one to the value to obtain a weight between</span>
<span id="L1561" class="ln">  1561	</span>	<span class="comment">// 1 and 256.&#34;</span>
<span id="L1562" class="ln">  1562	</span>	Weight uint8
<span id="L1563" class="ln">  1563	</span>}
<span id="L1564" class="ln">  1564	</span>
<span id="L1565" class="ln">  1565	</span>func (p http2PriorityParam) IsZero() bool {
<span id="L1566" class="ln">  1566	</span>	return p == http2PriorityParam{}
<span id="L1567" class="ln">  1567	</span>}
<span id="L1568" class="ln">  1568	</span>
<span id="L1569" class="ln">  1569	</span>func http2parsePriorityFrame(fh http2FrameHeader, payload []byte) (http2Frame, error) {
<span id="L1570" class="ln">  1570	</span>	if fh.StreamID == 0 {
<span id="L1571" class="ln">  1571	</span>		return nil, http2connError{http2ErrCodeProtocol, &#34;PRIORITY frame with stream ID 0&#34;}
<span id="L1572" class="ln">  1572	</span>	}
<span id="L1573" class="ln">  1573	</span>	if len(payload) != 5 {
<span id="L1574" class="ln">  1574	</span>		return nil, http2connError{http2ErrCodeFrameSize, fmt.Sprintf(&#34;PRIORITY frame payload size was %d; want 5&#34;, len(payload))}
<span id="L1575" class="ln">  1575	</span>	}
<span id="L1576" class="ln">  1576	</span>	v := binary.BigEndian.Uint32(payload[:4])
<span id="L1577" class="ln">  1577	</span>	streamID := v &amp; 0x7fffffff
<span id="L1578" class="ln">  1578	</span>	return &amp;http2PriorityFrame{
<span id="L1579" class="ln">  1579	</span>		http2FrameHeader: fh,
<span id="L1580" class="ln">  1580	</span>		http2PriorityParam: http2PriorityParam{
<span id="L1581" class="ln">  1581	</span>			Weight:    payload[4],
<span id="L1582" class="ln">  1582	</span>			StreamDep: streamID,
<span id="L1583" class="ln">  1583	</span>			Exclusive: streamID != v,
<span id="L1584" class="ln">  1584	</span>		},
<span id="L1585" class="ln">  1585	</span>	}, nil
<span id="L1586" class="ln">  1586	</span>}
<span id="L1587" class="ln">  1587	</span>
<span id="L1588" class="ln">  1588	</span><span class="comment">// WritePriority writes a PRIORITY frame.</span>
<span id="L1589" class="ln">  1589	</span><span class="comment">//</span>
<span id="L1590" class="ln">  1590	</span><span class="comment">// It will perform exactly one Write to the underlying Writer.</span>
<span id="L1591" class="ln">  1591	</span><span class="comment">// It is the caller&#39;s responsibility to not call other Write methods concurrently.</span>
<span id="L1592" class="ln">  1592	</span>func (f *http2Framer) WritePriority(streamID uint32, p http2PriorityParam) error {
<span id="L1593" class="ln">  1593	</span>	if !http2validStreamID(streamID) &amp;&amp; !f.AllowIllegalWrites {
<span id="L1594" class="ln">  1594	</span>		return http2errStreamID
<span id="L1595" class="ln">  1595	</span>	}
<span id="L1596" class="ln">  1596	</span>	if !http2validStreamIDOrZero(p.StreamDep) {
<span id="L1597" class="ln">  1597	</span>		return http2errDepStreamID
<span id="L1598" class="ln">  1598	</span>	}
<span id="L1599" class="ln">  1599	</span>	f.startWrite(http2FramePriority, 0, streamID)
<span id="L1600" class="ln">  1600	</span>	v := p.StreamDep
<span id="L1601" class="ln">  1601	</span>	if p.Exclusive {
<span id="L1602" class="ln">  1602	</span>		v |= 1 &lt;&lt; 31
<span id="L1603" class="ln">  1603	</span>	}
<span id="L1604" class="ln">  1604	</span>	f.writeUint32(v)
<span id="L1605" class="ln">  1605	</span>	f.writeByte(p.Weight)
<span id="L1606" class="ln">  1606	</span>	return f.endWrite()
<span id="L1607" class="ln">  1607	</span>}
<span id="L1608" class="ln">  1608	</span>
<span id="L1609" class="ln">  1609	</span><span class="comment">// A RSTStreamFrame allows for abnormal termination of a stream.</span>
<span id="L1610" class="ln">  1610	</span><span class="comment">// See http://http2.github.io/http2-spec/#rfc.section.6.4</span>
<span id="L1611" class="ln">  1611	</span>type http2RSTStreamFrame struct {
<span id="L1612" class="ln">  1612	</span>	http2FrameHeader
<span id="L1613" class="ln">  1613	</span>	ErrCode http2ErrCode
<span id="L1614" class="ln">  1614	</span>}
<span id="L1615" class="ln">  1615	</span>
<span id="L1616" class="ln">  1616	</span>func http2parseRSTStreamFrame(fh http2FrameHeader, p []byte) (http2Frame, error) {
<span id="L1617" class="ln">  1617	</span>	if len(p) != 4 {
<span id="L1618" class="ln">  1618	</span>		return nil, http2ConnectionError(http2ErrCodeFrameSize)
<span id="L1619" class="ln">  1619	</span>	}
<span id="L1620" class="ln">  1620	</span>	if fh.StreamID == 0 {
<span id="L1621" class="ln">  1621	</span>		return nil, http2ConnectionError(http2ErrCodeProtocol)
<span id="L1622" class="ln">  1622	</span>	}
<span id="L1623" class="ln">  1623	</span>	return &amp;http2RSTStreamFrame{fh, http2ErrCode(binary.BigEndian.Uint32(p[:4]))}, nil
<span id="L1624" class="ln">  1624	</span>}
<span id="L1625" class="ln">  1625	</span>
<span id="L1626" class="ln">  1626	</span><span class="comment">// WriteRSTStream writes a RST_STREAM frame.</span>
<span id="L1627" class="ln">  1627	</span><span class="comment">//</span>
<span id="L1628" class="ln">  1628	</span><span class="comment">// It will perform exactly one Write to the underlying Writer.</span>
<span id="L1629" class="ln">  1629	</span><span class="comment">// It is the caller&#39;s responsibility to not call other Write methods concurrently.</span>
<span id="L1630" class="ln">  1630	</span>func (f *http2Framer) WriteRSTStream(streamID uint32, code http2ErrCode) error {
<span id="L1631" class="ln">  1631	</span>	if !http2validStreamID(streamID) &amp;&amp; !f.AllowIllegalWrites {
<span id="L1632" class="ln">  1632	</span>		return http2errStreamID
<span id="L1633" class="ln">  1633	</span>	}
<span id="L1634" class="ln">  1634	</span>	f.startWrite(http2FrameRSTStream, 0, streamID)
<span id="L1635" class="ln">  1635	</span>	f.writeUint32(uint32(code))
<span id="L1636" class="ln">  1636	</span>	return f.endWrite()
<span id="L1637" class="ln">  1637	</span>}
<span id="L1638" class="ln">  1638	</span>
<span id="L1639" class="ln">  1639	</span><span class="comment">// A ContinuationFrame is used to continue a sequence of header block fragments.</span>
<span id="L1640" class="ln">  1640	</span><span class="comment">// See http://http2.github.io/http2-spec/#rfc.section.6.10</span>
<span id="L1641" class="ln">  1641	</span>type http2ContinuationFrame struct {
<span id="L1642" class="ln">  1642	</span>	http2FrameHeader
<span id="L1643" class="ln">  1643	</span>	headerFragBuf []byte
<span id="L1644" class="ln">  1644	</span>}
<span id="L1645" class="ln">  1645	</span>
<span id="L1646" class="ln">  1646	</span>func http2parseContinuationFrame(fh http2FrameHeader, p []byte) (http2Frame, error) {
<span id="L1647" class="ln">  1647	</span>	if fh.StreamID == 0 {
<span id="L1648" class="ln">  1648	</span>		return nil, http2connError{http2ErrCodeProtocol, &#34;CONTINUATION frame with stream ID 0&#34;}
<span id="L1649" class="ln">  1649	</span>	}
<span id="L1650" class="ln">  1650	</span>	return &amp;http2ContinuationFrame{fh, p}, nil
<span id="L1651" class="ln">  1651	</span>}
<span id="L1652" class="ln">  1652	</span>
<span id="L1653" class="ln">  1653	</span>func (f *http2ContinuationFrame) HeaderBlockFragment() []byte {
<span id="L1654" class="ln">  1654	</span>	f.checkValid()
<span id="L1655" class="ln">  1655	</span>	return f.headerFragBuf
<span id="L1656" class="ln">  1656	</span>}
<span id="L1657" class="ln">  1657	</span>
<span id="L1658" class="ln">  1658	</span>func (f *http2ContinuationFrame) HeadersEnded() bool {
<span id="L1659" class="ln">  1659	</span>	return f.http2FrameHeader.Flags.Has(http2FlagContinuationEndHeaders)
<span id="L1660" class="ln">  1660	</span>}
<span id="L1661" class="ln">  1661	</span>
<span id="L1662" class="ln">  1662	</span><span class="comment">// WriteContinuation writes a CONTINUATION frame.</span>
<span id="L1663" class="ln">  1663	</span><span class="comment">//</span>
<span id="L1664" class="ln">  1664	</span><span class="comment">// It will perform exactly one Write to the underlying Writer.</span>
<span id="L1665" class="ln">  1665	</span><span class="comment">// It is the caller&#39;s responsibility to not call other Write methods concurrently.</span>
<span id="L1666" class="ln">  1666	</span>func (f *http2Framer) WriteContinuation(streamID uint32, endHeaders bool, headerBlockFragment []byte) error {
<span id="L1667" class="ln">  1667	</span>	if !http2validStreamID(streamID) &amp;&amp; !f.AllowIllegalWrites {
<span id="L1668" class="ln">  1668	</span>		return http2errStreamID
<span id="L1669" class="ln">  1669	</span>	}
<span id="L1670" class="ln">  1670	</span>	var flags http2Flags
<span id="L1671" class="ln">  1671	</span>	if endHeaders {
<span id="L1672" class="ln">  1672	</span>		flags |= http2FlagContinuationEndHeaders
<span id="L1673" class="ln">  1673	</span>	}
<span id="L1674" class="ln">  1674	</span>	f.startWrite(http2FrameContinuation, flags, streamID)
<span id="L1675" class="ln">  1675	</span>	f.wbuf = append(f.wbuf, headerBlockFragment...)
<span id="L1676" class="ln">  1676	</span>	return f.endWrite()
<span id="L1677" class="ln">  1677	</span>}
<span id="L1678" class="ln">  1678	</span>
<span id="L1679" class="ln">  1679	</span><span class="comment">// A PushPromiseFrame is used to initiate a server stream.</span>
<span id="L1680" class="ln">  1680	</span><span class="comment">// See http://http2.github.io/http2-spec/#rfc.section.6.6</span>
<span id="L1681" class="ln">  1681	</span>type http2PushPromiseFrame struct {
<span id="L1682" class="ln">  1682	</span>	http2FrameHeader
<span id="L1683" class="ln">  1683	</span>	PromiseID     uint32
<span id="L1684" class="ln">  1684	</span>	headerFragBuf []byte <span class="comment">// not owned</span>
<span id="L1685" class="ln">  1685	</span>}
<span id="L1686" class="ln">  1686	</span>
<span id="L1687" class="ln">  1687	</span>func (f *http2PushPromiseFrame) HeaderBlockFragment() []byte {
<span id="L1688" class="ln">  1688	</span>	f.checkValid()
<span id="L1689" class="ln">  1689	</span>	return f.headerFragBuf
<span id="L1690" class="ln">  1690	</span>}
<span id="L1691" class="ln">  1691	</span>
<span id="L1692" class="ln">  1692	</span>func (f *http2PushPromiseFrame) HeadersEnded() bool {
<span id="L1693" class="ln">  1693	</span>	return f.http2FrameHeader.Flags.Has(http2FlagPushPromiseEndHeaders)
<span id="L1694" class="ln">  1694	</span>}
<span id="L1695" class="ln">  1695	</span>
<span id="L1696" class="ln">  1696	</span>func http2parsePushPromise(fh http2FrameHeader, p []byte) (_ http2Frame, err error) {
<span id="L1697" class="ln">  1697	</span>	pp := &amp;http2PushPromiseFrame{
<span id="L1698" class="ln">  1698	</span>		http2FrameHeader: fh,
<span id="L1699" class="ln">  1699	</span>	}
<span id="L1700" class="ln">  1700	</span>	if pp.StreamID == 0 {
<span id="L1701" class="ln">  1701	</span>
<span id="L1702" class="ln">  1702	</span>		return nil, http2ConnectionError(http2ErrCodeProtocol)
<span id="L1703" class="ln">  1703	</span>	}
<span id="L1704" class="ln">  1704	</span>	<span class="comment">// The PUSH_PROMISE frame includes optional padding.</span>
<span id="L1705" class="ln">  1705	</span>	<span class="comment">// Padding fields and flags are identical to those defined for DATA frames</span>
<span id="L1706" class="ln">  1706	</span>	var padLength uint8
<span id="L1707" class="ln">  1707	</span>	if fh.Flags.Has(http2FlagPushPromisePadded) {
<span id="L1708" class="ln">  1708	</span>		if p, padLength, err = http2readByte(p); err != nil {
<span id="L1709" class="ln">  1709	</span>			return
<span id="L1710" class="ln">  1710	</span>		}
<span id="L1711" class="ln">  1711	</span>	}
<span id="L1712" class="ln">  1712	</span>
<span id="L1713" class="ln">  1713	</span>	p, pp.PromiseID, err = http2readUint32(p)
<span id="L1714" class="ln">  1714	</span>	if err != nil {
<span id="L1715" class="ln">  1715	</span>		return
<span id="L1716" class="ln">  1716	</span>	}
<span id="L1717" class="ln">  1717	</span>	pp.PromiseID = pp.PromiseID &amp; (1&lt;&lt;31 - 1)
<span id="L1718" class="ln">  1718	</span>
<span id="L1719" class="ln">  1719	</span>	if int(padLength) &gt; len(p) {
<span id="L1720" class="ln">  1720	</span>
<span id="L1721" class="ln">  1721	</span>		return nil, http2ConnectionError(http2ErrCodeProtocol)
<span id="L1722" class="ln">  1722	</span>	}
<span id="L1723" class="ln">  1723	</span>	pp.headerFragBuf = p[:len(p)-int(padLength)]
<span id="L1724" class="ln">  1724	</span>	return pp, nil
<span id="L1725" class="ln">  1725	</span>}
<span id="L1726" class="ln">  1726	</span>
<span id="L1727" class="ln">  1727	</span><span class="comment">// PushPromiseParam are the parameters for writing a PUSH_PROMISE frame.</span>
<span id="L1728" class="ln">  1728	</span>type http2PushPromiseParam struct {
<span id="L1729" class="ln">  1729	</span>	<span class="comment">// StreamID is the required Stream ID to initiate.</span>
<span id="L1730" class="ln">  1730	</span>	StreamID uint32
<span id="L1731" class="ln">  1731	</span>
<span id="L1732" class="ln">  1732	</span>	<span class="comment">// PromiseID is the required Stream ID which this</span>
<span id="L1733" class="ln">  1733	</span>	<span class="comment">// Push Promises</span>
<span id="L1734" class="ln">  1734	</span>	PromiseID uint32
<span id="L1735" class="ln">  1735	</span>
<span id="L1736" class="ln">  1736	</span>	<span class="comment">// BlockFragment is part (or all) of a Header Block.</span>
<span id="L1737" class="ln">  1737	</span>	BlockFragment []byte
<span id="L1738" class="ln">  1738	</span>
<span id="L1739" class="ln">  1739	</span>	<span class="comment">// EndHeaders indicates that this frame contains an entire</span>
<span id="L1740" class="ln">  1740	</span>	<span class="comment">// header block and is not followed by any</span>
<span id="L1741" class="ln">  1741	</span>	<span class="comment">// CONTINUATION frames.</span>
<span id="L1742" class="ln">  1742	</span>	EndHeaders bool
<span id="L1743" class="ln">  1743	</span>
<span id="L1744" class="ln">  1744	</span>	<span class="comment">// PadLength is the optional number of bytes of zeros to add</span>
<span id="L1745" class="ln">  1745	</span>	<span class="comment">// to this frame.</span>
<span id="L1746" class="ln">  1746	</span>	PadLength uint8
<span id="L1747" class="ln">  1747	</span>}
<span id="L1748" class="ln">  1748	</span>
<span id="L1749" class="ln">  1749	</span><span class="comment">// WritePushPromise writes a single PushPromise Frame.</span>
<span id="L1750" class="ln">  1750	</span><span class="comment">//</span>
<span id="L1751" class="ln">  1751	</span><span class="comment">// As with Header Frames, This is the low level call for writing</span>
<span id="L1752" class="ln">  1752	</span><span class="comment">// individual frames. Continuation frames are handled elsewhere.</span>
<span id="L1753" class="ln">  1753	</span><span class="comment">//</span>
<span id="L1754" class="ln">  1754	</span><span class="comment">// It will perform exactly one Write to the underlying Writer.</span>
<span id="L1755" class="ln">  1755	</span><span class="comment">// It is the caller&#39;s responsibility to not call other Write methods concurrently.</span>
<span id="L1756" class="ln">  1756	</span>func (f *http2Framer) WritePushPromise(p http2PushPromiseParam) error {
<span id="L1757" class="ln">  1757	</span>	if !http2validStreamID(p.StreamID) &amp;&amp; !f.AllowIllegalWrites {
<span id="L1758" class="ln">  1758	</span>		return http2errStreamID
<span id="L1759" class="ln">  1759	</span>	}
<span id="L1760" class="ln">  1760	</span>	var flags http2Flags
<span id="L1761" class="ln">  1761	</span>	if p.PadLength != 0 {
<span id="L1762" class="ln">  1762	</span>		flags |= http2FlagPushPromisePadded
<span id="L1763" class="ln">  1763	</span>	}
<span id="L1764" class="ln">  1764	</span>	if p.EndHeaders {
<span id="L1765" class="ln">  1765	</span>		flags |= http2FlagPushPromiseEndHeaders
<span id="L1766" class="ln">  1766	</span>	}
<span id="L1767" class="ln">  1767	</span>	f.startWrite(http2FramePushPromise, flags, p.StreamID)
<span id="L1768" class="ln">  1768	</span>	if p.PadLength != 0 {
<span id="L1769" class="ln">  1769	</span>		f.writeByte(p.PadLength)
<span id="L1770" class="ln">  1770	</span>	}
<span id="L1771" class="ln">  1771	</span>	if !http2validStreamID(p.PromiseID) &amp;&amp; !f.AllowIllegalWrites {
<span id="L1772" class="ln">  1772	</span>		return http2errStreamID
<span id="L1773" class="ln">  1773	</span>	}
<span id="L1774" class="ln">  1774	</span>	f.writeUint32(p.PromiseID)
<span id="L1775" class="ln">  1775	</span>	f.wbuf = append(f.wbuf, p.BlockFragment...)
<span id="L1776" class="ln">  1776	</span>	f.wbuf = append(f.wbuf, http2padZeros[:p.PadLength]...)
<span id="L1777" class="ln">  1777	</span>	return f.endWrite()
<span id="L1778" class="ln">  1778	</span>}
<span id="L1779" class="ln">  1779	</span>
<span id="L1780" class="ln">  1780	</span><span class="comment">// WriteRawFrame writes a raw frame. This can be used to write</span>
<span id="L1781" class="ln">  1781	</span><span class="comment">// extension frames unknown to this package.</span>
<span id="L1782" class="ln">  1782	</span>func (f *http2Framer) WriteRawFrame(t http2FrameType, flags http2Flags, streamID uint32, payload []byte) error {
<span id="L1783" class="ln">  1783	</span>	f.startWrite(t, flags, streamID)
<span id="L1784" class="ln">  1784	</span>	f.writeBytes(payload)
<span id="L1785" class="ln">  1785	</span>	return f.endWrite()
<span id="L1786" class="ln">  1786	</span>}
<span id="L1787" class="ln">  1787	</span>
<span id="L1788" class="ln">  1788	</span>func http2readByte(p []byte) (remain []byte, b byte, err error) {
<span id="L1789" class="ln">  1789	</span>	if len(p) == 0 {
<span id="L1790" class="ln">  1790	</span>		return nil, 0, io.ErrUnexpectedEOF
<span id="L1791" class="ln">  1791	</span>	}
<span id="L1792" class="ln">  1792	</span>	return p[1:], p[0], nil
<span id="L1793" class="ln">  1793	</span>}
<span id="L1794" class="ln">  1794	</span>
<span id="L1795" class="ln">  1795	</span>func http2readUint32(p []byte) (remain []byte, v uint32, err error) {
<span id="L1796" class="ln">  1796	</span>	if len(p) &lt; 4 {
<span id="L1797" class="ln">  1797	</span>		return nil, 0, io.ErrUnexpectedEOF
<span id="L1798" class="ln">  1798	</span>	}
<span id="L1799" class="ln">  1799	</span>	return p[4:], binary.BigEndian.Uint32(p[:4]), nil
<span id="L1800" class="ln">  1800	</span>}
<span id="L1801" class="ln">  1801	</span>
<span id="L1802" class="ln">  1802	</span>type http2streamEnder interface {
<span id="L1803" class="ln">  1803	</span>	StreamEnded() bool
<span id="L1804" class="ln">  1804	</span>}
<span id="L1805" class="ln">  1805	</span>
<span id="L1806" class="ln">  1806	</span>type http2headersEnder interface {
<span id="L1807" class="ln">  1807	</span>	HeadersEnded() bool
<span id="L1808" class="ln">  1808	</span>}
<span id="L1809" class="ln">  1809	</span>
<span id="L1810" class="ln">  1810	</span>type http2headersOrContinuation interface {
<span id="L1811" class="ln">  1811	</span>	http2headersEnder
<span id="L1812" class="ln">  1812	</span>	HeaderBlockFragment() []byte
<span id="L1813" class="ln">  1813	</span>}
<span id="L1814" class="ln">  1814	</span>
<span id="L1815" class="ln">  1815	</span><span class="comment">// A MetaHeadersFrame is the representation of one HEADERS frame and</span>
<span id="L1816" class="ln">  1816	</span><span class="comment">// zero or more contiguous CONTINUATION frames and the decoding of</span>
<span id="L1817" class="ln">  1817	</span><span class="comment">// their HPACK-encoded contents.</span>
<span id="L1818" class="ln">  1818	</span><span class="comment">//</span>
<span id="L1819" class="ln">  1819	</span><span class="comment">// This type of frame does not appear on the wire and is only returned</span>
<span id="L1820" class="ln">  1820	</span><span class="comment">// by the Framer when Framer.ReadMetaHeaders is set.</span>
<span id="L1821" class="ln">  1821	</span>type http2MetaHeadersFrame struct {
<span id="L1822" class="ln">  1822	</span>	*http2HeadersFrame
<span id="L1823" class="ln">  1823	</span>
<span id="L1824" class="ln">  1824	</span>	<span class="comment">// Fields are the fields contained in the HEADERS and</span>
<span id="L1825" class="ln">  1825	</span>	<span class="comment">// CONTINUATION frames. The underlying slice is owned by the</span>
<span id="L1826" class="ln">  1826	</span>	<span class="comment">// Framer and must not be retained after the next call to</span>
<span id="L1827" class="ln">  1827	</span>	<span class="comment">// ReadFrame.</span>
<span id="L1828" class="ln">  1828	</span>	<span class="comment">//</span>
<span id="L1829" class="ln">  1829	</span>	<span class="comment">// Fields are guaranteed to be in the correct http2 order and</span>
<span id="L1830" class="ln">  1830	</span>	<span class="comment">// not have unknown pseudo header fields or invalid header</span>
<span id="L1831" class="ln">  1831	</span>	<span class="comment">// field names or values. Required pseudo header fields may be</span>
<span id="L1832" class="ln">  1832	</span>	<span class="comment">// missing, however. Use the MetaHeadersFrame.Pseudo accessor</span>
<span id="L1833" class="ln">  1833	</span>	<span class="comment">// method access pseudo headers.</span>
<span id="L1834" class="ln">  1834	</span>	Fields []hpack.HeaderField
<span id="L1835" class="ln">  1835	</span>
<span id="L1836" class="ln">  1836	</span>	<span class="comment">// Truncated is whether the max header list size limit was hit</span>
<span id="L1837" class="ln">  1837	</span>	<span class="comment">// and Fields is incomplete. The hpack decoder state is still</span>
<span id="L1838" class="ln">  1838	</span>	<span class="comment">// valid, however.</span>
<span id="L1839" class="ln">  1839	</span>	Truncated bool
<span id="L1840" class="ln">  1840	</span>}
<span id="L1841" class="ln">  1841	</span>
<span id="L1842" class="ln">  1842	</span><span class="comment">// PseudoValue returns the given pseudo header field&#39;s value.</span>
<span id="L1843" class="ln">  1843	</span><span class="comment">// The provided pseudo field should not contain the leading colon.</span>
<span id="L1844" class="ln">  1844	</span>func (mh *http2MetaHeadersFrame) PseudoValue(pseudo string) string {
<span id="L1845" class="ln">  1845	</span>	for _, hf := range mh.Fields {
<span id="L1846" class="ln">  1846	</span>		if !hf.IsPseudo() {
<span id="L1847" class="ln">  1847	</span>			return &#34;&#34;
<span id="L1848" class="ln">  1848	</span>		}
<span id="L1849" class="ln">  1849	</span>		if hf.Name[1:] == pseudo {
<span id="L1850" class="ln">  1850	</span>			return hf.Value
<span id="L1851" class="ln">  1851	</span>		}
<span id="L1852" class="ln">  1852	</span>	}
<span id="L1853" class="ln">  1853	</span>	return &#34;&#34;
<span id="L1854" class="ln">  1854	</span>}
<span id="L1855" class="ln">  1855	</span>
<span id="L1856" class="ln">  1856	</span><span class="comment">// RegularFields returns the regular (non-pseudo) header fields of mh.</span>
<span id="L1857" class="ln">  1857	</span><span class="comment">// The caller does not own the returned slice.</span>
<span id="L1858" class="ln">  1858	</span>func (mh *http2MetaHeadersFrame) RegularFields() []hpack.HeaderField {
<span id="L1859" class="ln">  1859	</span>	for i, hf := range mh.Fields {
<span id="L1860" class="ln">  1860	</span>		if !hf.IsPseudo() {
<span id="L1861" class="ln">  1861	</span>			return mh.Fields[i:]
<span id="L1862" class="ln">  1862	</span>		}
<span id="L1863" class="ln">  1863	</span>	}
<span id="L1864" class="ln">  1864	</span>	return nil
<span id="L1865" class="ln">  1865	</span>}
<span id="L1866" class="ln">  1866	</span>
<span id="L1867" class="ln">  1867	</span><span class="comment">// PseudoFields returns the pseudo header fields of mh.</span>
<span id="L1868" class="ln">  1868	</span><span class="comment">// The caller does not own the returned slice.</span>
<span id="L1869" class="ln">  1869	</span>func (mh *http2MetaHeadersFrame) PseudoFields() []hpack.HeaderField {
<span id="L1870" class="ln">  1870	</span>	for i, hf := range mh.Fields {
<span id="L1871" class="ln">  1871	</span>		if !hf.IsPseudo() {
<span id="L1872" class="ln">  1872	</span>			return mh.Fields[:i]
<span id="L1873" class="ln">  1873	</span>		}
<span id="L1874" class="ln">  1874	</span>	}
<span id="L1875" class="ln">  1875	</span>	return mh.Fields
<span id="L1876" class="ln">  1876	</span>}
<span id="L1877" class="ln">  1877	</span>
<span id="L1878" class="ln">  1878	</span>func (mh *http2MetaHeadersFrame) checkPseudos() error {
<span id="L1879" class="ln">  1879	</span>	var isRequest, isResponse bool
<span id="L1880" class="ln">  1880	</span>	pf := mh.PseudoFields()
<span id="L1881" class="ln">  1881	</span>	for i, hf := range pf {
<span id="L1882" class="ln">  1882	</span>		switch hf.Name {
<span id="L1883" class="ln">  1883	</span>		case &#34;:method&#34;, &#34;:path&#34;, &#34;:scheme&#34;, &#34;:authority&#34;:
<span id="L1884" class="ln">  1884	</span>			isRequest = true
<span id="L1885" class="ln">  1885	</span>		case &#34;:status&#34;:
<span id="L1886" class="ln">  1886	</span>			isResponse = true
<span id="L1887" class="ln">  1887	</span>		default:
<span id="L1888" class="ln">  1888	</span>			return http2pseudoHeaderError(hf.Name)
<span id="L1889" class="ln">  1889	</span>		}
<span id="L1890" class="ln">  1890	</span>
<span id="L1891" class="ln">  1891	</span>		for _, hf2 := range pf[:i] {
<span id="L1892" class="ln">  1892	</span>			if hf.Name == hf2.Name {
<span id="L1893" class="ln">  1893	</span>				return http2duplicatePseudoHeaderError(hf.Name)
<span id="L1894" class="ln">  1894	</span>			}
<span id="L1895" class="ln">  1895	</span>		}
<span id="L1896" class="ln">  1896	</span>	}
<span id="L1897" class="ln">  1897	</span>	if isRequest &amp;&amp; isResponse {
<span id="L1898" class="ln">  1898	</span>		return http2errMixPseudoHeaderTypes
<span id="L1899" class="ln">  1899	</span>	}
<span id="L1900" class="ln">  1900	</span>	return nil
<span id="L1901" class="ln">  1901	</span>}
<span id="L1902" class="ln">  1902	</span>
<span id="L1903" class="ln">  1903	</span>func (fr *http2Framer) maxHeaderStringLen() int {
<span id="L1904" class="ln">  1904	</span>	v := fr.maxHeaderListSize()
<span id="L1905" class="ln">  1905	</span>	if uint32(int(v)) == v {
<span id="L1906" class="ln">  1906	</span>		return int(v)
<span id="L1907" class="ln">  1907	</span>	}
<span id="L1908" class="ln">  1908	</span>
<span id="L1909" class="ln">  1909	</span>	return 0
<span id="L1910" class="ln">  1910	</span>}
<span id="L1911" class="ln">  1911	</span>
<span id="L1912" class="ln">  1912	</span><span class="comment">// readMetaFrame returns 0 or more CONTINUATION frames from fr and</span>
<span id="L1913" class="ln">  1913	</span><span class="comment">// merge them into into the provided hf and returns a MetaHeadersFrame</span>
<span id="L1914" class="ln">  1914	</span><span class="comment">// with the decoded hpack values.</span>
<span id="L1915" class="ln">  1915	</span>func (fr *http2Framer) readMetaFrame(hf *http2HeadersFrame) (*http2MetaHeadersFrame, error) {
<span id="L1916" class="ln">  1916	</span>	if fr.AllowIllegalReads {
<span id="L1917" class="ln">  1917	</span>		return nil, errors.New(&#34;illegal use of AllowIllegalReads with ReadMetaHeaders&#34;)
<span id="L1918" class="ln">  1918	</span>	}
<span id="L1919" class="ln">  1919	</span>	mh := &amp;http2MetaHeadersFrame{
<span id="L1920" class="ln">  1920	</span>		http2HeadersFrame: hf,
<span id="L1921" class="ln">  1921	</span>	}
<span id="L1922" class="ln">  1922	</span>	var remainSize = fr.maxHeaderListSize()
<span id="L1923" class="ln">  1923	</span>	var sawRegular bool
<span id="L1924" class="ln">  1924	</span>
<span id="L1925" class="ln">  1925	</span>	var invalid error <span class="comment">// pseudo header field errors</span>
<span id="L1926" class="ln">  1926	</span>	hdec := fr.ReadMetaHeaders
<span id="L1927" class="ln">  1927	</span>	hdec.SetEmitEnabled(true)
<span id="L1928" class="ln">  1928	</span>	hdec.SetMaxStringLength(fr.maxHeaderStringLen())
<span id="L1929" class="ln">  1929	</span>	hdec.SetEmitFunc(func(hf hpack.HeaderField) {
<span id="L1930" class="ln">  1930	</span>		if http2VerboseLogs &amp;&amp; fr.logReads {
<span id="L1931" class="ln">  1931	</span>			fr.debugReadLoggerf(&#34;http2: decoded hpack field %+v&#34;, hf)
<span id="L1932" class="ln">  1932	</span>		}
<span id="L1933" class="ln">  1933	</span>		if !httplex.ValidHeaderFieldValue(hf.Value) {
<span id="L1934" class="ln">  1934	</span>			invalid = http2headerFieldValueError(hf.Value)
<span id="L1935" class="ln">  1935	</span>		}
<span id="L1936" class="ln">  1936	</span>		isPseudo := strings.HasPrefix(hf.Name, &#34;:&#34;)
<span id="L1937" class="ln">  1937	</span>		if isPseudo {
<span id="L1938" class="ln">  1938	</span>			if sawRegular {
<span id="L1939" class="ln">  1939	</span>				invalid = http2errPseudoAfterRegular
<span id="L1940" class="ln">  1940	</span>			}
<span id="L1941" class="ln">  1941	</span>		} else {
<span id="L1942" class="ln">  1942	</span>			sawRegular = true
<span id="L1943" class="ln">  1943	</span>			if !http2validWireHeaderFieldName(hf.Name) {
<span id="L1944" class="ln">  1944	</span>				invalid = http2headerFieldNameError(hf.Name)
<span id="L1945" class="ln">  1945	</span>			}
<span id="L1946" class="ln">  1946	</span>		}
<span id="L1947" class="ln">  1947	</span>
<span id="L1948" class="ln">  1948	</span>		if invalid != nil {
<span id="L1949" class="ln">  1949	</span>			hdec.SetEmitEnabled(false)
<span id="L1950" class="ln">  1950	</span>			return
<span id="L1951" class="ln">  1951	</span>		}
<span id="L1952" class="ln">  1952	</span>
<span id="L1953" class="ln">  1953	</span>		size := hf.Size()
<span id="L1954" class="ln">  1954	</span>		if size &gt; remainSize {
<span id="L1955" class="ln">  1955	</span>			hdec.SetEmitEnabled(false)
<span id="L1956" class="ln">  1956	</span>			mh.Truncated = true
<span id="L1957" class="ln">  1957	</span>			return
<span id="L1958" class="ln">  1958	</span>		}
<span id="L1959" class="ln">  1959	</span>		remainSize -= size
<span id="L1960" class="ln">  1960	</span>
<span id="L1961" class="ln">  1961	</span>		mh.Fields = append(mh.Fields, hf)
<span id="L1962" class="ln">  1962	</span>	})
<span id="L1963" class="ln">  1963	</span>
<span id="L1964" class="ln">  1964	</span>	defer hdec.SetEmitFunc(func(hf hpack.HeaderField) {})
<span id="L1965" class="ln">  1965	</span>
<span id="L1966" class="ln">  1966	</span>	var hc http2headersOrContinuation = hf
<span id="L1967" class="ln">  1967	</span>	for {
<span id="L1968" class="ln">  1968	</span>		frag := hc.HeaderBlockFragment()
<span id="L1969" class="ln">  1969	</span>		if _, err := hdec.Write(frag); err != nil {
<span id="L1970" class="ln">  1970	</span>			return nil, http2ConnectionError(http2ErrCodeCompression)
<span id="L1971" class="ln">  1971	</span>		}
<span id="L1972" class="ln">  1972	</span>
<span id="L1973" class="ln">  1973	</span>		if hc.HeadersEnded() {
<span id="L1974" class="ln">  1974	</span>			break
<span id="L1975" class="ln">  1975	</span>		}
<span id="L1976" class="ln">  1976	</span>		if f, err := fr.ReadFrame(); err != nil {
<span id="L1977" class="ln">  1977	</span>			return nil, err
<span id="L1978" class="ln">  1978	</span>		} else {
<span id="L1979" class="ln">  1979	</span>			hc = f.(*http2ContinuationFrame)
<span id="L1980" class="ln">  1980	</span>		}
<span id="L1981" class="ln">  1981	</span>	}
<span id="L1982" class="ln">  1982	</span>
<span id="L1983" class="ln">  1983	</span>	mh.http2HeadersFrame.headerFragBuf = nil
<span id="L1984" class="ln">  1984	</span>	mh.http2HeadersFrame.invalidate()
<span id="L1985" class="ln">  1985	</span>
<span id="L1986" class="ln">  1986	</span>	if err := hdec.Close(); err != nil {
<span id="L1987" class="ln">  1987	</span>		return nil, http2ConnectionError(http2ErrCodeCompression)
<span id="L1988" class="ln">  1988	</span>	}
<span id="L1989" class="ln">  1989	</span>	if invalid != nil {
<span id="L1990" class="ln">  1990	</span>		fr.errDetail = invalid
<span id="L1991" class="ln">  1991	</span>		if http2VerboseLogs {
<span id="L1992" class="ln">  1992	</span>			log.Printf(&#34;http2: invalid header: %v&#34;, invalid)
<span id="L1993" class="ln">  1993	</span>		}
<span id="L1994" class="ln">  1994	</span>		return nil, http2StreamError{mh.StreamID, http2ErrCodeProtocol, invalid}
<span id="L1995" class="ln">  1995	</span>	}
<span id="L1996" class="ln">  1996	</span>	if err := mh.checkPseudos(); err != nil {
<span id="L1997" class="ln">  1997	</span>		fr.errDetail = err
<span id="L1998" class="ln">  1998	</span>		if http2VerboseLogs {
<span id="L1999" class="ln">  1999	</span>			log.Printf(&#34;http2: invalid pseudo headers: %v&#34;, err)
<span id="L2000" class="ln">  2000	</span>		}
<span id="L2001" class="ln">  2001	</span>		return nil, http2StreamError{mh.StreamID, http2ErrCodeProtocol, err}
<span id="L2002" class="ln">  2002	</span>	}
<span id="L2003" class="ln">  2003	</span>	return mh, nil
<span id="L2004" class="ln">  2004	</span>}
<span id="L2005" class="ln">  2005	</span>
<span id="L2006" class="ln">  2006	</span>func http2summarizeFrame(f http2Frame) string {
<span id="L2007" class="ln">  2007	</span>	var buf bytes.Buffer
<span id="L2008" class="ln">  2008	</span>	f.Header().writeDebug(&amp;buf)
<span id="L2009" class="ln">  2009	</span>	switch f := f.(type) {
<span id="L2010" class="ln">  2010	</span>	case *http2SettingsFrame:
<span id="L2011" class="ln">  2011	</span>		n := 0
<span id="L2012" class="ln">  2012	</span>		f.ForeachSetting(func(s http2Setting) error {
<span id="L2013" class="ln">  2013	</span>			n++
<span id="L2014" class="ln">  2014	</span>			if n == 1 {
<span id="L2015" class="ln">  2015	</span>				buf.WriteString(&#34;, settings:&#34;)
<span id="L2016" class="ln">  2016	</span>			}
<span id="L2017" class="ln">  2017	</span>			fmt.Fprintf(&amp;buf, &#34; %v=%v,&#34;, s.ID, s.Val)
<span id="L2018" class="ln">  2018	</span>			return nil
<span id="L2019" class="ln">  2019	</span>		})
<span id="L2020" class="ln">  2020	</span>		if n &gt; 0 {
<span id="L2021" class="ln">  2021	</span>			buf.Truncate(buf.Len() - 1)
<span id="L2022" class="ln">  2022	</span>		}
<span id="L2023" class="ln">  2023	</span>	case *http2DataFrame:
<span id="L2024" class="ln">  2024	</span>		data := f.Data()
<span id="L2025" class="ln">  2025	</span>		const max = 256
<span id="L2026" class="ln">  2026	</span>		if len(data) &gt; max {
<span id="L2027" class="ln">  2027	</span>			data = data[:max]
<span id="L2028" class="ln">  2028	</span>		}
<span id="L2029" class="ln">  2029	</span>		fmt.Fprintf(&amp;buf, &#34; data=%q&#34;, data)
<span id="L2030" class="ln">  2030	</span>		if len(f.Data()) &gt; max {
<span id="L2031" class="ln">  2031	</span>			fmt.Fprintf(&amp;buf, &#34; (%d bytes omitted)&#34;, len(f.Data())-max)
<span id="L2032" class="ln">  2032	</span>		}
<span id="L2033" class="ln">  2033	</span>	case *http2WindowUpdateFrame:
<span id="L2034" class="ln">  2034	</span>		if f.StreamID == 0 {
<span id="L2035" class="ln">  2035	</span>			buf.WriteString(&#34; (conn)&#34;)
<span id="L2036" class="ln">  2036	</span>		}
<span id="L2037" class="ln">  2037	</span>		fmt.Fprintf(&amp;buf, &#34; incr=%v&#34;, f.Increment)
<span id="L2038" class="ln">  2038	</span>	case *http2PingFrame:
<span id="L2039" class="ln">  2039	</span>		fmt.Fprintf(&amp;buf, &#34; ping=%q&#34;, f.Data[:])
<span id="L2040" class="ln">  2040	</span>	case *http2GoAwayFrame:
<span id="L2041" class="ln">  2041	</span>		fmt.Fprintf(&amp;buf, &#34; LastStreamID=%v ErrCode=%v Debug=%q&#34;,
<span id="L2042" class="ln">  2042	</span>			f.LastStreamID, f.ErrCode, f.debugData)
<span id="L2043" class="ln">  2043	</span>	case *http2RSTStreamFrame:
<span id="L2044" class="ln">  2044	</span>		fmt.Fprintf(&amp;buf, &#34; ErrCode=%v&#34;, f.ErrCode)
<span id="L2045" class="ln">  2045	</span>	}
<span id="L2046" class="ln">  2046	</span>	return buf.String()
<span id="L2047" class="ln">  2047	</span>}
<span id="L2048" class="ln">  2048	</span>
<span id="L2049" class="ln">  2049	</span>func http2transportExpectContinueTimeout(t1 *Transport) time.Duration {
<span id="L2050" class="ln">  2050	</span>	return t1.ExpectContinueTimeout
<span id="L2051" class="ln">  2051	</span>}
<span id="L2052" class="ln">  2052	</span>
<span id="L2053" class="ln">  2053	</span><span class="comment">// isBadCipher reports whether the cipher is blacklisted by the HTTP/2 spec.</span>
<span id="L2054" class="ln">  2054	</span>func http2isBadCipher(cipher uint16) bool {
<span id="L2055" class="ln">  2055	</span>	switch cipher {
<span id="L2056" class="ln">  2056	</span>	case tls.TLS_RSA_WITH_RC4_128_SHA,
<span id="L2057" class="ln">  2057	</span>		tls.TLS_RSA_WITH_3DES_EDE_CBC_SHA,
<span id="L2058" class="ln">  2058	</span>		tls.TLS_RSA_WITH_AES_128_CBC_SHA,
<span id="L2059" class="ln">  2059	</span>		tls.TLS_RSA_WITH_AES_256_CBC_SHA,
<span id="L2060" class="ln">  2060	</span>		tls.TLS_RSA_WITH_AES_128_GCM_SHA256,
<span id="L2061" class="ln">  2061	</span>		tls.TLS_RSA_WITH_AES_256_GCM_SHA384,
<span id="L2062" class="ln">  2062	</span>		tls.TLS_ECDHE_ECDSA_WITH_RC4_128_SHA,
<span id="L2063" class="ln">  2063	</span>		tls.TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA,
<span id="L2064" class="ln">  2064	</span>		tls.TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA,
<span id="L2065" class="ln">  2065	</span>		tls.TLS_ECDHE_RSA_WITH_RC4_128_SHA,
<span id="L2066" class="ln">  2066	</span>		tls.TLS_ECDHE_RSA_WITH_3DES_EDE_CBC_SHA,
<span id="L2067" class="ln">  2067	</span>		tls.TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA,
<span id="L2068" class="ln">  2068	</span>		tls.TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA:
<span id="L2069" class="ln">  2069	</span>
<span id="L2070" class="ln">  2070	</span>		return true
<span id="L2071" class="ln">  2071	</span>	default:
<span id="L2072" class="ln">  2072	</span>		return false
<span id="L2073" class="ln">  2073	</span>	}
<span id="L2074" class="ln">  2074	</span>}
<span id="L2075" class="ln">  2075	</span>
<span id="L2076" class="ln">  2076	</span>type http2contextContext interface {
<span id="L2077" class="ln">  2077	</span>	context.Context
<span id="L2078" class="ln">  2078	</span>}
<span id="L2079" class="ln">  2079	</span>
<span id="L2080" class="ln">  2080	</span>func http2serverConnBaseContext(c net.Conn, opts *http2ServeConnOpts) (ctx http2contextContext, cancel func()) {
<span id="L2081" class="ln">  2081	</span>	ctx, cancel = context.WithCancel(context.Background())
<span id="L2082" class="ln">  2082	</span>	ctx = context.WithValue(ctx, LocalAddrContextKey, c.LocalAddr())
<span id="L2083" class="ln">  2083	</span>	if hs := opts.baseConfig(); hs != nil {
<span id="L2084" class="ln">  2084	</span>		ctx = context.WithValue(ctx, ServerContextKey, hs)
<span id="L2085" class="ln">  2085	</span>	}
<span id="L2086" class="ln">  2086	</span>	return
<span id="L2087" class="ln">  2087	</span>}
<span id="L2088" class="ln">  2088	</span>
<span id="L2089" class="ln">  2089	</span>func http2contextWithCancel(ctx http2contextContext) (_ http2contextContext, cancel func()) {
<span id="L2090" class="ln">  2090	</span>	return context.WithCancel(ctx)
<span id="L2091" class="ln">  2091	</span>}
<span id="L2092" class="ln">  2092	</span>
<span id="L2093" class="ln">  2093	</span>func http2requestWithContext(req *Request, ctx http2contextContext) *Request {
<span id="L2094" class="ln">  2094	</span>	return req.WithContext(ctx)
<span id="L2095" class="ln">  2095	</span>}
<span id="L2096" class="ln">  2096	</span>
<span id="L2097" class="ln">  2097	</span>type http2clientTrace httptrace.ClientTrace
<span id="L2098" class="ln">  2098	</span>
<span id="L2099" class="ln">  2099	</span>func http2reqContext(r *Request) context.Context { return r.Context() }
<span id="L2100" class="ln">  2100	</span>
<span id="L2101" class="ln">  2101	</span>func (t *http2Transport) idleConnTimeout() time.Duration {
<span id="L2102" class="ln">  2102	</span>	if t.t1 != nil {
<span id="L2103" class="ln">  2103	</span>		return t.t1.IdleConnTimeout
<span id="L2104" class="ln">  2104	</span>	}
<span id="L2105" class="ln">  2105	</span>	return 0
<span id="L2106" class="ln">  2106	</span>}
<span id="L2107" class="ln">  2107	</span>
<span id="L2108" class="ln">  2108	</span>func http2setResponseUncompressed(res *Response) { res.Uncompressed = true }
<span id="L2109" class="ln">  2109	</span>
<span id="L2110" class="ln">  2110	</span>func http2traceGotConn(req *Request, cc *http2ClientConn) {
<span id="L2111" class="ln">  2111	</span>	trace := httptrace.ContextClientTrace(req.Context())
<span id="L2112" class="ln">  2112	</span>	if trace == nil || trace.GotConn == nil {
<span id="L2113" class="ln">  2113	</span>		return
<span id="L2114" class="ln">  2114	</span>	}
<span id="L2115" class="ln">  2115	</span>	ci := httptrace.GotConnInfo{Conn: cc.tconn}
<span id="L2116" class="ln">  2116	</span>	cc.mu.Lock()
<span id="L2117" class="ln">  2117	</span>	ci.Reused = cc.nextStreamID &gt; 1
<span id="L2118" class="ln">  2118	</span>	ci.WasIdle = len(cc.streams) == 0 &amp;&amp; ci.Reused
<span id="L2119" class="ln">  2119	</span>	if ci.WasIdle &amp;&amp; !cc.lastActive.IsZero() {
<span id="L2120" class="ln">  2120	</span>		ci.IdleTime = time.Now().Sub(cc.lastActive)
<span id="L2121" class="ln">  2121	</span>	}
<span id="L2122" class="ln">  2122	</span>	cc.mu.Unlock()
<span id="L2123" class="ln">  2123	</span>
<span id="L2124" class="ln">  2124	</span>	trace.GotConn(ci)
<span id="L2125" class="ln">  2125	</span>}
<span id="L2126" class="ln">  2126	</span>
<span id="L2127" class="ln">  2127	</span>func http2traceWroteHeaders(trace *http2clientTrace) {
<span id="L2128" class="ln">  2128	</span>	if trace != nil &amp;&amp; trace.WroteHeaders != nil {
<span id="L2129" class="ln">  2129	</span>		trace.WroteHeaders()
<span id="L2130" class="ln">  2130	</span>	}
<span id="L2131" class="ln">  2131	</span>}
<span id="L2132" class="ln">  2132	</span>
<span id="L2133" class="ln">  2133	</span>func http2traceGot100Continue(trace *http2clientTrace) {
<span id="L2134" class="ln">  2134	</span>	if trace != nil &amp;&amp; trace.Got100Continue != nil {
<span id="L2135" class="ln">  2135	</span>		trace.Got100Continue()
<span id="L2136" class="ln">  2136	</span>	}
<span id="L2137" class="ln">  2137	</span>}
<span id="L2138" class="ln">  2138	</span>
<span id="L2139" class="ln">  2139	</span>func http2traceWait100Continue(trace *http2clientTrace) {
<span id="L2140" class="ln">  2140	</span>	if trace != nil &amp;&amp; trace.Wait100Continue != nil {
<span id="L2141" class="ln">  2141	</span>		trace.Wait100Continue()
<span id="L2142" class="ln">  2142	</span>	}
<span id="L2143" class="ln">  2143	</span>}
<span id="L2144" class="ln">  2144	</span>
<span id="L2145" class="ln">  2145	</span>func http2traceWroteRequest(trace *http2clientTrace, err error) {
<span id="L2146" class="ln">  2146	</span>	if trace != nil &amp;&amp; trace.WroteRequest != nil {
<span id="L2147" class="ln">  2147	</span>		trace.WroteRequest(httptrace.WroteRequestInfo{Err: err})
<span id="L2148" class="ln">  2148	</span>	}
<span id="L2149" class="ln">  2149	</span>}
<span id="L2150" class="ln">  2150	</span>
<span id="L2151" class="ln">  2151	</span>func http2traceFirstResponseByte(trace *http2clientTrace) {
<span id="L2152" class="ln">  2152	</span>	if trace != nil &amp;&amp; trace.GotFirstResponseByte != nil {
<span id="L2153" class="ln">  2153	</span>		trace.GotFirstResponseByte()
<span id="L2154" class="ln">  2154	</span>	}
<span id="L2155" class="ln">  2155	</span>}
<span id="L2156" class="ln">  2156	</span>
<span id="L2157" class="ln">  2157	</span>func http2requestTrace(req *Request) *http2clientTrace {
<span id="L2158" class="ln">  2158	</span>	trace := httptrace.ContextClientTrace(req.Context())
<span id="L2159" class="ln">  2159	</span>	return (*http2clientTrace)(trace)
<span id="L2160" class="ln">  2160	</span>}
<span id="L2161" class="ln">  2161	</span>
<span id="L2162" class="ln">  2162	</span><span class="comment">// Ping sends a PING frame to the server and waits for the ack.</span>
<span id="L2163" class="ln">  2163	</span>func (cc *http2ClientConn) Ping(ctx context.Context) error {
<span id="L2164" class="ln">  2164	</span>	return cc.ping(ctx)
<span id="L2165" class="ln">  2165	</span>}
<span id="L2166" class="ln">  2166	</span>
<span id="L2167" class="ln">  2167	</span>func http2cloneTLSConfig(c *tls.Config) *tls.Config { return c.Clone() }
<span id="L2168" class="ln">  2168	</span>
<span id="L2169" class="ln">  2169	</span>var _ Pusher = (*http2responseWriter)(nil)
<span id="L2170" class="ln">  2170	</span>
<span id="L2171" class="ln">  2171	</span><span class="comment">// Push implements http.Pusher.</span>
<span id="L2172" class="ln">  2172	</span>func (w *http2responseWriter) Push(target string, opts *PushOptions) error {
<span id="L2173" class="ln">  2173	</span>	internalOpts := http2pushOptions{}
<span id="L2174" class="ln">  2174	</span>	if opts != nil {
<span id="L2175" class="ln">  2175	</span>		internalOpts.Method = opts.Method
<span id="L2176" class="ln">  2176	</span>		internalOpts.Header = opts.Header
<span id="L2177" class="ln">  2177	</span>	}
<span id="L2178" class="ln">  2178	</span>	return w.push(target, internalOpts)
<span id="L2179" class="ln">  2179	</span>}
<span id="L2180" class="ln">  2180	</span>
<span id="L2181" class="ln">  2181	</span>func http2configureServer18(h1 *Server, h2 *http2Server) error {
<span id="L2182" class="ln">  2182	</span>	if h2.IdleTimeout == 0 {
<span id="L2183" class="ln">  2183	</span>		if h1.IdleTimeout != 0 {
<span id="L2184" class="ln">  2184	</span>			h2.IdleTimeout = h1.IdleTimeout
<span id="L2185" class="ln">  2185	</span>		} else {
<span id="L2186" class="ln">  2186	</span>			h2.IdleTimeout = h1.ReadTimeout
<span id="L2187" class="ln">  2187	</span>		}
<span id="L2188" class="ln">  2188	</span>	}
<span id="L2189" class="ln">  2189	</span>	return nil
<span id="L2190" class="ln">  2190	</span>}
<span id="L2191" class="ln">  2191	</span>
<span id="L2192" class="ln">  2192	</span>func http2shouldLogPanic(panicValue interface{}) bool {
<span id="L2193" class="ln">  2193	</span>	return panicValue != nil &amp;&amp; panicValue != ErrAbortHandler
<span id="L2194" class="ln">  2194	</span>}
<span id="L2195" class="ln">  2195	</span>
<span id="L2196" class="ln">  2196	</span>func http2reqGetBody(req *Request) func() (io.ReadCloser, error) {
<span id="L2197" class="ln">  2197	</span>	return req.GetBody
<span id="L2198" class="ln">  2198	</span>}
<span id="L2199" class="ln">  2199	</span>
<span id="L2200" class="ln">  2200	</span>func http2reqBodyIsNoBody(body io.ReadCloser) bool {
<span id="L2201" class="ln">  2201	</span>	return body == NoBody
<span id="L2202" class="ln">  2202	</span>}
<span id="L2203" class="ln">  2203	</span>
<span id="L2204" class="ln">  2204	</span>var http2DebugGoroutines = os.Getenv(&#34;DEBUG_HTTP2_GOROUTINES&#34;) == &#34;1&#34;
<span id="L2205" class="ln">  2205	</span>
<span id="L2206" class="ln">  2206	</span>type http2goroutineLock uint64
<span id="L2207" class="ln">  2207	</span>
<span id="L2208" class="ln">  2208	</span>func http2newGoroutineLock() http2goroutineLock {
<span id="L2209" class="ln">  2209	</span>	if !http2DebugGoroutines {
<span id="L2210" class="ln">  2210	</span>		return 0
<span id="L2211" class="ln">  2211	</span>	}
<span id="L2212" class="ln">  2212	</span>	return http2goroutineLock(http2curGoroutineID())
<span id="L2213" class="ln">  2213	</span>}
<span id="L2214" class="ln">  2214	</span>
<span id="L2215" class="ln">  2215	</span>func (g http2goroutineLock) check() {
<span id="L2216" class="ln">  2216	</span>	if !http2DebugGoroutines {
<span id="L2217" class="ln">  2217	</span>		return
<span id="L2218" class="ln">  2218	</span>	}
<span id="L2219" class="ln">  2219	</span>	if http2curGoroutineID() != uint64(g) {
<span id="L2220" class="ln">  2220	</span>		panic(&#34;running on the wrong goroutine&#34;)
<span id="L2221" class="ln">  2221	</span>	}
<span id="L2222" class="ln">  2222	</span>}
<span id="L2223" class="ln">  2223	</span>
<span id="L2224" class="ln">  2224	</span>func (g http2goroutineLock) checkNotOn() {
<span id="L2225" class="ln">  2225	</span>	if !http2DebugGoroutines {
<span id="L2226" class="ln">  2226	</span>		return
<span id="L2227" class="ln">  2227	</span>	}
<span id="L2228" class="ln">  2228	</span>	if http2curGoroutineID() == uint64(g) {
<span id="L2229" class="ln">  2229	</span>		panic(&#34;running on the wrong goroutine&#34;)
<span id="L2230" class="ln">  2230	</span>	}
<span id="L2231" class="ln">  2231	</span>}
<span id="L2232" class="ln">  2232	</span>
<span id="L2233" class="ln">  2233	</span>var http2goroutineSpace = []byte(&#34;goroutine &#34;)
<span id="L2234" class="ln">  2234	</span>
<span id="L2235" class="ln">  2235	</span>func http2curGoroutineID() uint64 {
<span id="L2236" class="ln">  2236	</span>	bp := http2littleBuf.Get().(*[]byte)
<span id="L2237" class="ln">  2237	</span>	defer http2littleBuf.Put(bp)
<span id="L2238" class="ln">  2238	</span>	b := *bp
<span id="L2239" class="ln">  2239	</span>	b = b[:runtime.Stack(b, false)]
<span id="L2240" class="ln">  2240	</span>
<span id="L2241" class="ln">  2241	</span>	b = bytes.TrimPrefix(b, http2goroutineSpace)
<span id="L2242" class="ln">  2242	</span>	i := bytes.IndexByte(b, &#39; &#39;)
<span id="L2243" class="ln">  2243	</span>	if i &lt; 0 {
<span id="L2244" class="ln">  2244	</span>		panic(fmt.Sprintf(&#34;No space found in %q&#34;, b))
<span id="L2245" class="ln">  2245	</span>	}
<span id="L2246" class="ln">  2246	</span>	b = b[:i]
<span id="L2247" class="ln">  2247	</span>	n, err := http2parseUintBytes(b, 10, 64)
<span id="L2248" class="ln">  2248	</span>	if err != nil {
<span id="L2249" class="ln">  2249	</span>		panic(fmt.Sprintf(&#34;Failed to parse goroutine ID out of %q: %v&#34;, b, err))
<span id="L2250" class="ln">  2250	</span>	}
<span id="L2251" class="ln">  2251	</span>	return n
<span id="L2252" class="ln">  2252	</span>}
<span id="L2253" class="ln">  2253	</span>
<span id="L2254" class="ln">  2254	</span>var http2littleBuf = sync.Pool{
<span id="L2255" class="ln">  2255	</span>	New: func() interface{} {
<span id="L2256" class="ln">  2256	</span>		buf := make([]byte, 64)
<span id="L2257" class="ln">  2257	</span>		return &amp;buf
<span id="L2258" class="ln">  2258	</span>	},
<span id="L2259" class="ln">  2259	</span>}
<span id="L2260" class="ln">  2260	</span>
<span id="L2261" class="ln">  2261	</span><span class="comment">// parseUintBytes is like strconv.ParseUint, but using a []byte.</span>
<span id="L2262" class="ln">  2262	</span>func http2parseUintBytes(s []byte, base int, bitSize int) (n uint64, err error) {
<span id="L2263" class="ln">  2263	</span>	var cutoff, maxVal uint64
<span id="L2264" class="ln">  2264	</span>
<span id="L2265" class="ln">  2265	</span>	if bitSize == 0 {
<span id="L2266" class="ln">  2266	</span>		bitSize = int(strconv.IntSize)
<span id="L2267" class="ln">  2267	</span>	}
<span id="L2268" class="ln">  2268	</span>
<span id="L2269" class="ln">  2269	</span>	s0 := s
<span id="L2270" class="ln">  2270	</span>	switch {
<span id="L2271" class="ln">  2271	</span>	case len(s) &lt; 1:
<span id="L2272" class="ln">  2272	</span>		err = strconv.ErrSyntax
<span id="L2273" class="ln">  2273	</span>		goto Error
<span id="L2274" class="ln">  2274	</span>
<span id="L2275" class="ln">  2275	</span>	case 2 &lt;= base &amp;&amp; base &lt;= 36:
<span id="L2276" class="ln">  2276	</span>
<span id="L2277" class="ln">  2277	</span>	case base == 0:
<span id="L2278" class="ln">  2278	</span>
<span id="L2279" class="ln">  2279	</span>		switch {
<span id="L2280" class="ln">  2280	</span>		case s[0] == &#39;0&#39; &amp;&amp; len(s) &gt; 1 &amp;&amp; (s[1] == &#39;x&#39; || s[1] == &#39;X&#39;):
<span id="L2281" class="ln">  2281	</span>			base = 16
<span id="L2282" class="ln">  2282	</span>			s = s[2:]
<span id="L2283" class="ln">  2283	</span>			if len(s) &lt; 1 {
<span id="L2284" class="ln">  2284	</span>				err = strconv.ErrSyntax
<span id="L2285" class="ln">  2285	</span>				goto Error
<span id="L2286" class="ln">  2286	</span>			}
<span id="L2287" class="ln">  2287	</span>		case s[0] == &#39;0&#39;:
<span id="L2288" class="ln">  2288	</span>			base = 8
<span id="L2289" class="ln">  2289	</span>		default:
<span id="L2290" class="ln">  2290	</span>			base = 10
<span id="L2291" class="ln">  2291	</span>		}
<span id="L2292" class="ln">  2292	</span>
<span id="L2293" class="ln">  2293	</span>	default:
<span id="L2294" class="ln">  2294	</span>		err = errors.New(&#34;invalid base &#34; + strconv.Itoa(base))
<span id="L2295" class="ln">  2295	</span>		goto Error
<span id="L2296" class="ln">  2296	</span>	}
<span id="L2297" class="ln">  2297	</span>
<span id="L2298" class="ln">  2298	</span>	n = 0
<span id="L2299" class="ln">  2299	</span>	cutoff = http2cutoff64(base)
<span id="L2300" class="ln">  2300	</span>	maxVal = 1&lt;&lt;uint(bitSize) - 1
<span id="L2301" class="ln">  2301	</span>
<span id="L2302" class="ln">  2302	</span>	for i := 0; i &lt; len(s); i++ {
<span id="L2303" class="ln">  2303	</span>		var v byte
<span id="L2304" class="ln">  2304	</span>		d := s[i]
<span id="L2305" class="ln">  2305	</span>		switch {
<span id="L2306" class="ln">  2306	</span>		case &#39;0&#39; &lt;= d &amp;&amp; d &lt;= &#39;9&#39;:
<span id="L2307" class="ln">  2307	</span>			v = d - &#39;0&#39;
<span id="L2308" class="ln">  2308	</span>		case &#39;a&#39; &lt;= d &amp;&amp; d &lt;= &#39;z&#39;:
<span id="L2309" class="ln">  2309	</span>			v = d - &#39;a&#39; + 10
<span id="L2310" class="ln">  2310	</span>		case &#39;A&#39; &lt;= d &amp;&amp; d &lt;= &#39;Z&#39;:
<span id="L2311" class="ln">  2311	</span>			v = d - &#39;A&#39; + 10
<span id="L2312" class="ln">  2312	</span>		default:
<span id="L2313" class="ln">  2313	</span>			n = 0
<span id="L2314" class="ln">  2314	</span>			err = strconv.ErrSyntax
<span id="L2315" class="ln">  2315	</span>			goto Error
<span id="L2316" class="ln">  2316	</span>		}
<span id="L2317" class="ln">  2317	</span>		if int(v) &gt;= base {
<span id="L2318" class="ln">  2318	</span>			n = 0
<span id="L2319" class="ln">  2319	</span>			err = strconv.ErrSyntax
<span id="L2320" class="ln">  2320	</span>			goto Error
<span id="L2321" class="ln">  2321	</span>		}
<span id="L2322" class="ln">  2322	</span>
<span id="L2323" class="ln">  2323	</span>		if n &gt;= cutoff {
<span id="L2324" class="ln">  2324	</span>
<span id="L2325" class="ln">  2325	</span>			n = 1&lt;&lt;64 - 1
<span id="L2326" class="ln">  2326	</span>			err = strconv.ErrRange
<span id="L2327" class="ln">  2327	</span>			goto Error
<span id="L2328" class="ln">  2328	</span>		}
<span id="L2329" class="ln">  2329	</span>		n *= uint64(base)
<span id="L2330" class="ln">  2330	</span>
<span id="L2331" class="ln">  2331	</span>		n1 := n + uint64(v)
<span id="L2332" class="ln">  2332	</span>		if n1 &lt; n || n1 &gt; maxVal {
<span id="L2333" class="ln">  2333	</span>
<span id="L2334" class="ln">  2334	</span>			n = 1&lt;&lt;64 - 1
<span id="L2335" class="ln">  2335	</span>			err = strconv.ErrRange
<span id="L2336" class="ln">  2336	</span>			goto Error
<span id="L2337" class="ln">  2337	</span>		}
<span id="L2338" class="ln">  2338	</span>		n = n1
<span id="L2339" class="ln">  2339	</span>	}
<span id="L2340" class="ln">  2340	</span>
<span id="L2341" class="ln">  2341	</span>	return n, nil
<span id="L2342" class="ln">  2342	</span>
<span id="L2343" class="ln">  2343	</span>Error:
<span id="L2344" class="ln">  2344	</span>	return n, &amp;strconv.NumError{Func: &#34;ParseUint&#34;, Num: string(s0), Err: err}
<span id="L2345" class="ln">  2345	</span>}
<span id="L2346" class="ln">  2346	</span>
<span id="L2347" class="ln">  2347	</span><span class="comment">// Return the first number n such that n*base &gt;= 1&lt;&lt;64.</span>
<span id="L2348" class="ln">  2348	</span>func http2cutoff64(base int) uint64 {
<span id="L2349" class="ln">  2349	</span>	if base &lt; 2 {
<span id="L2350" class="ln">  2350	</span>		return 0
<span id="L2351" class="ln">  2351	</span>	}
<span id="L2352" class="ln">  2352	</span>	return (1&lt;&lt;64-1)/uint64(base) + 1
<span id="L2353" class="ln">  2353	</span>}
<span id="L2354" class="ln">  2354	</span>
<span id="L2355" class="ln">  2355	</span>var (
<span id="L2356" class="ln">  2356	</span>	http2commonLowerHeader = map[string]string{} <span class="comment">// Go-Canonical-Case -&gt; lower-case</span>
<span id="L2357" class="ln">  2357	</span>	http2commonCanonHeader = map[string]string{} <span class="comment">// lower-case -&gt; Go-Canonical-Case</span>
<span id="L2358" class="ln">  2358	</span>)
<span id="L2359" class="ln">  2359	</span>
<span id="L2360" class="ln">  2360	</span>func init() {
<span id="L2361" class="ln">  2361	</span>	for _, v := range []string{
<span id="L2362" class="ln">  2362	</span>		&#34;accept&#34;,
<span id="L2363" class="ln">  2363	</span>		&#34;accept-charset&#34;,
<span id="L2364" class="ln">  2364	</span>		&#34;accept-encoding&#34;,
<span id="L2365" class="ln">  2365	</span>		&#34;accept-language&#34;,
<span id="L2366" class="ln">  2366	</span>		&#34;accept-ranges&#34;,
<span id="L2367" class="ln">  2367	</span>		&#34;age&#34;,
<span id="L2368" class="ln">  2368	</span>		&#34;access-control-allow-origin&#34;,
<span id="L2369" class="ln">  2369	</span>		&#34;allow&#34;,
<span id="L2370" class="ln">  2370	</span>		&#34;authorization&#34;,
<span id="L2371" class="ln">  2371	</span>		&#34;cache-control&#34;,
<span id="L2372" class="ln">  2372	</span>		&#34;content-disposition&#34;,
<span id="L2373" class="ln">  2373	</span>		&#34;content-encoding&#34;,
<span id="L2374" class="ln">  2374	</span>		&#34;content-language&#34;,
<span id="L2375" class="ln">  2375	</span>		&#34;content-length&#34;,
<span id="L2376" class="ln">  2376	</span>		&#34;content-location&#34;,
<span id="L2377" class="ln">  2377	</span>		&#34;content-range&#34;,
<span id="L2378" class="ln">  2378	</span>		&#34;content-type&#34;,
<span id="L2379" class="ln">  2379	</span>		&#34;cookie&#34;,
<span id="L2380" class="ln">  2380	</span>		&#34;date&#34;,
<span id="L2381" class="ln">  2381	</span>		&#34;etag&#34;,
<span id="L2382" class="ln">  2382	</span>		&#34;expect&#34;,
<span id="L2383" class="ln">  2383	</span>		&#34;expires&#34;,
<span id="L2384" class="ln">  2384	</span>		&#34;from&#34;,
<span id="L2385" class="ln">  2385	</span>		&#34;host&#34;,
<span id="L2386" class="ln">  2386	</span>		&#34;if-match&#34;,
<span id="L2387" class="ln">  2387	</span>		&#34;if-modified-since&#34;,
<span id="L2388" class="ln">  2388	</span>		&#34;if-none-match&#34;,
<span id="L2389" class="ln">  2389	</span>		&#34;if-unmodified-since&#34;,
<span id="L2390" class="ln">  2390	</span>		&#34;last-modified&#34;,
<span id="L2391" class="ln">  2391	</span>		&#34;link&#34;,
<span id="L2392" class="ln">  2392	</span>		&#34;location&#34;,
<span id="L2393" class="ln">  2393	</span>		&#34;max-forwards&#34;,
<span id="L2394" class="ln">  2394	</span>		&#34;proxy-authenticate&#34;,
<span id="L2395" class="ln">  2395	</span>		&#34;proxy-authorization&#34;,
<span id="L2396" class="ln">  2396	</span>		&#34;range&#34;,
<span id="L2397" class="ln">  2397	</span>		&#34;referer&#34;,
<span id="L2398" class="ln">  2398	</span>		&#34;refresh&#34;,
<span id="L2399" class="ln">  2399	</span>		&#34;retry-after&#34;,
<span id="L2400" class="ln">  2400	</span>		&#34;server&#34;,
<span id="L2401" class="ln">  2401	</span>		&#34;set-cookie&#34;,
<span id="L2402" class="ln">  2402	</span>		&#34;strict-transport-security&#34;,
<span id="L2403" class="ln">  2403	</span>		&#34;trailer&#34;,
<span id="L2404" class="ln">  2404	</span>		&#34;transfer-encoding&#34;,
<span id="L2405" class="ln">  2405	</span>		&#34;user-agent&#34;,
<span id="L2406" class="ln">  2406	</span>		&#34;vary&#34;,
<span id="L2407" class="ln">  2407	</span>		&#34;via&#34;,
<span id="L2408" class="ln">  2408	</span>		&#34;www-authenticate&#34;,
<span id="L2409" class="ln">  2409	</span>	} {
<span id="L2410" class="ln">  2410	</span>		chk := CanonicalHeaderKey(v)
<span id="L2411" class="ln">  2411	</span>		http2commonLowerHeader[chk] = v
<span id="L2412" class="ln">  2412	</span>		http2commonCanonHeader[v] = chk
<span id="L2413" class="ln">  2413	</span>	}
<span id="L2414" class="ln">  2414	</span>}
<span id="L2415" class="ln">  2415	</span>
<span id="L2416" class="ln">  2416	</span>func http2lowerHeader(v string) string {
<span id="L2417" class="ln">  2417	</span>	if s, ok := http2commonLowerHeader[v]; ok {
<span id="L2418" class="ln">  2418	</span>		return s
<span id="L2419" class="ln">  2419	</span>	}
<span id="L2420" class="ln">  2420	</span>	return strings.ToLower(v)
<span id="L2421" class="ln">  2421	</span>}
<span id="L2422" class="ln">  2422	</span>
<span id="L2423" class="ln">  2423	</span>var (
<span id="L2424" class="ln">  2424	</span>	http2VerboseLogs    bool
<span id="L2425" class="ln">  2425	</span>	http2logFrameWrites bool
<span id="L2426" class="ln">  2426	</span>	http2logFrameReads  bool
<span id="L2427" class="ln">  2427	</span>	http2inTests        bool
<span id="L2428" class="ln">  2428	</span>)
<span id="L2429" class="ln">  2429	</span>
<span id="L2430" class="ln">  2430	</span>func init() {
<span id="L2431" class="ln">  2431	</span>	e := os.Getenv(&#34;GODEBUG&#34;)
<span id="L2432" class="ln">  2432	</span>	if strings.Contains(e, &#34;http2debug=1&#34;) {
<span id="L2433" class="ln">  2433	</span>		http2VerboseLogs = true
<span id="L2434" class="ln">  2434	</span>	}
<span id="L2435" class="ln">  2435	</span>	if strings.Contains(e, &#34;http2debug=2&#34;) {
<span id="L2436" class="ln">  2436	</span>		http2VerboseLogs = true
<span id="L2437" class="ln">  2437	</span>		http2logFrameWrites = true
<span id="L2438" class="ln">  2438	</span>		http2logFrameReads = true
<span id="L2439" class="ln">  2439	</span>	}
<span id="L2440" class="ln">  2440	</span>}
<span id="L2441" class="ln">  2441	</span>
<span id="L2442" class="ln">  2442	</span>const (
<span id="L2443" class="ln">  2443	</span>	<span class="comment">// ClientPreface is the string that must be sent by new</span>
<span id="L2444" class="ln">  2444	</span>	<span class="comment">// connections from clients.</span>
<span id="L2445" class="ln">  2445	</span>	http2ClientPreface = &#34;PRI * HTTP/2.0\r\n\r\nSM\r\n\r\n&#34;
<span id="L2446" class="ln">  2446	</span>
<span id="L2447" class="ln">  2447	</span>	<span class="comment">// SETTINGS_MAX_FRAME_SIZE default</span>
<span id="L2448" class="ln">  2448	</span>	<span class="comment">// http://http2.github.io/http2-spec/#rfc.section.6.5.2</span>
<span id="L2449" class="ln">  2449	</span>	http2initialMaxFrameSize = 16384
<span id="L2450" class="ln">  2450	</span>
<span id="L2451" class="ln">  2451	</span>	<span class="comment">// NextProtoTLS is the NPN/ALPN protocol negotiated during</span>
<span id="L2452" class="ln">  2452	</span>	<span class="comment">// HTTP/2&#39;s TLS setup.</span>
<span id="L2453" class="ln">  2453	</span>	http2NextProtoTLS = &#34;h2&#34;
<span id="L2454" class="ln">  2454	</span>
<span id="L2455" class="ln">  2455	</span>	<span class="comment">// http://http2.github.io/http2-spec/#SettingValues</span>
<span id="L2456" class="ln">  2456	</span>	http2initialHeaderTableSize = 4096
<span id="L2457" class="ln">  2457	</span>
<span id="L2458" class="ln">  2458	</span>	http2initialWindowSize = 65535 <span class="comment">// 6.9.2 Initial Flow Control Window Size</span>
<span id="L2459" class="ln">  2459	</span>
<span id="L2460" class="ln">  2460	</span>	http2defaultMaxReadFrameSize = 1 &lt;&lt; 20
<span id="L2461" class="ln">  2461	</span>)
<span id="L2462" class="ln">  2462	</span>
<span id="L2463" class="ln">  2463	</span>var (
<span id="L2464" class="ln">  2464	</span>	http2clientPreface = []byte(http2ClientPreface)
<span id="L2465" class="ln">  2465	</span>)
<span id="L2466" class="ln">  2466	</span>
<span id="L2467" class="ln">  2467	</span>type http2streamState int
<span id="L2468" class="ln">  2468	</span>
<span id="L2469" class="ln">  2469	</span><span class="comment">// HTTP/2 stream states.</span>
<span id="L2470" class="ln">  2470	</span><span class="comment">//</span>
<span id="L2471" class="ln">  2471	</span><span class="comment">// See http://tools.ietf.org/html/rfc7540#section-5.1.</span>
<span id="L2472" class="ln">  2472	</span><span class="comment">//</span>
<span id="L2473" class="ln">  2473	</span><span class="comment">// For simplicity, the server code merges &#34;reserved (local)&#34; into</span>
<span id="L2474" class="ln">  2474	</span><span class="comment">// &#34;half-closed (remote)&#34;. This is one less state transition to track.</span>
<span id="L2475" class="ln">  2475	</span><span class="comment">// The only downside is that we send PUSH_PROMISEs slightly less</span>
<span id="L2476" class="ln">  2476	</span><span class="comment">// liberally than allowable. More discussion here:</span>
<span id="L2477" class="ln">  2477	</span><span class="comment">// https://lists.w3.org/Archives/Public/ietf-http-wg/2016JulSep/0599.html</span>
<span id="L2478" class="ln">  2478	</span><span class="comment">//</span>
<span id="L2479" class="ln">  2479	</span><span class="comment">// &#34;reserved (remote)&#34; is omitted since the client code does not</span>
<span id="L2480" class="ln">  2480	</span><span class="comment">// support server push.</span>
<span id="L2481" class="ln">  2481	</span>const (
<span id="L2482" class="ln">  2482	</span>	http2stateIdle http2streamState = iota
<span id="L2483" class="ln">  2483	</span>	http2stateOpen
<span id="L2484" class="ln">  2484	</span>	http2stateHalfClosedLocal
<span id="L2485" class="ln">  2485	</span>	http2stateHalfClosedRemote
<span id="L2486" class="ln">  2486	</span>	http2stateClosed
<span id="L2487" class="ln">  2487	</span>)
<span id="L2488" class="ln">  2488	</span>
<span id="L2489" class="ln">  2489	</span>var http2stateName = [...]string{
<span id="L2490" class="ln">  2490	</span>	http2stateIdle:             &#34;Idle&#34;,
<span id="L2491" class="ln">  2491	</span>	http2stateOpen:             &#34;Open&#34;,
<span id="L2492" class="ln">  2492	</span>	http2stateHalfClosedLocal:  &#34;HalfClosedLocal&#34;,
<span id="L2493" class="ln">  2493	</span>	http2stateHalfClosedRemote: &#34;HalfClosedRemote&#34;,
<span id="L2494" class="ln">  2494	</span>	http2stateClosed:           &#34;Closed&#34;,
<span id="L2495" class="ln">  2495	</span>}
<span id="L2496" class="ln">  2496	</span>
<span id="L2497" class="ln">  2497	</span>func (st http2streamState) String() string {
<span id="L2498" class="ln">  2498	</span>	return http2stateName[st]
<span id="L2499" class="ln">  2499	</span>}
<span id="L2500" class="ln">  2500	</span>
<span id="L2501" class="ln">  2501	</span><span class="comment">// Setting is a setting parameter: which setting it is, and its value.</span>
<span id="L2502" class="ln">  2502	</span>type http2Setting struct {
<span id="L2503" class="ln">  2503	</span>	<span class="comment">// ID is which setting is being set.</span>
<span id="L2504" class="ln">  2504	</span>	<span class="comment">// See http://http2.github.io/http2-spec/#SettingValues</span>
<span id="L2505" class="ln">  2505	</span>	ID http2SettingID
<span id="L2506" class="ln">  2506	</span>
<span id="L2507" class="ln">  2507	</span>	<span class="comment">// Val is the value.</span>
<span id="L2508" class="ln">  2508	</span>	Val uint32
<span id="L2509" class="ln">  2509	</span>}
<span id="L2510" class="ln">  2510	</span>
<span id="L2511" class="ln">  2511	</span>func (s http2Setting) String() string {
<span id="L2512" class="ln">  2512	</span>	return fmt.Sprintf(&#34;[%v = %d]&#34;, s.ID, s.Val)
<span id="L2513" class="ln">  2513	</span>}
<span id="L2514" class="ln">  2514	</span>
<span id="L2515" class="ln">  2515	</span><span class="comment">// Valid reports whether the setting is valid.</span>
<span id="L2516" class="ln">  2516	</span>func (s http2Setting) Valid() error {
<span id="L2517" class="ln">  2517	</span>
<span id="L2518" class="ln">  2518	</span>	switch s.ID {
<span id="L2519" class="ln">  2519	</span>	case http2SettingEnablePush:
<span id="L2520" class="ln">  2520	</span>		if s.Val != 1 &amp;&amp; s.Val != 0 {
<span id="L2521" class="ln">  2521	</span>			return http2ConnectionError(http2ErrCodeProtocol)
<span id="L2522" class="ln">  2522	</span>		}
<span id="L2523" class="ln">  2523	</span>	case http2SettingInitialWindowSize:
<span id="L2524" class="ln">  2524	</span>		if s.Val &gt; 1&lt;&lt;31-1 {
<span id="L2525" class="ln">  2525	</span>			return http2ConnectionError(http2ErrCodeFlowControl)
<span id="L2526" class="ln">  2526	</span>		}
<span id="L2527" class="ln">  2527	</span>	case http2SettingMaxFrameSize:
<span id="L2528" class="ln">  2528	</span>		if s.Val &lt; 16384 || s.Val &gt; 1&lt;&lt;24-1 {
<span id="L2529" class="ln">  2529	</span>			return http2ConnectionError(http2ErrCodeProtocol)
<span id="L2530" class="ln">  2530	</span>		}
<span id="L2531" class="ln">  2531	</span>	}
<span id="L2532" class="ln">  2532	</span>	return nil
<span id="L2533" class="ln">  2533	</span>}
<span id="L2534" class="ln">  2534	</span>
<span id="L2535" class="ln">  2535	</span><span class="comment">// A SettingID is an HTTP/2 setting as defined in</span>
<span id="L2536" class="ln">  2536	</span><span class="comment">// http://http2.github.io/http2-spec/#iana-settings</span>
<span id="L2537" class="ln">  2537	</span>type http2SettingID uint16
<span id="L2538" class="ln">  2538	</span>
<span id="L2539" class="ln">  2539	</span>const (
<span id="L2540" class="ln">  2540	</span>	http2SettingHeaderTableSize      http2SettingID = 0x1
<span id="L2541" class="ln">  2541	</span>	http2SettingEnablePush           http2SettingID = 0x2
<span id="L2542" class="ln">  2542	</span>	http2SettingMaxConcurrentStreams http2SettingID = 0x3
<span id="L2543" class="ln">  2543	</span>	http2SettingInitialWindowSize    http2SettingID = 0x4
<span id="L2544" class="ln">  2544	</span>	http2SettingMaxFrameSize         http2SettingID = 0x5
<span id="L2545" class="ln">  2545	</span>	http2SettingMaxHeaderListSize    http2SettingID = 0x6
<span id="L2546" class="ln">  2546	</span>)
<span id="L2547" class="ln">  2547	</span>
<span id="L2548" class="ln">  2548	</span>var http2settingName = map[http2SettingID]string{
<span id="L2549" class="ln">  2549	</span>	http2SettingHeaderTableSize:      &#34;HEADER_TABLE_SIZE&#34;,
<span id="L2550" class="ln">  2550	</span>	http2SettingEnablePush:           &#34;ENABLE_PUSH&#34;,
<span id="L2551" class="ln">  2551	</span>	http2SettingMaxConcurrentStreams: &#34;MAX_CONCURRENT_STREAMS&#34;,
<span id="L2552" class="ln">  2552	</span>	http2SettingInitialWindowSize:    &#34;INITIAL_WINDOW_SIZE&#34;,
<span id="L2553" class="ln">  2553	</span>	http2SettingMaxFrameSize:         &#34;MAX_FRAME_SIZE&#34;,
<span id="L2554" class="ln">  2554	</span>	http2SettingMaxHeaderListSize:    &#34;MAX_HEADER_LIST_SIZE&#34;,
<span id="L2555" class="ln">  2555	</span>}
<span id="L2556" class="ln">  2556	</span>
<span id="L2557" class="ln">  2557	</span>func (s http2SettingID) String() string {
<span id="L2558" class="ln">  2558	</span>	if v, ok := http2settingName[s]; ok {
<span id="L2559" class="ln">  2559	</span>		return v
<span id="L2560" class="ln">  2560	</span>	}
<span id="L2561" class="ln">  2561	</span>	return fmt.Sprintf(&#34;UNKNOWN_SETTING_%d&#34;, uint16(s))
<span id="L2562" class="ln">  2562	</span>}
<span id="L2563" class="ln">  2563	</span>
<span id="L2564" class="ln">  2564	</span>var (
<span id="L2565" class="ln">  2565	</span>	http2errInvalidHeaderFieldName  = errors.New(&#34;http2: invalid header field name&#34;)
<span id="L2566" class="ln">  2566	</span>	http2errInvalidHeaderFieldValue = errors.New(&#34;http2: invalid header field value&#34;)
<span id="L2567" class="ln">  2567	</span>)
<span id="L2568" class="ln">  2568	</span>
<span id="L2569" class="ln">  2569	</span><span class="comment">// validWireHeaderFieldName reports whether v is a valid header field</span>
<span id="L2570" class="ln">  2570	</span><span class="comment">// name (key). See httplex.ValidHeaderName for the base rules.</span>
<span id="L2571" class="ln">  2571	</span><span class="comment">//</span>
<span id="L2572" class="ln">  2572	</span><span class="comment">// Further, http2 says:</span>
<span id="L2573" class="ln">  2573	</span><span class="comment">//   &#34;Just as in HTTP/1.x, header field names are strings of ASCII</span>
<span id="L2574" class="ln">  2574	</span><span class="comment">//   characters that are compared in a case-insensitive</span>
<span id="L2575" class="ln">  2575	</span><span class="comment">//   fashion. However, header field names MUST be converted to</span>
<span id="L2576" class="ln">  2576	</span><span class="comment">//   lowercase prior to their encoding in HTTP/2. &#34;</span>
<span id="L2577" class="ln">  2577	</span>func http2validWireHeaderFieldName(v string) bool {
<span id="L2578" class="ln">  2578	</span>	if len(v) == 0 {
<span id="L2579" class="ln">  2579	</span>		return false
<span id="L2580" class="ln">  2580	</span>	}
<span id="L2581" class="ln">  2581	</span>	for _, r := range v {
<span id="L2582" class="ln">  2582	</span>		if !httplex.IsTokenRune(r) {
<span id="L2583" class="ln">  2583	</span>			return false
<span id="L2584" class="ln">  2584	</span>		}
<span id="L2585" class="ln">  2585	</span>		if &#39;A&#39; &lt;= r &amp;&amp; r &lt;= &#39;Z&#39; {
<span id="L2586" class="ln">  2586	</span>			return false
<span id="L2587" class="ln">  2587	</span>		}
<span id="L2588" class="ln">  2588	</span>	}
<span id="L2589" class="ln">  2589	</span>	return true
<span id="L2590" class="ln">  2590	</span>}
<span id="L2591" class="ln">  2591	</span>
<span id="L2592" class="ln">  2592	</span>var http2httpCodeStringCommon = map[int]string{} <span class="comment">// n -&gt; strconv.Itoa(n)</span>
<span id="L2593" class="ln">  2593	</span>
<span id="L2594" class="ln">  2594	</span>func init() {
<span id="L2595" class="ln">  2595	</span>	for i := 100; i &lt;= 999; i++ {
<span id="L2596" class="ln">  2596	</span>		if v := StatusText(i); v != &#34;&#34; {
<span id="L2597" class="ln">  2597	</span>			http2httpCodeStringCommon[i] = strconv.Itoa(i)
<span id="L2598" class="ln">  2598	</span>		}
<span id="L2599" class="ln">  2599	</span>	}
<span id="L2600" class="ln">  2600	</span>}
<span id="L2601" class="ln">  2601	</span>
<span id="L2602" class="ln">  2602	</span>func http2httpCodeString(code int) string {
<span id="L2603" class="ln">  2603	</span>	if s, ok := http2httpCodeStringCommon[code]; ok {
<span id="L2604" class="ln">  2604	</span>		return s
<span id="L2605" class="ln">  2605	</span>	}
<span id="L2606" class="ln">  2606	</span>	return strconv.Itoa(code)
<span id="L2607" class="ln">  2607	</span>}
<span id="L2608" class="ln">  2608	</span>
<span id="L2609" class="ln">  2609	</span><span class="comment">// from pkg io</span>
<span id="L2610" class="ln">  2610	</span>type http2stringWriter interface {
<span id="L2611" class="ln">  2611	</span>	WriteString(s string) (n int, err error)
<span id="L2612" class="ln">  2612	</span>}
<span id="L2613" class="ln">  2613	</span>
<span id="L2614" class="ln">  2614	</span><span class="comment">// A gate lets two goroutines coordinate their activities.</span>
<span id="L2615" class="ln">  2615	</span>type http2gate chan struct{}
<span id="L2616" class="ln">  2616	</span>
<span id="L2617" class="ln">  2617	</span>func (g http2gate) Done() { g &lt;- struct{}{} }
<span id="L2618" class="ln">  2618	</span>
<span id="L2619" class="ln">  2619	</span>func (g http2gate) Wait() { &lt;-g }
<span id="L2620" class="ln">  2620	</span>
<span id="L2621" class="ln">  2621	</span><span class="comment">// A closeWaiter is like a sync.WaitGroup but only goes 1 to 0 (open to closed).</span>
<span id="L2622" class="ln">  2622	</span>type http2closeWaiter chan struct{}
<span id="L2623" class="ln">  2623	</span>
<span id="L2624" class="ln">  2624	</span><span class="comment">// Init makes a closeWaiter usable.</span>
<span id="L2625" class="ln">  2625	</span><span class="comment">// It exists because so a closeWaiter value can be placed inside a</span>
<span id="L2626" class="ln">  2626	</span><span class="comment">// larger struct and have the Mutex and Cond&#39;s memory in the same</span>
<span id="L2627" class="ln">  2627	</span><span class="comment">// allocation.</span>
<span id="L2628" class="ln">  2628	</span>func (cw *http2closeWaiter) Init() {
<span id="L2629" class="ln">  2629	</span>	*cw = make(chan struct{})
<span id="L2630" class="ln">  2630	</span>}
<span id="L2631" class="ln">  2631	</span>
<span id="L2632" class="ln">  2632	</span><span class="comment">// Close marks the closeWaiter as closed and unblocks any waiters.</span>
<span id="L2633" class="ln">  2633	</span>func (cw http2closeWaiter) Close() {
<span id="L2634" class="ln">  2634	</span>	close(cw)
<span id="L2635" class="ln">  2635	</span>}
<span id="L2636" class="ln">  2636	</span>
<span id="L2637" class="ln">  2637	</span><span class="comment">// Wait waits for the closeWaiter to become closed.</span>
<span id="L2638" class="ln">  2638	</span>func (cw http2closeWaiter) Wait() {
<span id="L2639" class="ln">  2639	</span>	&lt;-cw
<span id="L2640" class="ln">  2640	</span>}
<span id="L2641" class="ln">  2641	</span>
<span id="L2642" class="ln">  2642	</span><span class="comment">// bufferedWriter is a buffered writer that writes to w.</span>
<span id="L2643" class="ln">  2643	</span><span class="comment">// Its buffered writer is lazily allocated as needed, to minimize</span>
<span id="L2644" class="ln">  2644	</span><span class="comment">// idle memory usage with many connections.</span>
<span id="L2645" class="ln">  2645	</span>type http2bufferedWriter struct {
<span id="L2646" class="ln">  2646	</span>	w  io.Writer     <span class="comment">// immutable</span>
<span id="L2647" class="ln">  2647	</span>	bw *bufio.Writer <span class="comment">// non-nil when data is buffered</span>
<span id="L2648" class="ln">  2648	</span>}
<span id="L2649" class="ln">  2649	</span>
<span id="L2650" class="ln">  2650	</span>func http2newBufferedWriter(w io.Writer) *http2bufferedWriter {
<span id="L2651" class="ln">  2651	</span>	return &amp;http2bufferedWriter{w: w}
<span id="L2652" class="ln">  2652	</span>}
<span id="L2653" class="ln">  2653	</span>
<span id="L2654" class="ln">  2654	</span><span class="comment">// bufWriterPoolBufferSize is the size of bufio.Writer&#39;s</span>
<span id="L2655" class="ln">  2655	</span><span class="comment">// buffers created using bufWriterPool.</span>
<span id="L2656" class="ln">  2656	</span><span class="comment">//</span>
<span id="L2657" class="ln">  2657	</span><span class="comment">// TODO: pick a less arbitrary value? this is a bit under</span>
<span id="L2658" class="ln">  2658	</span><span class="comment">// (3 x typical 1500 byte MTU) at least. Other than that,</span>
<span id="L2659" class="ln">  2659	</span><span class="comment">// not much thought went into it.</span>
<span id="L2660" class="ln">  2660	</span>const http2bufWriterPoolBufferSize = 4 &lt;&lt; 10
<span id="L2661" class="ln">  2661	</span>
<span id="L2662" class="ln">  2662	</span>var http2bufWriterPool = sync.Pool{
<span id="L2663" class="ln">  2663	</span>	New: func() interface{} {
<span id="L2664" class="ln">  2664	</span>		return bufio.NewWriterSize(nil, http2bufWriterPoolBufferSize)
<span id="L2665" class="ln">  2665	</span>	},
<span id="L2666" class="ln">  2666	</span>}
<span id="L2667" class="ln">  2667	</span>
<span id="L2668" class="ln">  2668	</span>func (w *http2bufferedWriter) Available() int {
<span id="L2669" class="ln">  2669	</span>	if w.bw == nil {
<span id="L2670" class="ln">  2670	</span>		return http2bufWriterPoolBufferSize
<span id="L2671" class="ln">  2671	</span>	}
<span id="L2672" class="ln">  2672	</span>	return w.bw.Available()
<span id="L2673" class="ln">  2673	</span>}
<span id="L2674" class="ln">  2674	</span>
<span id="L2675" class="ln">  2675	</span>func (w *http2bufferedWriter) Write(p []byte) (n int, err error) {
<span id="L2676" class="ln">  2676	</span>	if w.bw == nil {
<span id="L2677" class="ln">  2677	</span>		bw := http2bufWriterPool.Get().(*bufio.Writer)
<span id="L2678" class="ln">  2678	</span>		bw.Reset(w.w)
<span id="L2679" class="ln">  2679	</span>		w.bw = bw
<span id="L2680" class="ln">  2680	</span>	}
<span id="L2681" class="ln">  2681	</span>	return w.bw.Write(p)
<span id="L2682" class="ln">  2682	</span>}
<span id="L2683" class="ln">  2683	</span>
<span id="L2684" class="ln">  2684	</span>func (w *http2bufferedWriter) Flush() error {
<span id="L2685" class="ln">  2685	</span>	bw := w.bw
<span id="L2686" class="ln">  2686	</span>	if bw == nil {
<span id="L2687" class="ln">  2687	</span>		return nil
<span id="L2688" class="ln">  2688	</span>	}
<span id="L2689" class="ln">  2689	</span>	err := bw.Flush()
<span id="L2690" class="ln">  2690	</span>	bw.Reset(nil)
<span id="L2691" class="ln">  2691	</span>	http2bufWriterPool.Put(bw)
<span id="L2692" class="ln">  2692	</span>	w.bw = nil
<span id="L2693" class="ln">  2693	</span>	return err
<span id="L2694" class="ln">  2694	</span>}
<span id="L2695" class="ln">  2695	</span>
<span id="L2696" class="ln">  2696	</span>func http2mustUint31(v int32) uint32 {
<span id="L2697" class="ln">  2697	</span>	if v &lt; 0 || v &gt; 2147483647 {
<span id="L2698" class="ln">  2698	</span>		panic(&#34;out of range&#34;)
<span id="L2699" class="ln">  2699	</span>	}
<span id="L2700" class="ln">  2700	</span>	return uint32(v)
<span id="L2701" class="ln">  2701	</span>}
<span id="L2702" class="ln">  2702	</span>
<span id="L2703" class="ln">  2703	</span><span class="comment">// bodyAllowedForStatus reports whether a given response status code</span>
<span id="L2704" class="ln">  2704	</span><span class="comment">// permits a body. See RFC 2616, section 4.4.</span>
<span id="L2705" class="ln">  2705	</span>func http2bodyAllowedForStatus(status int) bool {
<span id="L2706" class="ln">  2706	</span>	switch {
<span id="L2707" class="ln">  2707	</span>	case status &gt;= 100 &amp;&amp; status &lt;= 199:
<span id="L2708" class="ln">  2708	</span>		return false
<span id="L2709" class="ln">  2709	</span>	case status == 204:
<span id="L2710" class="ln">  2710	</span>		return false
<span id="L2711" class="ln">  2711	</span>	case status == 304:
<span id="L2712" class="ln">  2712	</span>		return false
<span id="L2713" class="ln">  2713	</span>	}
<span id="L2714" class="ln">  2714	</span>	return true
<span id="L2715" class="ln">  2715	</span>}
<span id="L2716" class="ln">  2716	</span>
<span id="L2717" class="ln">  2717	</span>type http2httpError struct {
<span id="L2718" class="ln">  2718	</span>	msg     string
<span id="L2719" class="ln">  2719	</span>	timeout bool
<span id="L2720" class="ln">  2720	</span>}
<span id="L2721" class="ln">  2721	</span>
<span id="L2722" class="ln">  2722	</span>func (e *http2httpError) Error() string { return e.msg }
<span id="L2723" class="ln">  2723	</span>
<span id="L2724" class="ln">  2724	</span>func (e *http2httpError) Timeout() bool { return e.timeout }
<span id="L2725" class="ln">  2725	</span>
<span id="L2726" class="ln">  2726	</span>func (e *http2httpError) Temporary() bool { return true }
<span id="L2727" class="ln">  2727	</span>
<span id="L2728" class="ln">  2728	</span>var http2errTimeout error = &amp;http2httpError{msg: &#34;http2: timeout awaiting response headers&#34;, timeout: true}
<span id="L2729" class="ln">  2729	</span>
<span id="L2730" class="ln">  2730	</span>type http2connectionStater interface {
<span id="L2731" class="ln">  2731	</span>	ConnectionState() tls.ConnectionState
<span id="L2732" class="ln">  2732	</span>}
<span id="L2733" class="ln">  2733	</span>
<span id="L2734" class="ln">  2734	</span>var http2sorterPool = sync.Pool{New: func() interface{} { return new(http2sorter) }}
<span id="L2735" class="ln">  2735	</span>
<span id="L2736" class="ln">  2736	</span>type http2sorter struct {
<span id="L2737" class="ln">  2737	</span>	v []string <span class="comment">// owned by sorter</span>
<span id="L2738" class="ln">  2738	</span>}
<span id="L2739" class="ln">  2739	</span>
<span id="L2740" class="ln">  2740	</span>func (s *http2sorter) Len() int { return len(s.v) }
<span id="L2741" class="ln">  2741	</span>
<span id="L2742" class="ln">  2742	</span>func (s *http2sorter) Swap(i, j int) { s.v[i], s.v[j] = s.v[j], s.v[i] }
<span id="L2743" class="ln">  2743	</span>
<span id="L2744" class="ln">  2744	</span>func (s *http2sorter) Less(i, j int) bool { return s.v[i] &lt; s.v[j] }
<span id="L2745" class="ln">  2745	</span>
<span id="L2746" class="ln">  2746	</span><span class="comment">// Keys returns the sorted keys of h.</span>
<span id="L2747" class="ln">  2747	</span><span class="comment">//</span>
<span id="L2748" class="ln">  2748	</span><span class="comment">// The returned slice is only valid until s used again or returned to</span>
<span id="L2749" class="ln">  2749	</span><span class="comment">// its pool.</span>
<span id="L2750" class="ln">  2750	</span>func (s *http2sorter) Keys(h Header) []string {
<span id="L2751" class="ln">  2751	</span>	keys := s.v[:0]
<span id="L2752" class="ln">  2752	</span>	for k := range h {
<span id="L2753" class="ln">  2753	</span>		keys = append(keys, k)
<span id="L2754" class="ln">  2754	</span>	}
<span id="L2755" class="ln">  2755	</span>	s.v = keys
<span id="L2756" class="ln">  2756	</span>	sort.Sort(s)
<span id="L2757" class="ln">  2757	</span>	return keys
<span id="L2758" class="ln">  2758	</span>}
<span id="L2759" class="ln">  2759	</span>
<span id="L2760" class="ln">  2760	</span>func (s *http2sorter) SortStrings(ss []string) {
<span id="L2761" class="ln">  2761	</span>
<span id="L2762" class="ln">  2762	</span>	save := s.v
<span id="L2763" class="ln">  2763	</span>	s.v = ss
<span id="L2764" class="ln">  2764	</span>	sort.Sort(s)
<span id="L2765" class="ln">  2765	</span>	s.v = save
<span id="L2766" class="ln">  2766	</span>}
<span id="L2767" class="ln">  2767	</span>
<span id="L2768" class="ln">  2768	</span><span class="comment">// validPseudoPath reports whether v is a valid :path pseudo-header</span>
<span id="L2769" class="ln">  2769	</span><span class="comment">// value. It must be either:</span>
<span id="L2770" class="ln">  2770	</span><span class="comment">//</span>
<span id="L2771" class="ln">  2771	</span><span class="comment">//     *) a non-empty string starting with &#39;/&#39;, but not with with &#34;//&#34;,</span>
<span id="L2772" class="ln">  2772	</span><span class="comment">//     *) the string &#39;*&#39;, for OPTIONS requests.</span>
<span id="L2773" class="ln">  2773	</span><span class="comment">//</span>
<span id="L2774" class="ln">  2774	</span><span class="comment">// For now this is only used a quick check for deciding when to clean</span>
<span id="L2775" class="ln">  2775	</span><span class="comment">// up Opaque URLs before sending requests from the Transport.</span>
<span id="L2776" class="ln">  2776	</span><span class="comment">// See golang.org/issue/16847</span>
<span id="L2777" class="ln">  2777	</span>func http2validPseudoPath(v string) bool {
<span id="L2778" class="ln">  2778	</span>	return (len(v) &gt; 0 &amp;&amp; v[0] == &#39;/&#39; &amp;&amp; (len(v) == 1 || v[1] != &#39;/&#39;)) || v == &#34;*&#34;
<span id="L2779" class="ln">  2779	</span>}
<span id="L2780" class="ln">  2780	</span>
<span id="L2781" class="ln">  2781	</span><span class="comment">// pipe is a goroutine-safe io.Reader/io.Writer pair.  It&#39;s like</span>
<span id="L2782" class="ln">  2782	</span><span class="comment">// io.Pipe except there are no PipeReader/PipeWriter halves, and the</span>
<span id="L2783" class="ln">  2783	</span><span class="comment">// underlying buffer is an interface. (io.Pipe is always unbuffered)</span>
<span id="L2784" class="ln">  2784	</span>type http2pipe struct {
<span id="L2785" class="ln">  2785	</span>	mu       sync.Mutex
<span id="L2786" class="ln">  2786	</span>	c        sync.Cond <span class="comment">// c.L lazily initialized to &amp;p.mu</span>
<span id="L2787" class="ln">  2787	</span>	b        http2pipeBuffer
<span id="L2788" class="ln">  2788	</span>	err      error         <span class="comment">// read error once empty. non-nil means closed.</span>
<span id="L2789" class="ln">  2789	</span>	breakErr error         <span class="comment">// immediate read error (caller doesn&#39;t see rest of b)</span>
<span id="L2790" class="ln">  2790	</span>	donec    chan struct{} <span class="comment">// closed on error</span>
<span id="L2791" class="ln">  2791	</span>	readFn   func()        <span class="comment">// optional code to run in Read before error</span>
<span id="L2792" class="ln">  2792	</span>}
<span id="L2793" class="ln">  2793	</span>
<span id="L2794" class="ln">  2794	</span>type http2pipeBuffer interface {
<span id="L2795" class="ln">  2795	</span>	Len() int
<span id="L2796" class="ln">  2796	</span>	io.Writer
<span id="L2797" class="ln">  2797	</span>	io.Reader
<span id="L2798" class="ln">  2798	</span>}
<span id="L2799" class="ln">  2799	</span>
<span id="L2800" class="ln">  2800	</span>func (p *http2pipe) Len() int {
<span id="L2801" class="ln">  2801	</span>	p.mu.Lock()
<span id="L2802" class="ln">  2802	</span>	defer p.mu.Unlock()
<span id="L2803" class="ln">  2803	</span>	return p.b.Len()
<span id="L2804" class="ln">  2804	</span>}
<span id="L2805" class="ln">  2805	</span>
<span id="L2806" class="ln">  2806	</span><span class="comment">// Read waits until data is available and copies bytes</span>
<span id="L2807" class="ln">  2807	</span><span class="comment">// from the buffer into p.</span>
<span id="L2808" class="ln">  2808	</span>func (p *http2pipe) Read(d []byte) (n int, err error) {
<span id="L2809" class="ln">  2809	</span>	p.mu.Lock()
<span id="L2810" class="ln">  2810	</span>	defer p.mu.Unlock()
<span id="L2811" class="ln">  2811	</span>	if p.c.L == nil {
<span id="L2812" class="ln">  2812	</span>		p.c.L = &amp;p.mu
<span id="L2813" class="ln">  2813	</span>	}
<span id="L2814" class="ln">  2814	</span>	for {
<span id="L2815" class="ln">  2815	</span>		if p.breakErr != nil {
<span id="L2816" class="ln">  2816	</span>			return 0, p.breakErr
<span id="L2817" class="ln">  2817	</span>		}
<span id="L2818" class="ln">  2818	</span>		if p.b.Len() &gt; 0 {
<span id="L2819" class="ln">  2819	</span>			return p.b.Read(d)
<span id="L2820" class="ln">  2820	</span>		}
<span id="L2821" class="ln">  2821	</span>		if p.err != nil {
<span id="L2822" class="ln">  2822	</span>			if p.readFn != nil {
<span id="L2823" class="ln">  2823	</span>				p.readFn()
<span id="L2824" class="ln">  2824	</span>				p.readFn = nil
<span id="L2825" class="ln">  2825	</span>			}
<span id="L2826" class="ln">  2826	</span>			return 0, p.err
<span id="L2827" class="ln">  2827	</span>		}
<span id="L2828" class="ln">  2828	</span>		p.c.Wait()
<span id="L2829" class="ln">  2829	</span>	}
<span id="L2830" class="ln">  2830	</span>}
<span id="L2831" class="ln">  2831	</span>
<span id="L2832" class="ln">  2832	</span>var http2errClosedPipeWrite = errors.New(&#34;write on closed buffer&#34;)
<span id="L2833" class="ln">  2833	</span>
<span id="L2834" class="ln">  2834	</span><span class="comment">// Write copies bytes from p into the buffer and wakes a reader.</span>
<span id="L2835" class="ln">  2835	</span><span class="comment">// It is an error to write more data than the buffer can hold.</span>
<span id="L2836" class="ln">  2836	</span>func (p *http2pipe) Write(d []byte) (n int, err error) {
<span id="L2837" class="ln">  2837	</span>	p.mu.Lock()
<span id="L2838" class="ln">  2838	</span>	defer p.mu.Unlock()
<span id="L2839" class="ln">  2839	</span>	if p.c.L == nil {
<span id="L2840" class="ln">  2840	</span>		p.c.L = &amp;p.mu
<span id="L2841" class="ln">  2841	</span>	}
<span id="L2842" class="ln">  2842	</span>	defer p.c.Signal()
<span id="L2843" class="ln">  2843	</span>	if p.err != nil {
<span id="L2844" class="ln">  2844	</span>		return 0, http2errClosedPipeWrite
<span id="L2845" class="ln">  2845	</span>	}
<span id="L2846" class="ln">  2846	</span>	return p.b.Write(d)
<span id="L2847" class="ln">  2847	</span>}
<span id="L2848" class="ln">  2848	</span>
<span id="L2849" class="ln">  2849	</span><span class="comment">// CloseWithError causes the next Read (waking up a current blocked</span>
<span id="L2850" class="ln">  2850	</span><span class="comment">// Read if needed) to return the provided err after all data has been</span>
<span id="L2851" class="ln">  2851	</span><span class="comment">// read.</span>
<span id="L2852" class="ln">  2852	</span><span class="comment">//</span>
<span id="L2853" class="ln">  2853	</span><span class="comment">// The error must be non-nil.</span>
<span id="L2854" class="ln">  2854	</span>func (p *http2pipe) CloseWithError(err error) { p.closeWithError(&amp;p.err, err, nil) }
<span id="L2855" class="ln">  2855	</span>
<span id="L2856" class="ln">  2856	</span><span class="comment">// BreakWithError causes the next Read (waking up a current blocked</span>
<span id="L2857" class="ln">  2857	</span><span class="comment">// Read if needed) to return the provided err immediately, without</span>
<span id="L2858" class="ln">  2858	</span><span class="comment">// waiting for unread data.</span>
<span id="L2859" class="ln">  2859	</span>func (p *http2pipe) BreakWithError(err error) { p.closeWithError(&amp;p.breakErr, err, nil) }
<span id="L2860" class="ln">  2860	</span>
<span id="L2861" class="ln">  2861	</span><span class="comment">// closeWithErrorAndCode is like CloseWithError but also sets some code to run</span>
<span id="L2862" class="ln">  2862	</span><span class="comment">// in the caller&#39;s goroutine before returning the error.</span>
<span id="L2863" class="ln">  2863	</span>func (p *http2pipe) closeWithErrorAndCode(err error, fn func()) { p.closeWithError(&amp;p.err, err, fn) }
<span id="L2864" class="ln">  2864	</span>
<span id="L2865" class="ln">  2865	</span>func (p *http2pipe) closeWithError(dst *error, err error, fn func()) {
<span id="L2866" class="ln">  2866	</span>	if err == nil {
<span id="L2867" class="ln">  2867	</span>		panic(&#34;err must be non-nil&#34;)
<span id="L2868" class="ln">  2868	</span>	}
<span id="L2869" class="ln">  2869	</span>	p.mu.Lock()
<span id="L2870" class="ln">  2870	</span>	defer p.mu.Unlock()
<span id="L2871" class="ln">  2871	</span>	if p.c.L == nil {
<span id="L2872" class="ln">  2872	</span>		p.c.L = &amp;p.mu
<span id="L2873" class="ln">  2873	</span>	}
<span id="L2874" class="ln">  2874	</span>	defer p.c.Signal()
<span id="L2875" class="ln">  2875	</span>	if *dst != nil {
<span id="L2876" class="ln">  2876	</span>
<span id="L2877" class="ln">  2877	</span>		return
<span id="L2878" class="ln">  2878	</span>	}
<span id="L2879" class="ln">  2879	</span>	p.readFn = fn
<span id="L2880" class="ln">  2880	</span>	*dst = err
<span id="L2881" class="ln">  2881	</span>	p.closeDoneLocked()
<span id="L2882" class="ln">  2882	</span>}
<span id="L2883" class="ln">  2883	</span>
<span id="L2884" class="ln">  2884	</span><span class="comment">// requires p.mu be held.</span>
<span id="L2885" class="ln">  2885	</span>func (p *http2pipe) closeDoneLocked() {
<span id="L2886" class="ln">  2886	</span>	if p.donec == nil {
<span id="L2887" class="ln">  2887	</span>		return
<span id="L2888" class="ln">  2888	</span>	}
<span id="L2889" class="ln">  2889	</span>
<span id="L2890" class="ln">  2890	</span>	select {
<span id="L2891" class="ln">  2891	</span>	case &lt;-p.donec:
<span id="L2892" class="ln">  2892	</span>	default:
<span id="L2893" class="ln">  2893	</span>		close(p.donec)
<span id="L2894" class="ln">  2894	</span>	}
<span id="L2895" class="ln">  2895	</span>}
<span id="L2896" class="ln">  2896	</span>
<span id="L2897" class="ln">  2897	</span><span class="comment">// Err returns the error (if any) first set by BreakWithError or CloseWithError.</span>
<span id="L2898" class="ln">  2898	</span>func (p *http2pipe) Err() error {
<span id="L2899" class="ln">  2899	</span>	p.mu.Lock()
<span id="L2900" class="ln">  2900	</span>	defer p.mu.Unlock()
<span id="L2901" class="ln">  2901	</span>	if p.breakErr != nil {
<span id="L2902" class="ln">  2902	</span>		return p.breakErr
<span id="L2903" class="ln">  2903	</span>	}
<span id="L2904" class="ln">  2904	</span>	return p.err
<span id="L2905" class="ln">  2905	</span>}
<span id="L2906" class="ln">  2906	</span>
<span id="L2907" class="ln">  2907	</span><span class="comment">// Done returns a channel which is closed if and when this pipe is closed</span>
<span id="L2908" class="ln">  2908	</span><span class="comment">// with CloseWithError.</span>
<span id="L2909" class="ln">  2909	</span>func (p *http2pipe) Done() &lt;-chan struct{} {
<span id="L2910" class="ln">  2910	</span>	p.mu.Lock()
<span id="L2911" class="ln">  2911	</span>	defer p.mu.Unlock()
<span id="L2912" class="ln">  2912	</span>	if p.donec == nil {
<span id="L2913" class="ln">  2913	</span>		p.donec = make(chan struct{})
<span id="L2914" class="ln">  2914	</span>		if p.err != nil || p.breakErr != nil {
<span id="L2915" class="ln">  2915	</span>
<span id="L2916" class="ln">  2916	</span>			p.closeDoneLocked()
<span id="L2917" class="ln">  2917	</span>		}
<span id="L2918" class="ln">  2918	</span>	}
<span id="L2919" class="ln">  2919	</span>	return p.donec
<span id="L2920" class="ln">  2920	</span>}
<span id="L2921" class="ln">  2921	</span>
<span id="L2922" class="ln">  2922	</span>const (
<span id="L2923" class="ln">  2923	</span>	http2prefaceTimeout        = 10 * time.Second
<span id="L2924" class="ln">  2924	</span>	http2firstSettingsTimeout  = 2 * time.Second <span class="comment">// should be in-flight with preface anyway</span>
<span id="L2925" class="ln">  2925	</span>	http2handlerChunkWriteSize = 4 &lt;&lt; 10
<span id="L2926" class="ln">  2926	</span>	http2defaultMaxStreams     = 250 <span class="comment">// TODO: make this 100 as the GFE seems to?</span>
<span id="L2927" class="ln">  2927	</span>)
<span id="L2928" class="ln">  2928	</span>
<span id="L2929" class="ln">  2929	</span>var (
<span id="L2930" class="ln">  2930	</span>	http2errClientDisconnected = errors.New(&#34;client disconnected&#34;)
<span id="L2931" class="ln">  2931	</span>	http2errClosedBody         = errors.New(&#34;body closed by handler&#34;)
<span id="L2932" class="ln">  2932	</span>	http2errHandlerComplete    = errors.New(&#34;http2: request body closed due to handler exiting&#34;)
<span id="L2933" class="ln">  2933	</span>	http2errStreamClosed       = errors.New(&#34;http2: stream closed&#34;)
<span id="L2934" class="ln">  2934	</span>)
<span id="L2935" class="ln">  2935	</span>
<span id="L2936" class="ln">  2936	</span>var http2responseWriterStatePool = sync.Pool{
<span id="L2937" class="ln">  2937	</span>	New: func() interface{} {
<span id="L2938" class="ln">  2938	</span>		rws := &amp;http2responseWriterState{}
<span id="L2939" class="ln">  2939	</span>		rws.bw = bufio.NewWriterSize(http2chunkWriter{rws}, http2handlerChunkWriteSize)
<span id="L2940" class="ln">  2940	</span>		return rws
<span id="L2941" class="ln">  2941	</span>	},
<span id="L2942" class="ln">  2942	</span>}
<span id="L2943" class="ln">  2943	</span>
<span id="L2944" class="ln">  2944	</span><span class="comment">// Test hooks.</span>
<span id="L2945" class="ln">  2945	</span>var (
<span id="L2946" class="ln">  2946	</span>	http2testHookOnConn        func()
<span id="L2947" class="ln">  2947	</span>	http2testHookGetServerConn func(*http2serverConn)
<span id="L2948" class="ln">  2948	</span>	http2testHookOnPanicMu     *sync.Mutex <span class="comment">// nil except in tests</span>
<span id="L2949" class="ln">  2949	</span>	http2testHookOnPanic       func(sc *http2serverConn, panicVal interface{}) (rePanic bool)
<span id="L2950" class="ln">  2950	</span>)
<span id="L2951" class="ln">  2951	</span>
<span id="L2952" class="ln">  2952	</span><span class="comment">// Server is an HTTP/2 server.</span>
<span id="L2953" class="ln">  2953	</span>type http2Server struct {
<span id="L2954" class="ln">  2954	</span>	<span class="comment">// MaxHandlers limits the number of http.Handler ServeHTTP goroutines</span>
<span id="L2955" class="ln">  2955	</span>	<span class="comment">// which may run at a time over all connections.</span>
<span id="L2956" class="ln">  2956	</span>	<span class="comment">// Negative or zero no limit.</span>
<span id="L2957" class="ln">  2957	</span>	<span class="comment">// TODO: implement</span>
<span id="L2958" class="ln">  2958	</span>	MaxHandlers int
<span id="L2959" class="ln">  2959	</span>
<span id="L2960" class="ln">  2960	</span>	<span class="comment">// MaxConcurrentStreams optionally specifies the number of</span>
<span id="L2961" class="ln">  2961	</span>	<span class="comment">// concurrent streams that each client may have open at a</span>
<span id="L2962" class="ln">  2962	</span>	<span class="comment">// time. This is unrelated to the number of http.Handler goroutines</span>
<span id="L2963" class="ln">  2963	</span>	<span class="comment">// which may be active globally, which is MaxHandlers.</span>
<span id="L2964" class="ln">  2964	</span>	<span class="comment">// If zero, MaxConcurrentStreams defaults to at least 100, per</span>
<span id="L2965" class="ln">  2965	</span>	<span class="comment">// the HTTP/2 spec&#39;s recommendations.</span>
<span id="L2966" class="ln">  2966	</span>	MaxConcurrentStreams uint32
<span id="L2967" class="ln">  2967	</span>
<span id="L2968" class="ln">  2968	</span>	<span class="comment">// MaxReadFrameSize optionally specifies the largest frame</span>
<span id="L2969" class="ln">  2969	</span>	<span class="comment">// this server is willing to read. A valid value is between</span>
<span id="L2970" class="ln">  2970	</span>	<span class="comment">// 16k and 16M, inclusive. If zero or otherwise invalid, a</span>
<span id="L2971" class="ln">  2971	</span>	<span class="comment">// default value is used.</span>
<span id="L2972" class="ln">  2972	</span>	MaxReadFrameSize uint32
<span id="L2973" class="ln">  2973	</span>
<span id="L2974" class="ln">  2974	</span>	<span class="comment">// PermitProhibitedCipherSuites, if true, permits the use of</span>
<span id="L2975" class="ln">  2975	</span>	<span class="comment">// cipher suites prohibited by the HTTP/2 spec.</span>
<span id="L2976" class="ln">  2976	</span>	PermitProhibitedCipherSuites bool
<span id="L2977" class="ln">  2977	</span>
<span id="L2978" class="ln">  2978	</span>	<span class="comment">// IdleTimeout specifies how long until idle clients should be</span>
<span id="L2979" class="ln">  2979	</span>	<span class="comment">// closed with a GOAWAY frame. PING frames are not considered</span>
<span id="L2980" class="ln">  2980	</span>	<span class="comment">// activity for the purposes of IdleTimeout.</span>
<span id="L2981" class="ln">  2981	</span>	IdleTimeout time.Duration
<span id="L2982" class="ln">  2982	</span>
<span id="L2983" class="ln">  2983	</span>	<span class="comment">// NewWriteScheduler constructs a write scheduler for a connection.</span>
<span id="L2984" class="ln">  2984	</span>	<span class="comment">// If nil, a default scheduler is chosen.</span>
<span id="L2985" class="ln">  2985	</span>	NewWriteScheduler func() http2WriteScheduler
<span id="L2986" class="ln">  2986	</span>}
<span id="L2987" class="ln">  2987	</span>
<span id="L2988" class="ln">  2988	</span>func (s *http2Server) maxReadFrameSize() uint32 {
<span id="L2989" class="ln">  2989	</span>	if v := s.MaxReadFrameSize; v &gt;= http2minMaxFrameSize &amp;&amp; v &lt;= http2maxFrameSize {
<span id="L2990" class="ln">  2990	</span>		return v
<span id="L2991" class="ln">  2991	</span>	}
<span id="L2992" class="ln">  2992	</span>	return http2defaultMaxReadFrameSize
<span id="L2993" class="ln">  2993	</span>}
<span id="L2994" class="ln">  2994	</span>
<span id="L2995" class="ln">  2995	</span>func (s *http2Server) maxConcurrentStreams() uint32 {
<span id="L2996" class="ln">  2996	</span>	if v := s.MaxConcurrentStreams; v &gt; 0 {
<span id="L2997" class="ln">  2997	</span>		return v
<span id="L2998" class="ln">  2998	</span>	}
<span id="L2999" class="ln">  2999	</span>	return http2defaultMaxStreams
<span id="L3000" class="ln">  3000	</span>}
<span id="L3001" class="ln">  3001	</span>
<span id="L3002" class="ln">  3002	</span><span class="comment">// ConfigureServer adds HTTP/2 support to a net/http Server.</span>
<span id="L3003" class="ln">  3003	</span><span class="comment">//</span>
<span id="L3004" class="ln">  3004	</span><span class="comment">// The configuration conf may be nil.</span>
<span id="L3005" class="ln">  3005	</span><span class="comment">//</span>
<span id="L3006" class="ln">  3006	</span><span class="comment">// ConfigureServer must be called before s begins serving.</span>
<span id="L3007" class="ln">  3007	</span>func http2ConfigureServer(s *Server, conf *http2Server) error {
<span id="L3008" class="ln">  3008	</span>	if s == nil {
<span id="L3009" class="ln">  3009	</span>		panic(&#34;nil *http.Server&#34;)
<span id="L3010" class="ln">  3010	</span>	}
<span id="L3011" class="ln">  3011	</span>	if conf == nil {
<span id="L3012" class="ln">  3012	</span>		conf = new(http2Server)
<span id="L3013" class="ln">  3013	</span>	}
<span id="L3014" class="ln">  3014	</span>	if err := http2configureServer18(s, conf); err != nil {
<span id="L3015" class="ln">  3015	</span>		return err
<span id="L3016" class="ln">  3016	</span>	}
<span id="L3017" class="ln">  3017	</span>
<span id="L3018" class="ln">  3018	</span>	if s.TLSConfig == nil {
<span id="L3019" class="ln">  3019	</span>		s.TLSConfig = new(tls.Config)
<span id="L3020" class="ln">  3020	</span>	} else if s.TLSConfig.CipherSuites != nil {
<span id="L3021" class="ln">  3021	</span>		<span class="comment">// If they already provided a CipherSuite list, return</span>
<span id="L3022" class="ln">  3022	</span>		<span class="comment">// an error if it has a bad order or is missing</span>
<span id="L3023" class="ln">  3023	</span>		<span class="comment">// ECDHE_RSA_WITH_AES_128_GCM_SHA256.</span>
<span id="L3024" class="ln">  3024	</span>		const requiredCipher = tls.TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256
<span id="L3025" class="ln">  3025	</span>		haveRequired := false
<span id="L3026" class="ln">  3026	</span>		sawBad := false
<span id="L3027" class="ln">  3027	</span>		for i, cs := range s.TLSConfig.CipherSuites {
<span id="L3028" class="ln">  3028	</span>			if cs == requiredCipher {
<span id="L3029" class="ln">  3029	</span>				haveRequired = true
<span id="L3030" class="ln">  3030	</span>			}
<span id="L3031" class="ln">  3031	</span>			if http2isBadCipher(cs) {
<span id="L3032" class="ln">  3032	</span>				sawBad = true
<span id="L3033" class="ln">  3033	</span>			} else if sawBad {
<span id="L3034" class="ln">  3034	</span>				return fmt.Errorf(&#34;http2: TLSConfig.CipherSuites index %d contains an HTTP/2-approved cipher suite (%#04x), but it comes after unapproved cipher suites. With this configuration, clients that don&#39;t support previous, approved cipher suites may be given an unapproved one and reject the connection.&#34;, i, cs)
<span id="L3035" class="ln">  3035	</span>			}
<span id="L3036" class="ln">  3036	</span>		}
<span id="L3037" class="ln">  3037	</span>		if !haveRequired {
<span id="L3038" class="ln">  3038	</span>			return fmt.Errorf(&#34;http2: TLSConfig.CipherSuites is missing HTTP/2-required TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256&#34;)
<span id="L3039" class="ln">  3039	</span>		}
<span id="L3040" class="ln">  3040	</span>	}
<span id="L3041" class="ln">  3041	</span>
<span id="L3042" class="ln">  3042	</span>	s.TLSConfig.PreferServerCipherSuites = true
<span id="L3043" class="ln">  3043	</span>
<span id="L3044" class="ln">  3044	</span>	haveNPN := false
<span id="L3045" class="ln">  3045	</span>	for _, p := range s.TLSConfig.NextProtos {
<span id="L3046" class="ln">  3046	</span>		if p == http2NextProtoTLS {
<span id="L3047" class="ln">  3047	</span>			haveNPN = true
<span id="L3048" class="ln">  3048	</span>			break
<span id="L3049" class="ln">  3049	</span>		}
<span id="L3050" class="ln">  3050	</span>	}
<span id="L3051" class="ln">  3051	</span>	if !haveNPN {
<span id="L3052" class="ln">  3052	</span>		s.TLSConfig.NextProtos = append(s.TLSConfig.NextProtos, http2NextProtoTLS)
<span id="L3053" class="ln">  3053	</span>	}
<span id="L3054" class="ln">  3054	</span>
<span id="L3055" class="ln">  3055	</span>	if s.TLSNextProto == nil {
<span id="L3056" class="ln">  3056	</span>		s.TLSNextProto = map[string]func(*Server, *tls.Conn, Handler){}
<span id="L3057" class="ln">  3057	</span>	}
<span id="L3058" class="ln">  3058	</span>	protoHandler := func(hs *Server, c *tls.Conn, h Handler) {
<span id="L3059" class="ln">  3059	</span>		if http2testHookOnConn != nil {
<span id="L3060" class="ln">  3060	</span>			http2testHookOnConn()
<span id="L3061" class="ln">  3061	</span>		}
<span id="L3062" class="ln">  3062	</span>		conf.ServeConn(c, &amp;http2ServeConnOpts{
<span id="L3063" class="ln">  3063	</span>			Handler:    h,
<span id="L3064" class="ln">  3064	</span>			BaseConfig: hs,
<span id="L3065" class="ln">  3065	</span>		})
<span id="L3066" class="ln">  3066	</span>	}
<span id="L3067" class="ln">  3067	</span>	s.TLSNextProto[http2NextProtoTLS] = protoHandler
<span id="L3068" class="ln">  3068	</span>	return nil
<span id="L3069" class="ln">  3069	</span>}
<span id="L3070" class="ln">  3070	</span>
<span id="L3071" class="ln">  3071	</span><span class="comment">// ServeConnOpts are options for the Server.ServeConn method.</span>
<span id="L3072" class="ln">  3072	</span>type http2ServeConnOpts struct {
<span id="L3073" class="ln">  3073	</span>	<span class="comment">// BaseConfig optionally sets the base configuration</span>
<span id="L3074" class="ln">  3074	</span>	<span class="comment">// for values. If nil, defaults are used.</span>
<span id="L3075" class="ln">  3075	</span>	BaseConfig *Server
<span id="L3076" class="ln">  3076	</span>
<span id="L3077" class="ln">  3077	</span>	<span class="comment">// Handler specifies which handler to use for processing</span>
<span id="L3078" class="ln">  3078	</span>	<span class="comment">// requests. If nil, BaseConfig.Handler is used. If BaseConfig</span>
<span id="L3079" class="ln">  3079	</span>	<span class="comment">// or BaseConfig.Handler is nil, http.DefaultServeMux is used.</span>
<span id="L3080" class="ln">  3080	</span>	Handler Handler
<span id="L3081" class="ln">  3081	</span>}
<span id="L3082" class="ln">  3082	</span>
<span id="L3083" class="ln">  3083	</span>func (o *http2ServeConnOpts) baseConfig() *Server {
<span id="L3084" class="ln">  3084	</span>	if o != nil &amp;&amp; o.BaseConfig != nil {
<span id="L3085" class="ln">  3085	</span>		return o.BaseConfig
<span id="L3086" class="ln">  3086	</span>	}
<span id="L3087" class="ln">  3087	</span>	return new(Server)
<span id="L3088" class="ln">  3088	</span>}
<span id="L3089" class="ln">  3089	</span>
<span id="L3090" class="ln">  3090	</span>func (o *http2ServeConnOpts) handler() Handler {
<span id="L3091" class="ln">  3091	</span>	if o != nil {
<span id="L3092" class="ln">  3092	</span>		if o.Handler != nil {
<span id="L3093" class="ln">  3093	</span>			return o.Handler
<span id="L3094" class="ln">  3094	</span>		}
<span id="L3095" class="ln">  3095	</span>		if o.BaseConfig != nil &amp;&amp; o.BaseConfig.Handler != nil {
<span id="L3096" class="ln">  3096	</span>			return o.BaseConfig.Handler
<span id="L3097" class="ln">  3097	</span>		}
<span id="L3098" class="ln">  3098	</span>	}
<span id="L3099" class="ln">  3099	</span>	return DefaultServeMux
<span id="L3100" class="ln">  3100	</span>}
<span id="L3101" class="ln">  3101	</span>
<span id="L3102" class="ln">  3102	</span><span class="comment">// ServeConn serves HTTP/2 requests on the provided connection and</span>
<span id="L3103" class="ln">  3103	</span><span class="comment">// blocks until the connection is no longer readable.</span>
<span id="L3104" class="ln">  3104	</span><span class="comment">//</span>
<span id="L3105" class="ln">  3105	</span><span class="comment">// ServeConn starts speaking HTTP/2 assuming that c has not had any</span>
<span id="L3106" class="ln">  3106	</span><span class="comment">// reads or writes. It writes its initial settings frame and expects</span>
<span id="L3107" class="ln">  3107	</span><span class="comment">// to be able to read the preface and settings frame from the</span>
<span id="L3108" class="ln">  3108	</span><span class="comment">// client. If c has a ConnectionState method like a *tls.Conn, the</span>
<span id="L3109" class="ln">  3109	</span><span class="comment">// ConnectionState is used to verify the TLS ciphersuite and to set</span>
<span id="L3110" class="ln">  3110	</span><span class="comment">// the Request.TLS field in Handlers.</span>
<span id="L3111" class="ln">  3111	</span><span class="comment">//</span>
<span id="L3112" class="ln">  3112	</span><span class="comment">// ServeConn does not support h2c by itself. Any h2c support must be</span>
<span id="L3113" class="ln">  3113	</span><span class="comment">// implemented in terms of providing a suitably-behaving net.Conn.</span>
<span id="L3114" class="ln">  3114	</span><span class="comment">//</span>
<span id="L3115" class="ln">  3115	</span><span class="comment">// The opts parameter is optional. If nil, default values are used.</span>
<span id="L3116" class="ln">  3116	</span>func (s *http2Server) ServeConn(c net.Conn, opts *http2ServeConnOpts) {
<span id="L3117" class="ln">  3117	</span>	baseCtx, cancel := http2serverConnBaseContext(c, opts)
<span id="L3118" class="ln">  3118	</span>	defer cancel()
<span id="L3119" class="ln">  3119	</span>
<span id="L3120" class="ln">  3120	</span>	sc := &amp;http2serverConn{
<span id="L3121" class="ln">  3121	</span>		srv:               s,
<span id="L3122" class="ln">  3122	</span>		hs:                opts.baseConfig(),
<span id="L3123" class="ln">  3123	</span>		conn:              c,
<span id="L3124" class="ln">  3124	</span>		baseCtx:           baseCtx,
<span id="L3125" class="ln">  3125	</span>		remoteAddrStr:     c.RemoteAddr().String(),
<span id="L3126" class="ln">  3126	</span>		bw:                http2newBufferedWriter(c),
<span id="L3127" class="ln">  3127	</span>		handler:           opts.handler(),
<span id="L3128" class="ln">  3128	</span>		streams:           make(map[uint32]*http2stream),
<span id="L3129" class="ln">  3129	</span>		readFrameCh:       make(chan http2readFrameResult),
<span id="L3130" class="ln">  3130	</span>		wantWriteFrameCh:  make(chan http2FrameWriteRequest, 8),
<span id="L3131" class="ln">  3131	</span>		wantStartPushCh:   make(chan http2startPushRequest, 8),
<span id="L3132" class="ln">  3132	</span>		wroteFrameCh:      make(chan http2frameWriteResult, 1),
<span id="L3133" class="ln">  3133	</span>		bodyReadCh:        make(chan http2bodyReadMsg),
<span id="L3134" class="ln">  3134	</span>		doneServing:       make(chan struct{}),
<span id="L3135" class="ln">  3135	</span>		clientMaxStreams:  math.MaxUint32,
<span id="L3136" class="ln">  3136	</span>		advMaxStreams:     s.maxConcurrentStreams(),
<span id="L3137" class="ln">  3137	</span>		initialWindowSize: http2initialWindowSize,
<span id="L3138" class="ln">  3138	</span>		maxFrameSize:      http2initialMaxFrameSize,
<span id="L3139" class="ln">  3139	</span>		headerTableSize:   http2initialHeaderTableSize,
<span id="L3140" class="ln">  3140	</span>		serveG:            http2newGoroutineLock(),
<span id="L3141" class="ln">  3141	</span>		pushEnabled:       true,
<span id="L3142" class="ln">  3142	</span>	}
<span id="L3143" class="ln">  3143	</span>
<span id="L3144" class="ln">  3144	</span>	if sc.hs.WriteTimeout != 0 {
<span id="L3145" class="ln">  3145	</span>		sc.conn.SetWriteDeadline(time.Time{})
<span id="L3146" class="ln">  3146	</span>	}
<span id="L3147" class="ln">  3147	</span>
<span id="L3148" class="ln">  3148	</span>	if s.NewWriteScheduler != nil {
<span id="L3149" class="ln">  3149	</span>		sc.writeSched = s.NewWriteScheduler()
<span id="L3150" class="ln">  3150	</span>	} else {
<span id="L3151" class="ln">  3151	</span>		sc.writeSched = http2NewRandomWriteScheduler()
<span id="L3152" class="ln">  3152	</span>	}
<span id="L3153" class="ln">  3153	</span>
<span id="L3154" class="ln">  3154	</span>	sc.flow.add(http2initialWindowSize)
<span id="L3155" class="ln">  3155	</span>	sc.inflow.add(http2initialWindowSize)
<span id="L3156" class="ln">  3156	</span>	sc.hpackEncoder = hpack.NewEncoder(&amp;sc.headerWriteBuf)
<span id="L3157" class="ln">  3157	</span>
<span id="L3158" class="ln">  3158	</span>	fr := http2NewFramer(sc.bw, c)
<span id="L3159" class="ln">  3159	</span>	fr.ReadMetaHeaders = hpack.NewDecoder(http2initialHeaderTableSize, nil)
<span id="L3160" class="ln">  3160	</span>	fr.MaxHeaderListSize = sc.maxHeaderListSize()
<span id="L3161" class="ln">  3161	</span>	fr.SetMaxReadFrameSize(s.maxReadFrameSize())
<span id="L3162" class="ln">  3162	</span>	sc.framer = fr
<span id="L3163" class="ln">  3163	</span>
<span id="L3164" class="ln">  3164	</span>	if tc, ok := c.(http2connectionStater); ok {
<span id="L3165" class="ln">  3165	</span>		sc.tlsState = new(tls.ConnectionState)
<span id="L3166" class="ln">  3166	</span>		*sc.tlsState = tc.ConnectionState()
<span id="L3167" class="ln">  3167	</span>
<span id="L3168" class="ln">  3168	</span>		if sc.tlsState.Version &lt; tls.VersionTLS12 {
<span id="L3169" class="ln">  3169	</span>			sc.rejectConn(http2ErrCodeInadequateSecurity, &#34;TLS version too low&#34;)
<span id="L3170" class="ln">  3170	</span>			return
<span id="L3171" class="ln">  3171	</span>		}
<span id="L3172" class="ln">  3172	</span>
<span id="L3173" class="ln">  3173	</span>		if sc.tlsState.ServerName == &#34;&#34; {
<span id="L3174" class="ln">  3174	</span>
<span id="L3175" class="ln">  3175	</span>		}
<span id="L3176" class="ln">  3176	</span>
<span id="L3177" class="ln">  3177	</span>		if !s.PermitProhibitedCipherSuites &amp;&amp; http2isBadCipher(sc.tlsState.CipherSuite) {
<span id="L3178" class="ln">  3178	</span>
<span id="L3179" class="ln">  3179	</span>			sc.rejectConn(http2ErrCodeInadequateSecurity, fmt.Sprintf(&#34;Prohibited TLS 1.2 Cipher Suite: %x&#34;, sc.tlsState.CipherSuite))
<span id="L3180" class="ln">  3180	</span>			return
<span id="L3181" class="ln">  3181	</span>		}
<span id="L3182" class="ln">  3182	</span>	}
<span id="L3183" class="ln">  3183	</span>
<span id="L3184" class="ln">  3184	</span>	if hook := http2testHookGetServerConn; hook != nil {
<span id="L3185" class="ln">  3185	</span>		hook(sc)
<span id="L3186" class="ln">  3186	</span>	}
<span id="L3187" class="ln">  3187	</span>	sc.serve()
<span id="L3188" class="ln">  3188	</span>}
<span id="L3189" class="ln">  3189	</span>
<span id="L3190" class="ln">  3190	</span>func (sc *http2serverConn) rejectConn(err http2ErrCode, debug string) {
<span id="L3191" class="ln">  3191	</span>	sc.vlogf(&#34;http2: server rejecting conn: %v, %s&#34;, err, debug)
<span id="L3192" class="ln">  3192	</span>
<span id="L3193" class="ln">  3193	</span>	sc.framer.WriteGoAway(0, err, []byte(debug))
<span id="L3194" class="ln">  3194	</span>	sc.bw.Flush()
<span id="L3195" class="ln">  3195	</span>	sc.conn.Close()
<span id="L3196" class="ln">  3196	</span>}
<span id="L3197" class="ln">  3197	</span>
<span id="L3198" class="ln">  3198	</span>type http2serverConn struct {
<span id="L3199" class="ln">  3199	</span>	<span class="comment">// Immutable:</span>
<span id="L3200" class="ln">  3200	</span>	srv              *http2Server
<span id="L3201" class="ln">  3201	</span>	hs               *Server
<span id="L3202" class="ln">  3202	</span>	conn             net.Conn
<span id="L3203" class="ln">  3203	</span>	bw               *http2bufferedWriter <span class="comment">// writing to conn</span>
<span id="L3204" class="ln">  3204	</span>	handler          Handler
<span id="L3205" class="ln">  3205	</span>	baseCtx          http2contextContext
<span id="L3206" class="ln">  3206	</span>	framer           *http2Framer
<span id="L3207" class="ln">  3207	</span>	doneServing      chan struct{}               <span class="comment">// closed when serverConn.serve ends</span>
<span id="L3208" class="ln">  3208	</span>	readFrameCh      chan http2readFrameResult   <span class="comment">// written by serverConn.readFrames</span>
<span id="L3209" class="ln">  3209	</span>	wantWriteFrameCh chan http2FrameWriteRequest <span class="comment">// from handlers -&gt; serve</span>
<span id="L3210" class="ln">  3210	</span>	wantStartPushCh  chan http2startPushRequest  <span class="comment">// from handlers -&gt; serve</span>
<span id="L3211" class="ln">  3211	</span>	wroteFrameCh     chan http2frameWriteResult  <span class="comment">// from writeFrameAsync -&gt; serve, tickles more frame writes</span>
<span id="L3212" class="ln">  3212	</span>	bodyReadCh       chan http2bodyReadMsg       <span class="comment">// from handlers -&gt; serve</span>
<span id="L3213" class="ln">  3213	</span>	testHookCh       chan func(int)              <span class="comment">// code to run on the serve loop</span>
<span id="L3214" class="ln">  3214	</span>	flow             http2flow                   <span class="comment">// conn-wide (not stream-specific) outbound flow control</span>
<span id="L3215" class="ln">  3215	</span>	inflow           http2flow                   <span class="comment">// conn-wide inbound flow control</span>
<span id="L3216" class="ln">  3216	</span>	tlsState         *tls.ConnectionState        <span class="comment">// shared by all handlers, like net/http</span>
<span id="L3217" class="ln">  3217	</span>	remoteAddrStr    string
<span id="L3218" class="ln">  3218	</span>	writeSched       http2WriteScheduler
<span id="L3219" class="ln">  3219	</span>
<span id="L3220" class="ln">  3220	</span>	<span class="comment">// Everything following is owned by the serve loop; use serveG.check():</span>
<span id="L3221" class="ln">  3221	</span>	serveG                http2goroutineLock <span class="comment">// used to verify funcs are on serve()</span>
<span id="L3222" class="ln">  3222	</span>	pushEnabled           bool
<span id="L3223" class="ln">  3223	</span>	sawFirstSettings      bool <span class="comment">// got the initial SETTINGS frame after the preface</span>
<span id="L3224" class="ln">  3224	</span>	needToSendSettingsAck bool
<span id="L3225" class="ln">  3225	</span>	unackedSettings       int    <span class="comment">// how many SETTINGS have we sent without ACKs?</span>
<span id="L3226" class="ln">  3226	</span>	clientMaxStreams      uint32 <span class="comment">// SETTINGS_MAX_CONCURRENT_STREAMS from client (our PUSH_PROMISE limit)</span>
<span id="L3227" class="ln">  3227	</span>	advMaxStreams         uint32 <span class="comment">// our SETTINGS_MAX_CONCURRENT_STREAMS advertised the client</span>
<span id="L3228" class="ln">  3228	</span>	curClientStreams      uint32 <span class="comment">// number of open streams initiated by the client</span>
<span id="L3229" class="ln">  3229	</span>	curPushedStreams      uint32 <span class="comment">// number of open streams initiated by server push</span>
<span id="L3230" class="ln">  3230	</span>	maxClientStreamID     uint32 <span class="comment">// max ever seen from client (odd), or 0 if there have been no client requests</span>
<span id="L3231" class="ln">  3231	</span>	maxPushPromiseID      uint32 <span class="comment">// ID of the last push promise (even), or 0 if there have been no pushes</span>
<span id="L3232" class="ln">  3232	</span>	streams               map[uint32]*http2stream
<span id="L3233" class="ln">  3233	</span>	initialWindowSize     int32
<span id="L3234" class="ln">  3234	</span>	maxFrameSize          int32
<span id="L3235" class="ln">  3235	</span>	headerTableSize       uint32
<span id="L3236" class="ln">  3236	</span>	peerMaxHeaderListSize uint32            <span class="comment">// zero means unknown (default)</span>
<span id="L3237" class="ln">  3237	</span>	canonHeader           map[string]string <span class="comment">// http2-lower-case -&gt; Go-Canonical-Case</span>
<span id="L3238" class="ln">  3238	</span>	writingFrame          bool              <span class="comment">// started writing a frame (on serve goroutine or separate)</span>
<span id="L3239" class="ln">  3239	</span>	writingFrameAsync     bool              <span class="comment">// started a frame on its own goroutine but haven&#39;t heard back on wroteFrameCh</span>
<span id="L3240" class="ln">  3240	</span>	needsFrameFlush       bool              <span class="comment">// last frame write wasn&#39;t a flush</span>
<span id="L3241" class="ln">  3241	</span>	inGoAway              bool              <span class="comment">// we&#39;ve started to or sent GOAWAY</span>
<span id="L3242" class="ln">  3242	</span>	inFrameScheduleLoop   bool              <span class="comment">// whether we&#39;re in the scheduleFrameWrite loop</span>
<span id="L3243" class="ln">  3243	</span>	needToSendGoAway      bool              <span class="comment">// we need to schedule a GOAWAY frame write</span>
<span id="L3244" class="ln">  3244	</span>	goAwayCode            http2ErrCode
<span id="L3245" class="ln">  3245	</span>	shutdownTimerCh       &lt;-chan time.Time <span class="comment">// nil until used</span>
<span id="L3246" class="ln">  3246	</span>	shutdownTimer         *time.Timer      <span class="comment">// nil until used</span>
<span id="L3247" class="ln">  3247	</span>	idleTimer             *time.Timer      <span class="comment">// nil if unused</span>
<span id="L3248" class="ln">  3248	</span>	idleTimerCh           &lt;-chan time.Time <span class="comment">// nil if unused</span>
<span id="L3249" class="ln">  3249	</span>
<span id="L3250" class="ln">  3250	</span>	<span class="comment">// Owned by the writeFrameAsync goroutine:</span>
<span id="L3251" class="ln">  3251	</span>	headerWriteBuf bytes.Buffer
<span id="L3252" class="ln">  3252	</span>	hpackEncoder   *hpack.Encoder
<span id="L3253" class="ln">  3253	</span>}
<span id="L3254" class="ln">  3254	</span>
<span id="L3255" class="ln">  3255	</span>func (sc *http2serverConn) maxHeaderListSize() uint32 {
<span id="L3256" class="ln">  3256	</span>	n := sc.hs.MaxHeaderBytes
<span id="L3257" class="ln">  3257	</span>	if n &lt;= 0 {
<span id="L3258" class="ln">  3258	</span>		n = DefaultMaxHeaderBytes
<span id="L3259" class="ln">  3259	</span>	}
<span id="L3260" class="ln">  3260	</span>	<span class="comment">// http2&#39;s count is in a slightly different unit and includes 32 bytes per pair.</span>
<span id="L3261" class="ln">  3261	</span>	<span class="comment">// So, take the net/http.Server value and pad it up a bit, assuming 10 headers.</span>
<span id="L3262" class="ln">  3262	</span>	const perFieldOverhead = 32 <span class="comment">// per http2 spec</span>
<span id="L3263" class="ln">  3263	</span>	const typicalHeaders = 10   <span class="comment">// conservative</span>
<span id="L3264" class="ln">  3264	</span>	return uint32(n + typicalHeaders*perFieldOverhead)
<span id="L3265" class="ln">  3265	</span>}
<span id="L3266" class="ln">  3266	</span>
<span id="L3267" class="ln">  3267	</span>func (sc *http2serverConn) curOpenStreams() uint32 {
<span id="L3268" class="ln">  3268	</span>	sc.serveG.check()
<span id="L3269" class="ln">  3269	</span>	return sc.curClientStreams + sc.curPushedStreams
<span id="L3270" class="ln">  3270	</span>}
<span id="L3271" class="ln">  3271	</span>
<span id="L3272" class="ln">  3272	</span><span class="comment">// stream represents a stream. This is the minimal metadata needed by</span>
<span id="L3273" class="ln">  3273	</span><span class="comment">// the serve goroutine. Most of the actual stream state is owned by</span>
<span id="L3274" class="ln">  3274	</span><span class="comment">// the http.Handler&#39;s goroutine in the responseWriter. Because the</span>
<span id="L3275" class="ln">  3275	</span><span class="comment">// responseWriter&#39;s responseWriterState is recycled at the end of a</span>
<span id="L3276" class="ln">  3276	</span><span class="comment">// handler, this struct intentionally has no pointer to the</span>
<span id="L3277" class="ln">  3277	</span><span class="comment">// *responseWriter{,State} itself, as the Handler ending nils out the</span>
<span id="L3278" class="ln">  3278	</span><span class="comment">// responseWriter&#39;s state field.</span>
<span id="L3279" class="ln">  3279	</span>type http2stream struct {
<span id="L3280" class="ln">  3280	</span>	<span class="comment">// immutable:</span>
<span id="L3281" class="ln">  3281	</span>	sc        *http2serverConn
<span id="L3282" class="ln">  3282	</span>	id        uint32
<span id="L3283" class="ln">  3283	</span>	body      *http2pipe       <span class="comment">// non-nil if expecting DATA frames</span>
<span id="L3284" class="ln">  3284	</span>	cw        http2closeWaiter <span class="comment">// closed wait stream transitions to closed state</span>
<span id="L3285" class="ln">  3285	</span>	ctx       http2contextContext
<span id="L3286" class="ln">  3286	</span>	cancelCtx func()
<span id="L3287" class="ln">  3287	</span>
<span id="L3288" class="ln">  3288	</span>	<span class="comment">// owned by serverConn&#39;s serve loop:</span>
<span id="L3289" class="ln">  3289	</span>	bodyBytes        int64        <span class="comment">// body bytes seen so far</span>
<span id="L3290" class="ln">  3290	</span>	declBodyBytes    int64        <span class="comment">// or -1 if undeclared</span>
<span id="L3291" class="ln">  3291	</span>	flow             http2flow    <span class="comment">// limits writing from Handler to client</span>
<span id="L3292" class="ln">  3292	</span>	inflow           http2flow    <span class="comment">// what the client is allowed to POST/etc to us</span>
<span id="L3293" class="ln">  3293	</span>	parent           *http2stream <span class="comment">// or nil</span>
<span id="L3294" class="ln">  3294	</span>	numTrailerValues int64
<span id="L3295" class="ln">  3295	</span>	weight           uint8
<span id="L3296" class="ln">  3296	</span>	state            http2streamState
<span id="L3297" class="ln">  3297	</span>	resetQueued      bool   <span class="comment">// RST_STREAM queued for write; set by sc.resetStream</span>
<span id="L3298" class="ln">  3298	</span>	gotTrailerHeader bool   <span class="comment">// HEADER frame for trailers was seen</span>
<span id="L3299" class="ln">  3299	</span>	wroteHeaders     bool   <span class="comment">// whether we wrote headers (not status 100)</span>
<span id="L3300" class="ln">  3300	</span>	reqBuf           []byte <span class="comment">// if non-nil, body pipe buffer to return later at EOF</span>
<span id="L3301" class="ln">  3301	</span>
<span id="L3302" class="ln">  3302	</span>	trailer    Header <span class="comment">// accumulated trailers</span>
<span id="L3303" class="ln">  3303	</span>	reqTrailer Header <span class="comment">// handler&#39;s Request.Trailer</span>
<span id="L3304" class="ln">  3304	</span>}
<span id="L3305" class="ln">  3305	</span>
<span id="L3306" class="ln">  3306	</span>func (sc *http2serverConn) Framer() *http2Framer { return sc.framer }
<span id="L3307" class="ln">  3307	</span>
<span id="L3308" class="ln">  3308	</span>func (sc *http2serverConn) CloseConn() error { return sc.conn.Close() }
<span id="L3309" class="ln">  3309	</span>
<span id="L3310" class="ln">  3310	</span>func (sc *http2serverConn) Flush() error { return sc.bw.Flush() }
<span id="L3311" class="ln">  3311	</span>
<span id="L3312" class="ln">  3312	</span>func (sc *http2serverConn) HeaderEncoder() (*hpack.Encoder, *bytes.Buffer) {
<span id="L3313" class="ln">  3313	</span>	return sc.hpackEncoder, &amp;sc.headerWriteBuf
<span id="L3314" class="ln">  3314	</span>}
<span id="L3315" class="ln">  3315	</span>
<span id="L3316" class="ln">  3316	</span>func (sc *http2serverConn) state(streamID uint32) (http2streamState, *http2stream) {
<span id="L3317" class="ln">  3317	</span>	sc.serveG.check()
<span id="L3318" class="ln">  3318	</span>
<span id="L3319" class="ln">  3319	</span>	if st, ok := sc.streams[streamID]; ok {
<span id="L3320" class="ln">  3320	</span>		return st.state, st
<span id="L3321" class="ln">  3321	</span>	}
<span id="L3322" class="ln">  3322	</span>
<span id="L3323" class="ln">  3323	</span>	if streamID%2 == 1 {
<span id="L3324" class="ln">  3324	</span>		if streamID &lt;= sc.maxClientStreamID {
<span id="L3325" class="ln">  3325	</span>			return http2stateClosed, nil
<span id="L3326" class="ln">  3326	</span>		}
<span id="L3327" class="ln">  3327	</span>	} else {
<span id="L3328" class="ln">  3328	</span>		if streamID &lt;= sc.maxPushPromiseID {
<span id="L3329" class="ln">  3329	</span>			return http2stateClosed, nil
<span id="L3330" class="ln">  3330	</span>		}
<span id="L3331" class="ln">  3331	</span>	}
<span id="L3332" class="ln">  3332	</span>	return http2stateIdle, nil
<span id="L3333" class="ln">  3333	</span>}
<span id="L3334" class="ln">  3334	</span>
<span id="L3335" class="ln">  3335	</span><span class="comment">// setConnState calls the net/http ConnState hook for this connection, if configured.</span>
<span id="L3336" class="ln">  3336	</span><span class="comment">// Note that the net/http package does StateNew and StateClosed for us.</span>
<span id="L3337" class="ln">  3337	</span><span class="comment">// There is currently no plan for StateHijacked or hijacking HTTP/2 connections.</span>
<span id="L3338" class="ln">  3338	</span>func (sc *http2serverConn) setConnState(state ConnState) {
<span id="L3339" class="ln">  3339	</span>	if sc.hs.ConnState != nil {
<span id="L3340" class="ln">  3340	</span>		sc.hs.ConnState(sc.conn, state)
<span id="L3341" class="ln">  3341	</span>	}
<span id="L3342" class="ln">  3342	</span>}
<span id="L3343" class="ln">  3343	</span>
<span id="L3344" class="ln">  3344	</span>func (sc *http2serverConn) vlogf(format string, args ...interface{}) {
<span id="L3345" class="ln">  3345	</span>	if http2VerboseLogs {
<span id="L3346" class="ln">  3346	</span>		sc.logf(format, args...)
<span id="L3347" class="ln">  3347	</span>	}
<span id="L3348" class="ln">  3348	</span>}
<span id="L3349" class="ln">  3349	</span>
<span id="L3350" class="ln">  3350	</span>func (sc *http2serverConn) logf(format string, args ...interface{}) {
<span id="L3351" class="ln">  3351	</span>	if lg := sc.hs.ErrorLog; lg != nil {
<span id="L3352" class="ln">  3352	</span>		lg.Printf(format, args...)
<span id="L3353" class="ln">  3353	</span>	} else {
<span id="L3354" class="ln">  3354	</span>		log.Printf(format, args...)
<span id="L3355" class="ln">  3355	</span>	}
<span id="L3356" class="ln">  3356	</span>}
<span id="L3357" class="ln">  3357	</span>
<span id="L3358" class="ln">  3358	</span><span class="comment">// errno returns v&#39;s underlying uintptr, else 0.</span>
<span id="L3359" class="ln">  3359	</span><span class="comment">//</span>
<span id="L3360" class="ln">  3360	</span><span class="comment">// TODO: remove this helper function once http2 can use build</span>
<span id="L3361" class="ln">  3361	</span><span class="comment">// tags. See comment in isClosedConnError.</span>
<span id="L3362" class="ln">  3362	</span>func http2errno(v error) uintptr {
<span id="L3363" class="ln">  3363	</span>	if rv := reflect.ValueOf(v); rv.Kind() == reflect.Uintptr {
<span id="L3364" class="ln">  3364	</span>		return uintptr(rv.Uint())
<span id="L3365" class="ln">  3365	</span>	}
<span id="L3366" class="ln">  3366	</span>	return 0
<span id="L3367" class="ln">  3367	</span>}
<span id="L3368" class="ln">  3368	</span>
<span id="L3369" class="ln">  3369	</span><span class="comment">// isClosedConnError reports whether err is an error from use of a closed</span>
<span id="L3370" class="ln">  3370	</span><span class="comment">// network connection.</span>
<span id="L3371" class="ln">  3371	</span>func http2isClosedConnError(err error) bool {
<span id="L3372" class="ln">  3372	</span>	if err == nil {
<span id="L3373" class="ln">  3373	</span>		return false
<span id="L3374" class="ln">  3374	</span>	}
<span id="L3375" class="ln">  3375	</span>
<span id="L3376" class="ln">  3376	</span>	str := err.Error()
<span id="L3377" class="ln">  3377	</span>	if strings.Contains(str, &#34;use of closed network connection&#34;) {
<span id="L3378" class="ln">  3378	</span>		return true
<span id="L3379" class="ln">  3379	</span>	}
<span id="L3380" class="ln">  3380	</span>
<span id="L3381" class="ln">  3381	</span>	if runtime.GOOS == &#34;windows&#34; {
<span id="L3382" class="ln">  3382	</span>		if oe, ok := err.(*net.OpError); ok &amp;&amp; oe.Op == &#34;read&#34; {
<span id="L3383" class="ln">  3383	</span>			if se, ok := oe.Err.(*os.SyscallError); ok &amp;&amp; se.Syscall == &#34;wsarecv&#34; {
<span id="L3384" class="ln">  3384	</span>				const WSAECONNABORTED = 10053
<span id="L3385" class="ln">  3385	</span>				const WSAECONNRESET = 10054
<span id="L3386" class="ln">  3386	</span>				if n := http2errno(se.Err); n == WSAECONNRESET || n == WSAECONNABORTED {
<span id="L3387" class="ln">  3387	</span>					return true
<span id="L3388" class="ln">  3388	</span>				}
<span id="L3389" class="ln">  3389	</span>			}
<span id="L3390" class="ln">  3390	</span>		}
<span id="L3391" class="ln">  3391	</span>	}
<span id="L3392" class="ln">  3392	</span>	return false
<span id="L3393" class="ln">  3393	</span>}
<span id="L3394" class="ln">  3394	</span>
<span id="L3395" class="ln">  3395	</span>func (sc *http2serverConn) condlogf(err error, format string, args ...interface{}) {
<span id="L3396" class="ln">  3396	</span>	if err == nil {
<span id="L3397" class="ln">  3397	</span>		return
<span id="L3398" class="ln">  3398	</span>	}
<span id="L3399" class="ln">  3399	</span>	if err == io.EOF || err == io.ErrUnexpectedEOF || http2isClosedConnError(err) {
<span id="L3400" class="ln">  3400	</span>
<span id="L3401" class="ln">  3401	</span>		sc.vlogf(format, args...)
<span id="L3402" class="ln">  3402	</span>	} else {
<span id="L3403" class="ln">  3403	</span>		sc.logf(format, args...)
<span id="L3404" class="ln">  3404	</span>	}
<span id="L3405" class="ln">  3405	</span>}
<span id="L3406" class="ln">  3406	</span>
<span id="L3407" class="ln">  3407	</span>func (sc *http2serverConn) canonicalHeader(v string) string {
<span id="L3408" class="ln">  3408	</span>	sc.serveG.check()
<span id="L3409" class="ln">  3409	</span>	cv, ok := http2commonCanonHeader[v]
<span id="L3410" class="ln">  3410	</span>	if ok {
<span id="L3411" class="ln">  3411	</span>		return cv
<span id="L3412" class="ln">  3412	</span>	}
<span id="L3413" class="ln">  3413	</span>	cv, ok = sc.canonHeader[v]
<span id="L3414" class="ln">  3414	</span>	if ok {
<span id="L3415" class="ln">  3415	</span>		return cv
<span id="L3416" class="ln">  3416	</span>	}
<span id="L3417" class="ln">  3417	</span>	if sc.canonHeader == nil {
<span id="L3418" class="ln">  3418	</span>		sc.canonHeader = make(map[string]string)
<span id="L3419" class="ln">  3419	</span>	}
<span id="L3420" class="ln">  3420	</span>	cv = CanonicalHeaderKey(v)
<span id="L3421" class="ln">  3421	</span>	sc.canonHeader[v] = cv
<span id="L3422" class="ln">  3422	</span>	return cv
<span id="L3423" class="ln">  3423	</span>}
<span id="L3424" class="ln">  3424	</span>
<span id="L3425" class="ln">  3425	</span>type http2readFrameResult struct {
<span id="L3426" class="ln">  3426	</span>	f   http2Frame <span class="comment">// valid until readMore is called</span>
<span id="L3427" class="ln">  3427	</span>	err error
<span id="L3428" class="ln">  3428	</span>
<span id="L3429" class="ln">  3429	</span>	<span class="comment">// readMore should be called once the consumer no longer needs or</span>
<span id="L3430" class="ln">  3430	</span>	<span class="comment">// retains f. After readMore, f is invalid and more frames can be</span>
<span id="L3431" class="ln">  3431	</span>	<span class="comment">// read.</span>
<span id="L3432" class="ln">  3432	</span>	readMore func()
<span id="L3433" class="ln">  3433	</span>}
<span id="L3434" class="ln">  3434	</span>
<span id="L3435" class="ln">  3435	</span><span class="comment">// readFrames is the loop that reads incoming frames.</span>
<span id="L3436" class="ln">  3436	</span><span class="comment">// It takes care to only read one frame at a time, blocking until the</span>
<span id="L3437" class="ln">  3437	</span><span class="comment">// consumer is done with the frame.</span>
<span id="L3438" class="ln">  3438	</span><span class="comment">// It&#39;s run on its own goroutine.</span>
<span id="L3439" class="ln">  3439	</span>func (sc *http2serverConn) readFrames() {
<span id="L3440" class="ln">  3440	</span>	gate := make(http2gate)
<span id="L3441" class="ln">  3441	</span>	gateDone := gate.Done
<span id="L3442" class="ln">  3442	</span>	for {
<span id="L3443" class="ln">  3443	</span>		f, err := sc.framer.ReadFrame()
<span id="L3444" class="ln">  3444	</span>		select {
<span id="L3445" class="ln">  3445	</span>		case sc.readFrameCh &lt;- http2readFrameResult{f, err, gateDone}:
<span id="L3446" class="ln">  3446	</span>		case &lt;-sc.doneServing:
<span id="L3447" class="ln">  3447	</span>			return
<span id="L3448" class="ln">  3448	</span>		}
<span id="L3449" class="ln">  3449	</span>		select {
<span id="L3450" class="ln">  3450	</span>		case &lt;-gate:
<span id="L3451" class="ln">  3451	</span>		case &lt;-sc.doneServing:
<span id="L3452" class="ln">  3452	</span>			return
<span id="L3453" class="ln">  3453	</span>		}
<span id="L3454" class="ln">  3454	</span>		if http2terminalReadFrameError(err) {
<span id="L3455" class="ln">  3455	</span>			return
<span id="L3456" class="ln">  3456	</span>		}
<span id="L3457" class="ln">  3457	</span>	}
<span id="L3458" class="ln">  3458	</span>}
<span id="L3459" class="ln">  3459	</span>
<span id="L3460" class="ln">  3460	</span><span class="comment">// frameWriteResult is the message passed from writeFrameAsync to the serve goroutine.</span>
<span id="L3461" class="ln">  3461	</span>type http2frameWriteResult struct {
<span id="L3462" class="ln">  3462	</span>	wr  http2FrameWriteRequest <span class="comment">// what was written (or attempted)</span>
<span id="L3463" class="ln">  3463	</span>	err error                  <span class="comment">// result of the writeFrame call</span>
<span id="L3464" class="ln">  3464	</span>}
<span id="L3465" class="ln">  3465	</span>
<span id="L3466" class="ln">  3466	</span><span class="comment">// writeFrameAsync runs in its own goroutine and writes a single frame</span>
<span id="L3467" class="ln">  3467	</span><span class="comment">// and then reports when it&#39;s done.</span>
<span id="L3468" class="ln">  3468	</span><span class="comment">// At most one goroutine can be running writeFrameAsync at a time per</span>
<span id="L3469" class="ln">  3469	</span><span class="comment">// serverConn.</span>
<span id="L3470" class="ln">  3470	</span>func (sc *http2serverConn) writeFrameAsync(wr http2FrameWriteRequest) {
<span id="L3471" class="ln">  3471	</span>	err := wr.write.writeFrame(sc)
<span id="L3472" class="ln">  3472	</span>	sc.wroteFrameCh &lt;- http2frameWriteResult{wr, err}
<span id="L3473" class="ln">  3473	</span>}
<span id="L3474" class="ln">  3474	</span>
<span id="L3475" class="ln">  3475	</span>func (sc *http2serverConn) closeAllStreamsOnConnClose() {
<span id="L3476" class="ln">  3476	</span>	sc.serveG.check()
<span id="L3477" class="ln">  3477	</span>	for _, st := range sc.streams {
<span id="L3478" class="ln">  3478	</span>		sc.closeStream(st, http2errClientDisconnected)
<span id="L3479" class="ln">  3479	</span>	}
<span id="L3480" class="ln">  3480	</span>}
<span id="L3481" class="ln">  3481	</span>
<span id="L3482" class="ln">  3482	</span>func (sc *http2serverConn) stopShutdownTimer() {
<span id="L3483" class="ln">  3483	</span>	sc.serveG.check()
<span id="L3484" class="ln">  3484	</span>	if t := sc.shutdownTimer; t != nil {
<span id="L3485" class="ln">  3485	</span>		t.Stop()
<span id="L3486" class="ln">  3486	</span>	}
<span id="L3487" class="ln">  3487	</span>}
<span id="L3488" class="ln">  3488	</span>
<span id="L3489" class="ln">  3489	</span>func (sc *http2serverConn) notePanic() {
<span id="L3490" class="ln">  3490	</span>
<span id="L3491" class="ln">  3491	</span>	if http2testHookOnPanicMu != nil {
<span id="L3492" class="ln">  3492	</span>		http2testHookOnPanicMu.Lock()
<span id="L3493" class="ln">  3493	</span>		defer http2testHookOnPanicMu.Unlock()
<span id="L3494" class="ln">  3494	</span>	}
<span id="L3495" class="ln">  3495	</span>	if http2testHookOnPanic != nil {
<span id="L3496" class="ln">  3496	</span>		if e := recover(); e != nil {
<span id="L3497" class="ln">  3497	</span>			if http2testHookOnPanic(sc, e) {
<span id="L3498" class="ln">  3498	</span>				panic(e)
<span id="L3499" class="ln">  3499	</span>			}
<span id="L3500" class="ln">  3500	</span>		}
<span id="L3501" class="ln">  3501	</span>	}
<span id="L3502" class="ln">  3502	</span>}
<span id="L3503" class="ln">  3503	</span>
<span id="L3504" class="ln">  3504	</span>func (sc *http2serverConn) serve() {
<span id="L3505" class="ln">  3505	</span>	sc.serveG.check()
<span id="L3506" class="ln">  3506	</span>	defer sc.notePanic()
<span id="L3507" class="ln">  3507	</span>	defer sc.conn.Close()
<span id="L3508" class="ln">  3508	</span>	defer sc.closeAllStreamsOnConnClose()
<span id="L3509" class="ln">  3509	</span>	defer sc.stopShutdownTimer()
<span id="L3510" class="ln">  3510	</span>	defer close(sc.doneServing)
<span id="L3511" class="ln">  3511	</span>
<span id="L3512" class="ln">  3512	</span>	if http2VerboseLogs {
<span id="L3513" class="ln">  3513	</span>		sc.vlogf(&#34;http2: server connection from %v on %p&#34;, sc.conn.RemoteAddr(), sc.hs)
<span id="L3514" class="ln">  3514	</span>	}
<span id="L3515" class="ln">  3515	</span>
<span id="L3516" class="ln">  3516	</span>	sc.writeFrame(http2FrameWriteRequest{
<span id="L3517" class="ln">  3517	</span>		write: http2writeSettings{
<span id="L3518" class="ln">  3518	</span>			{http2SettingMaxFrameSize, sc.srv.maxReadFrameSize()},
<span id="L3519" class="ln">  3519	</span>			{http2SettingMaxConcurrentStreams, sc.advMaxStreams},
<span id="L3520" class="ln">  3520	</span>			{http2SettingMaxHeaderListSize, sc.maxHeaderListSize()},
<span id="L3521" class="ln">  3521	</span>		},
<span id="L3522" class="ln">  3522	</span>	})
<span id="L3523" class="ln">  3523	</span>	sc.unackedSettings++
<span id="L3524" class="ln">  3524	</span>
<span id="L3525" class="ln">  3525	</span>	if err := sc.readPreface(); err != nil {
<span id="L3526" class="ln">  3526	</span>		sc.condlogf(err, &#34;http2: server: error reading preface from client %v: %v&#34;, sc.conn.RemoteAddr(), err)
<span id="L3527" class="ln">  3527	</span>		return
<span id="L3528" class="ln">  3528	</span>	}
<span id="L3529" class="ln">  3529	</span>
<span id="L3530" class="ln">  3530	</span>	sc.setConnState(StateActive)
<span id="L3531" class="ln">  3531	</span>	sc.setConnState(StateIdle)
<span id="L3532" class="ln">  3532	</span>
<span id="L3533" class="ln">  3533	</span>	if sc.srv.IdleTimeout != 0 {
<span id="L3534" class="ln">  3534	</span>		sc.idleTimer = time.NewTimer(sc.srv.IdleTimeout)
<span id="L3535" class="ln">  3535	</span>		defer sc.idleTimer.Stop()
<span id="L3536" class="ln">  3536	</span>		sc.idleTimerCh = sc.idleTimer.C
<span id="L3537" class="ln">  3537	</span>	}
<span id="L3538" class="ln">  3538	</span>
<span id="L3539" class="ln">  3539	</span>	var gracefulShutdownCh &lt;-chan struct{}
<span id="L3540" class="ln">  3540	</span>	if sc.hs != nil {
<span id="L3541" class="ln">  3541	</span>		gracefulShutdownCh = http2h1ServerShutdownChan(sc.hs)
<span id="L3542" class="ln">  3542	</span>	}
<span id="L3543" class="ln">  3543	</span>
<span id="L3544" class="ln">  3544	</span>	go sc.readFrames()
<span id="L3545" class="ln">  3545	</span>
<span id="L3546" class="ln">  3546	</span>	settingsTimer := time.NewTimer(http2firstSettingsTimeout)
<span id="L3547" class="ln">  3547	</span>	loopNum := 0
<span id="L3548" class="ln">  3548	</span>	for {
<span id="L3549" class="ln">  3549	</span>		loopNum++
<span id="L3550" class="ln">  3550	</span>		select {
<span id="L3551" class="ln">  3551	</span>		case wr := &lt;-sc.wantWriteFrameCh:
<span id="L3552" class="ln">  3552	</span>			sc.writeFrame(wr)
<span id="L3553" class="ln">  3553	</span>		case spr := &lt;-sc.wantStartPushCh:
<span id="L3554" class="ln">  3554	</span>			sc.startPush(spr)
<span id="L3555" class="ln">  3555	</span>		case res := &lt;-sc.wroteFrameCh:
<span id="L3556" class="ln">  3556	</span>			sc.wroteFrame(res)
<span id="L3557" class="ln">  3557	</span>		case res := &lt;-sc.readFrameCh:
<span id="L3558" class="ln">  3558	</span>			if !sc.processFrameFromReader(res) {
<span id="L3559" class="ln">  3559	</span>				return
<span id="L3560" class="ln">  3560	</span>			}
<span id="L3561" class="ln">  3561	</span>			res.readMore()
<span id="L3562" class="ln">  3562	</span>			if settingsTimer.C != nil {
<span id="L3563" class="ln">  3563	</span>				settingsTimer.Stop()
<span id="L3564" class="ln">  3564	</span>				settingsTimer.C = nil
<span id="L3565" class="ln">  3565	</span>			}
<span id="L3566" class="ln">  3566	</span>		case m := &lt;-sc.bodyReadCh:
<span id="L3567" class="ln">  3567	</span>			sc.noteBodyRead(m.st, m.n)
<span id="L3568" class="ln">  3568	</span>		case &lt;-settingsTimer.C:
<span id="L3569" class="ln">  3569	</span>			sc.logf(&#34;timeout waiting for SETTINGS frames from %v&#34;, sc.conn.RemoteAddr())
<span id="L3570" class="ln">  3570	</span>			return
<span id="L3571" class="ln">  3571	</span>		case &lt;-gracefulShutdownCh:
<span id="L3572" class="ln">  3572	</span>			gracefulShutdownCh = nil
<span id="L3573" class="ln">  3573	</span>			sc.startGracefulShutdown()
<span id="L3574" class="ln">  3574	</span>		case &lt;-sc.shutdownTimerCh:
<span id="L3575" class="ln">  3575	</span>			sc.vlogf(&#34;GOAWAY close timer fired; closing conn from %v&#34;, sc.conn.RemoteAddr())
<span id="L3576" class="ln">  3576	</span>			return
<span id="L3577" class="ln">  3577	</span>		case &lt;-sc.idleTimerCh:
<span id="L3578" class="ln">  3578	</span>			sc.vlogf(&#34;connection is idle&#34;)
<span id="L3579" class="ln">  3579	</span>			sc.goAway(http2ErrCodeNo)
<span id="L3580" class="ln">  3580	</span>		case fn := &lt;-sc.testHookCh:
<span id="L3581" class="ln">  3581	</span>			fn(loopNum)
<span id="L3582" class="ln">  3582	</span>		}
<span id="L3583" class="ln">  3583	</span>
<span id="L3584" class="ln">  3584	</span>		if sc.inGoAway &amp;&amp; sc.curOpenStreams() == 0 &amp;&amp; !sc.needToSendGoAway &amp;&amp; !sc.writingFrame {
<span id="L3585" class="ln">  3585	</span>			return
<span id="L3586" class="ln">  3586	</span>		}
<span id="L3587" class="ln">  3587	</span>	}
<span id="L3588" class="ln">  3588	</span>}
<span id="L3589" class="ln">  3589	</span>
<span id="L3590" class="ln">  3590	</span><span class="comment">// readPreface reads the ClientPreface greeting from the peer</span>
<span id="L3591" class="ln">  3591	</span><span class="comment">// or returns an error on timeout or an invalid greeting.</span>
<span id="L3592" class="ln">  3592	</span>func (sc *http2serverConn) readPreface() error {
<span id="L3593" class="ln">  3593	</span>	errc := make(chan error, 1)
<span id="L3594" class="ln">  3594	</span>	go func() {
<span id="L3595" class="ln">  3595	</span>
<span id="L3596" class="ln">  3596	</span>		buf := make([]byte, len(http2ClientPreface))
<span id="L3597" class="ln">  3597	</span>		if _, err := io.ReadFull(sc.conn, buf); err != nil {
<span id="L3598" class="ln">  3598	</span>			errc &lt;- err
<span id="L3599" class="ln">  3599	</span>		} else if !bytes.Equal(buf, http2clientPreface) {
<span id="L3600" class="ln">  3600	</span>			errc &lt;- fmt.Errorf(&#34;bogus greeting %q&#34;, buf)
<span id="L3601" class="ln">  3601	</span>		} else {
<span id="L3602" class="ln">  3602	</span>			errc &lt;- nil
<span id="L3603" class="ln">  3603	</span>		}
<span id="L3604" class="ln">  3604	</span>	}()
<span id="L3605" class="ln">  3605	</span>	timer := time.NewTimer(http2prefaceTimeout)
<span id="L3606" class="ln">  3606	</span>	defer timer.Stop()
<span id="L3607" class="ln">  3607	</span>	select {
<span id="L3608" class="ln">  3608	</span>	case &lt;-timer.C:
<span id="L3609" class="ln">  3609	</span>		return errors.New(&#34;timeout waiting for client preface&#34;)
<span id="L3610" class="ln">  3610	</span>	case err := &lt;-errc:
<span id="L3611" class="ln">  3611	</span>		if err == nil {
<span id="L3612" class="ln">  3612	</span>			if http2VerboseLogs {
<span id="L3613" class="ln">  3613	</span>				sc.vlogf(&#34;http2: server: client %v said hello&#34;, sc.conn.RemoteAddr())
<span id="L3614" class="ln">  3614	</span>			}
<span id="L3615" class="ln">  3615	</span>		}
<span id="L3616" class="ln">  3616	</span>		return err
<span id="L3617" class="ln">  3617	</span>	}
<span id="L3618" class="ln">  3618	</span>}
<span id="L3619" class="ln">  3619	</span>
<span id="L3620" class="ln">  3620	</span>var http2errChanPool = sync.Pool{
<span id="L3621" class="ln">  3621	</span>	New: func() interface{} { return make(chan error, 1) },
<span id="L3622" class="ln">  3622	</span>}
<span id="L3623" class="ln">  3623	</span>
<span id="L3624" class="ln">  3624	</span>var http2writeDataPool = sync.Pool{
<span id="L3625" class="ln">  3625	</span>	New: func() interface{} { return new(http2writeData) },
<span id="L3626" class="ln">  3626	</span>}
<span id="L3627" class="ln">  3627	</span>
<span id="L3628" class="ln">  3628	</span><span class="comment">// writeDataFromHandler writes DATA response frames from a handler on</span>
<span id="L3629" class="ln">  3629	</span><span class="comment">// the given stream.</span>
<span id="L3630" class="ln">  3630	</span>func (sc *http2serverConn) writeDataFromHandler(stream *http2stream, data []byte, endStream bool) error {
<span id="L3631" class="ln">  3631	</span>	ch := http2errChanPool.Get().(chan error)
<span id="L3632" class="ln">  3632	</span>	writeArg := http2writeDataPool.Get().(*http2writeData)
<span id="L3633" class="ln">  3633	</span>	*writeArg = http2writeData{stream.id, data, endStream}
<span id="L3634" class="ln">  3634	</span>	err := sc.writeFrameFromHandler(http2FrameWriteRequest{
<span id="L3635" class="ln">  3635	</span>		write:  writeArg,
<span id="L3636" class="ln">  3636	</span>		stream: stream,
<span id="L3637" class="ln">  3637	</span>		done:   ch,
<span id="L3638" class="ln">  3638	</span>	})
<span id="L3639" class="ln">  3639	</span>	if err != nil {
<span id="L3640" class="ln">  3640	</span>		return err
<span id="L3641" class="ln">  3641	</span>	}
<span id="L3642" class="ln">  3642	</span>	var frameWriteDone bool <span class="comment">// the frame write is done (successfully or not)</span>
<span id="L3643" class="ln">  3643	</span>	select {
<span id="L3644" class="ln">  3644	</span>	case err = &lt;-ch:
<span id="L3645" class="ln">  3645	</span>		frameWriteDone = true
<span id="L3646" class="ln">  3646	</span>	case &lt;-sc.doneServing:
<span id="L3647" class="ln">  3647	</span>		return http2errClientDisconnected
<span id="L3648" class="ln">  3648	</span>	case &lt;-stream.cw:
<span id="L3649" class="ln">  3649	</span>
<span id="L3650" class="ln">  3650	</span>		select {
<span id="L3651" class="ln">  3651	</span>		case err = &lt;-ch:
<span id="L3652" class="ln">  3652	</span>			frameWriteDone = true
<span id="L3653" class="ln">  3653	</span>		default:
<span id="L3654" class="ln">  3654	</span>			return http2errStreamClosed
<span id="L3655" class="ln">  3655	</span>		}
<span id="L3656" class="ln">  3656	</span>	}
<span id="L3657" class="ln">  3657	</span>	http2errChanPool.Put(ch)
<span id="L3658" class="ln">  3658	</span>	if frameWriteDone {
<span id="L3659" class="ln">  3659	</span>		http2writeDataPool.Put(writeArg)
<span id="L3660" class="ln">  3660	</span>	}
<span id="L3661" class="ln">  3661	</span>	return err
<span id="L3662" class="ln">  3662	</span>}
<span id="L3663" class="ln">  3663	</span>
<span id="L3664" class="ln">  3664	</span><span class="comment">// writeFrameFromHandler sends wr to sc.wantWriteFrameCh, but aborts</span>
<span id="L3665" class="ln">  3665	</span><span class="comment">// if the connection has gone away.</span>
<span id="L3666" class="ln">  3666	</span><span class="comment">//</span>
<span id="L3667" class="ln">  3667	</span><span class="comment">// This must not be run from the serve goroutine itself, else it might</span>
<span id="L3668" class="ln">  3668	</span><span class="comment">// deadlock writing to sc.wantWriteFrameCh (which is only mildly</span>
<span id="L3669" class="ln">  3669	</span><span class="comment">// buffered and is read by serve itself). If you&#39;re on the serve</span>
<span id="L3670" class="ln">  3670	</span><span class="comment">// goroutine, call writeFrame instead.</span>
<span id="L3671" class="ln">  3671	</span>func (sc *http2serverConn) writeFrameFromHandler(wr http2FrameWriteRequest) error {
<span id="L3672" class="ln">  3672	</span>	sc.serveG.checkNotOn()
<span id="L3673" class="ln">  3673	</span>	select {
<span id="L3674" class="ln">  3674	</span>	case sc.wantWriteFrameCh &lt;- wr:
<span id="L3675" class="ln">  3675	</span>		return nil
<span id="L3676" class="ln">  3676	</span>	case &lt;-sc.doneServing:
<span id="L3677" class="ln">  3677	</span>
<span id="L3678" class="ln">  3678	</span>		return http2errClientDisconnected
<span id="L3679" class="ln">  3679	</span>	}
<span id="L3680" class="ln">  3680	</span>}
<span id="L3681" class="ln">  3681	</span>
<span id="L3682" class="ln">  3682	</span><span class="comment">// writeFrame schedules a frame to write and sends it if there&#39;s nothing</span>
<span id="L3683" class="ln">  3683	</span><span class="comment">// already being written.</span>
<span id="L3684" class="ln">  3684	</span><span class="comment">//</span>
<span id="L3685" class="ln">  3685	</span><span class="comment">// There is no pushback here (the serve goroutine never blocks). It&#39;s</span>
<span id="L3686" class="ln">  3686	</span><span class="comment">// the http.Handlers that block, waiting for their previous frames to</span>
<span id="L3687" class="ln">  3687	</span><span class="comment">// make it onto the wire</span>
<span id="L3688" class="ln">  3688	</span><span class="comment">//</span>
<span id="L3689" class="ln">  3689	</span><span class="comment">// If you&#39;re not on the serve goroutine, use writeFrameFromHandler instead.</span>
<span id="L3690" class="ln">  3690	</span>func (sc *http2serverConn) writeFrame(wr http2FrameWriteRequest) {
<span id="L3691" class="ln">  3691	</span>	sc.serveG.check()
<span id="L3692" class="ln">  3692	</span>
<span id="L3693" class="ln">  3693	</span>	<span class="comment">// If true, wr will not be written and wr.done will not be signaled.</span>
<span id="L3694" class="ln">  3694	</span>	var ignoreWrite bool
<span id="L3695" class="ln">  3695	</span>
<span id="L3696" class="ln">  3696	</span>	if wr.StreamID() != 0 {
<span id="L3697" class="ln">  3697	</span>		_, isReset := wr.write.(http2StreamError)
<span id="L3698" class="ln">  3698	</span>		if state, _ := sc.state(wr.StreamID()); state == http2stateClosed &amp;&amp; !isReset {
<span id="L3699" class="ln">  3699	</span>			ignoreWrite = true
<span id="L3700" class="ln">  3700	</span>		}
<span id="L3701" class="ln">  3701	</span>	}
<span id="L3702" class="ln">  3702	</span>
<span id="L3703" class="ln">  3703	</span>	switch wr.write.(type) {
<span id="L3704" class="ln">  3704	</span>	case *http2writeResHeaders:
<span id="L3705" class="ln">  3705	</span>		wr.stream.wroteHeaders = true
<span id="L3706" class="ln">  3706	</span>	case http2write100ContinueHeadersFrame:
<span id="L3707" class="ln">  3707	</span>		if wr.stream.wroteHeaders {
<span id="L3708" class="ln">  3708	</span>
<span id="L3709" class="ln">  3709	</span>			if wr.done != nil {
<span id="L3710" class="ln">  3710	</span>				panic(&#34;wr.done != nil for write100ContinueHeadersFrame&#34;)
<span id="L3711" class="ln">  3711	</span>			}
<span id="L3712" class="ln">  3712	</span>			ignoreWrite = true
<span id="L3713" class="ln">  3713	</span>		}
<span id="L3714" class="ln">  3714	</span>	}
<span id="L3715" class="ln">  3715	</span>
<span id="L3716" class="ln">  3716	</span>	if !ignoreWrite {
<span id="L3717" class="ln">  3717	</span>		sc.writeSched.Push(wr)
<span id="L3718" class="ln">  3718	</span>	}
<span id="L3719" class="ln">  3719	</span>	sc.scheduleFrameWrite()
<span id="L3720" class="ln">  3720	</span>}
<span id="L3721" class="ln">  3721	</span>
<span id="L3722" class="ln">  3722	</span><span class="comment">// startFrameWrite starts a goroutine to write wr (in a separate</span>
<span id="L3723" class="ln">  3723	</span><span class="comment">// goroutine since that might block on the network), and updates the</span>
<span id="L3724" class="ln">  3724	</span><span class="comment">// serve goroutine&#39;s state about the world, updated from info in wr.</span>
<span id="L3725" class="ln">  3725	</span>func (sc *http2serverConn) startFrameWrite(wr http2FrameWriteRequest) {
<span id="L3726" class="ln">  3726	</span>	sc.serveG.check()
<span id="L3727" class="ln">  3727	</span>	if sc.writingFrame {
<span id="L3728" class="ln">  3728	</span>		panic(&#34;internal error: can only be writing one frame at a time&#34;)
<span id="L3729" class="ln">  3729	</span>	}
<span id="L3730" class="ln">  3730	</span>
<span id="L3731" class="ln">  3731	</span>	st := wr.stream
<span id="L3732" class="ln">  3732	</span>	if st != nil {
<span id="L3733" class="ln">  3733	</span>		switch st.state {
<span id="L3734" class="ln">  3734	</span>		case http2stateHalfClosedLocal:
<span id="L3735" class="ln">  3735	</span>			switch wr.write.(type) {
<span id="L3736" class="ln">  3736	</span>			case http2StreamError, http2handlerPanicRST, http2writeWindowUpdate:
<span id="L3737" class="ln">  3737	</span>
<span id="L3738" class="ln">  3738	</span>			default:
<span id="L3739" class="ln">  3739	</span>				panic(fmt.Sprintf(&#34;internal error: attempt to send frame on a half-closed-local stream: %v&#34;, wr))
<span id="L3740" class="ln">  3740	</span>			}
<span id="L3741" class="ln">  3741	</span>		case http2stateClosed:
<span id="L3742" class="ln">  3742	</span>			panic(fmt.Sprintf(&#34;internal error: attempt to send frame on a closed stream: %v&#34;, wr))
<span id="L3743" class="ln">  3743	</span>		}
<span id="L3744" class="ln">  3744	</span>	}
<span id="L3745" class="ln">  3745	</span>	if wpp, ok := wr.write.(*http2writePushPromise); ok {
<span id="L3746" class="ln">  3746	</span>		var err error
<span id="L3747" class="ln">  3747	</span>		wpp.promisedID, err = wpp.allocatePromisedID()
<span id="L3748" class="ln">  3748	</span>		if err != nil {
<span id="L3749" class="ln">  3749	</span>			sc.writingFrameAsync = false
<span id="L3750" class="ln">  3750	</span>			wr.replyToWriter(err)
<span id="L3751" class="ln">  3751	</span>			return
<span id="L3752" class="ln">  3752	</span>		}
<span id="L3753" class="ln">  3753	</span>	}
<span id="L3754" class="ln">  3754	</span>
<span id="L3755" class="ln">  3755	</span>	sc.writingFrame = true
<span id="L3756" class="ln">  3756	</span>	sc.needsFrameFlush = true
<span id="L3757" class="ln">  3757	</span>	if wr.write.staysWithinBuffer(sc.bw.Available()) {
<span id="L3758" class="ln">  3758	</span>		sc.writingFrameAsync = false
<span id="L3759" class="ln">  3759	</span>		err := wr.write.writeFrame(sc)
<span id="L3760" class="ln">  3760	</span>		sc.wroteFrame(http2frameWriteResult{wr, err})
<span id="L3761" class="ln">  3761	</span>	} else {
<span id="L3762" class="ln">  3762	</span>		sc.writingFrameAsync = true
<span id="L3763" class="ln">  3763	</span>		go sc.writeFrameAsync(wr)
<span id="L3764" class="ln">  3764	</span>	}
<span id="L3765" class="ln">  3765	</span>}
<span id="L3766" class="ln">  3766	</span>
<span id="L3767" class="ln">  3767	</span><span class="comment">// errHandlerPanicked is the error given to any callers blocked in a read from</span>
<span id="L3768" class="ln">  3768	</span><span class="comment">// Request.Body when the main goroutine panics. Since most handlers read in the</span>
<span id="L3769" class="ln">  3769	</span><span class="comment">// the main ServeHTTP goroutine, this will show up rarely.</span>
<span id="L3770" class="ln">  3770	</span>var http2errHandlerPanicked = errors.New(&#34;http2: handler panicked&#34;)
<span id="L3771" class="ln">  3771	</span>
<span id="L3772" class="ln">  3772	</span><span class="comment">// wroteFrame is called on the serve goroutine with the result of</span>
<span id="L3773" class="ln">  3773	</span><span class="comment">// whatever happened on writeFrameAsync.</span>
<span id="L3774" class="ln">  3774	</span>func (sc *http2serverConn) wroteFrame(res http2frameWriteResult) {
<span id="L3775" class="ln">  3775	</span>	sc.serveG.check()
<span id="L3776" class="ln">  3776	</span>	if !sc.writingFrame {
<span id="L3777" class="ln">  3777	</span>		panic(&#34;internal error: expected to be already writing a frame&#34;)
<span id="L3778" class="ln">  3778	</span>	}
<span id="L3779" class="ln">  3779	</span>	sc.writingFrame = false
<span id="L3780" class="ln">  3780	</span>	sc.writingFrameAsync = false
<span id="L3781" class="ln">  3781	</span>
<span id="L3782" class="ln">  3782	</span>	wr := res.wr
<span id="L3783" class="ln">  3783	</span>
<span id="L3784" class="ln">  3784	</span>	if http2writeEndsStream(wr.write) {
<span id="L3785" class="ln">  3785	</span>		st := wr.stream
<span id="L3786" class="ln">  3786	</span>		if st == nil {
<span id="L3787" class="ln">  3787	</span>			panic(&#34;internal error: expecting non-nil stream&#34;)
<span id="L3788" class="ln">  3788	</span>		}
<span id="L3789" class="ln">  3789	</span>		switch st.state {
<span id="L3790" class="ln">  3790	</span>		case http2stateOpen:
<span id="L3791" class="ln">  3791	</span>
<span id="L3792" class="ln">  3792	</span>			st.state = http2stateHalfClosedLocal
<span id="L3793" class="ln">  3793	</span>			sc.resetStream(http2streamError(st.id, http2ErrCodeCancel))
<span id="L3794" class="ln">  3794	</span>		case http2stateHalfClosedRemote:
<span id="L3795" class="ln">  3795	</span>			sc.closeStream(st, http2errHandlerComplete)
<span id="L3796" class="ln">  3796	</span>		}
<span id="L3797" class="ln">  3797	</span>	} else {
<span id="L3798" class="ln">  3798	</span>		switch v := wr.write.(type) {
<span id="L3799" class="ln">  3799	</span>		case http2StreamError:
<span id="L3800" class="ln">  3800	</span>
<span id="L3801" class="ln">  3801	</span>			if st, ok := sc.streams[v.StreamID]; ok {
<span id="L3802" class="ln">  3802	</span>				sc.closeStream(st, v)
<span id="L3803" class="ln">  3803	</span>			}
<span id="L3804" class="ln">  3804	</span>		case http2handlerPanicRST:
<span id="L3805" class="ln">  3805	</span>			sc.closeStream(wr.stream, http2errHandlerPanicked)
<span id="L3806" class="ln">  3806	</span>		}
<span id="L3807" class="ln">  3807	</span>	}
<span id="L3808" class="ln">  3808	</span>
<span id="L3809" class="ln">  3809	</span>	wr.replyToWriter(res.err)
<span id="L3810" class="ln">  3810	</span>
<span id="L3811" class="ln">  3811	</span>	sc.scheduleFrameWrite()
<span id="L3812" class="ln">  3812	</span>}
<span id="L3813" class="ln">  3813	</span>
<span id="L3814" class="ln">  3814	</span><span class="comment">// scheduleFrameWrite tickles the frame writing scheduler.</span>
<span id="L3815" class="ln">  3815	</span><span class="comment">//</span>
<span id="L3816" class="ln">  3816	</span><span class="comment">// If a frame is already being written, nothing happens. This will be called again</span>
<span id="L3817" class="ln">  3817	</span><span class="comment">// when the frame is done being written.</span>
<span id="L3818" class="ln">  3818	</span><span class="comment">//</span>
<span id="L3819" class="ln">  3819	</span><span class="comment">// If a frame isn&#39;t being written we need to send one, the best frame</span>
<span id="L3820" class="ln">  3820	</span><span class="comment">// to send is selected, preferring first things that aren&#39;t</span>
<span id="L3821" class="ln">  3821	</span><span class="comment">// stream-specific (e.g. ACKing settings), and then finding the</span>
<span id="L3822" class="ln">  3822	</span><span class="comment">// highest priority stream.</span>
<span id="L3823" class="ln">  3823	</span><span class="comment">//</span>
<span id="L3824" class="ln">  3824	</span><span class="comment">// If a frame isn&#39;t being written and there&#39;s nothing else to send, we</span>
<span id="L3825" class="ln">  3825	</span><span class="comment">// flush the write buffer.</span>
<span id="L3826" class="ln">  3826	</span>func (sc *http2serverConn) scheduleFrameWrite() {
<span id="L3827" class="ln">  3827	</span>	sc.serveG.check()
<span id="L3828" class="ln">  3828	</span>	if sc.writingFrame || sc.inFrameScheduleLoop {
<span id="L3829" class="ln">  3829	</span>		return
<span id="L3830" class="ln">  3830	</span>	}
<span id="L3831" class="ln">  3831	</span>	sc.inFrameScheduleLoop = true
<span id="L3832" class="ln">  3832	</span>	for !sc.writingFrameAsync {
<span id="L3833" class="ln">  3833	</span>		if sc.needToSendGoAway {
<span id="L3834" class="ln">  3834	</span>			sc.needToSendGoAway = false
<span id="L3835" class="ln">  3835	</span>			sc.startFrameWrite(http2FrameWriteRequest{
<span id="L3836" class="ln">  3836	</span>				write: &amp;http2writeGoAway{
<span id="L3837" class="ln">  3837	</span>					maxStreamID: sc.maxClientStreamID,
<span id="L3838" class="ln">  3838	</span>					code:        sc.goAwayCode,
<span id="L3839" class="ln">  3839	</span>				},
<span id="L3840" class="ln">  3840	</span>			})
<span id="L3841" class="ln">  3841	</span>			continue
<span id="L3842" class="ln">  3842	</span>		}
<span id="L3843" class="ln">  3843	</span>		if sc.needToSendSettingsAck {
<span id="L3844" class="ln">  3844	</span>			sc.needToSendSettingsAck = false
<span id="L3845" class="ln">  3845	</span>			sc.startFrameWrite(http2FrameWriteRequest{write: http2writeSettingsAck{}})
<span id="L3846" class="ln">  3846	</span>			continue
<span id="L3847" class="ln">  3847	</span>		}
<span id="L3848" class="ln">  3848	</span>		if !sc.inGoAway || sc.goAwayCode == http2ErrCodeNo {
<span id="L3849" class="ln">  3849	</span>			if wr, ok := sc.writeSched.Pop(); ok {
<span id="L3850" class="ln">  3850	</span>				sc.startFrameWrite(wr)
<span id="L3851" class="ln">  3851	</span>				continue
<span id="L3852" class="ln">  3852	</span>			}
<span id="L3853" class="ln">  3853	</span>		}
<span id="L3854" class="ln">  3854	</span>		if sc.needsFrameFlush {
<span id="L3855" class="ln">  3855	</span>			sc.startFrameWrite(http2FrameWriteRequest{write: http2flushFrameWriter{}})
<span id="L3856" class="ln">  3856	</span>			sc.needsFrameFlush = false
<span id="L3857" class="ln">  3857	</span>			continue
<span id="L3858" class="ln">  3858	</span>		}
<span id="L3859" class="ln">  3859	</span>		break
<span id="L3860" class="ln">  3860	</span>	}
<span id="L3861" class="ln">  3861	</span>	sc.inFrameScheduleLoop = false
<span id="L3862" class="ln">  3862	</span>}
<span id="L3863" class="ln">  3863	</span>
<span id="L3864" class="ln">  3864	</span><span class="comment">// startGracefulShutdown sends a GOAWAY with ErrCodeNo to tell the</span>
<span id="L3865" class="ln">  3865	</span><span class="comment">// client we&#39;re gracefully shutting down. The connection isn&#39;t closed</span>
<span id="L3866" class="ln">  3866	</span><span class="comment">// until all current streams are done.</span>
<span id="L3867" class="ln">  3867	</span>func (sc *http2serverConn) startGracefulShutdown() {
<span id="L3868" class="ln">  3868	</span>	sc.goAwayIn(http2ErrCodeNo, 0)
<span id="L3869" class="ln">  3869	</span>}
<span id="L3870" class="ln">  3870	</span>
<span id="L3871" class="ln">  3871	</span>func (sc *http2serverConn) goAway(code http2ErrCode) {
<span id="L3872" class="ln">  3872	</span>	sc.serveG.check()
<span id="L3873" class="ln">  3873	</span>	var forceCloseIn time.Duration
<span id="L3874" class="ln">  3874	</span>	if code != http2ErrCodeNo {
<span id="L3875" class="ln">  3875	</span>		forceCloseIn = 250 * time.Millisecond
<span id="L3876" class="ln">  3876	</span>	} else {
<span id="L3877" class="ln">  3877	</span>
<span id="L3878" class="ln">  3878	</span>		forceCloseIn = 1 * time.Second
<span id="L3879" class="ln">  3879	</span>	}
<span id="L3880" class="ln">  3880	</span>	sc.goAwayIn(code, forceCloseIn)
<span id="L3881" class="ln">  3881	</span>}
<span id="L3882" class="ln">  3882	</span>
<span id="L3883" class="ln">  3883	</span>func (sc *http2serverConn) goAwayIn(code http2ErrCode, forceCloseIn time.Duration) {
<span id="L3884" class="ln">  3884	</span>	sc.serveG.check()
<span id="L3885" class="ln">  3885	</span>	if sc.inGoAway {
<span id="L3886" class="ln">  3886	</span>		return
<span id="L3887" class="ln">  3887	</span>	}
<span id="L3888" class="ln">  3888	</span>	if forceCloseIn != 0 {
<span id="L3889" class="ln">  3889	</span>		sc.shutDownIn(forceCloseIn)
<span id="L3890" class="ln">  3890	</span>	}
<span id="L3891" class="ln">  3891	</span>	sc.inGoAway = true
<span id="L3892" class="ln">  3892	</span>	sc.needToSendGoAway = true
<span id="L3893" class="ln">  3893	</span>	sc.goAwayCode = code
<span id="L3894" class="ln">  3894	</span>	sc.scheduleFrameWrite()
<span id="L3895" class="ln">  3895	</span>}
<span id="L3896" class="ln">  3896	</span>
<span id="L3897" class="ln">  3897	</span>func (sc *http2serverConn) shutDownIn(d time.Duration) {
<span id="L3898" class="ln">  3898	</span>	sc.serveG.check()
<span id="L3899" class="ln">  3899	</span>	sc.shutdownTimer = time.NewTimer(d)
<span id="L3900" class="ln">  3900	</span>	sc.shutdownTimerCh = sc.shutdownTimer.C
<span id="L3901" class="ln">  3901	</span>}
<span id="L3902" class="ln">  3902	</span>
<span id="L3903" class="ln">  3903	</span>func (sc *http2serverConn) resetStream(se http2StreamError) {
<span id="L3904" class="ln">  3904	</span>	sc.serveG.check()
<span id="L3905" class="ln">  3905	</span>	sc.writeFrame(http2FrameWriteRequest{write: se})
<span id="L3906" class="ln">  3906	</span>	if st, ok := sc.streams[se.StreamID]; ok {
<span id="L3907" class="ln">  3907	</span>		st.resetQueued = true
<span id="L3908" class="ln">  3908	</span>	}
<span id="L3909" class="ln">  3909	</span>}
<span id="L3910" class="ln">  3910	</span>
<span id="L3911" class="ln">  3911	</span><span class="comment">// processFrameFromReader processes the serve loop&#39;s read from readFrameCh from the</span>
<span id="L3912" class="ln">  3912	</span><span class="comment">// frame-reading goroutine.</span>
<span id="L3913" class="ln">  3913	</span><span class="comment">// processFrameFromReader returns whether the connection should be kept open.</span>
<span id="L3914" class="ln">  3914	</span>func (sc *http2serverConn) processFrameFromReader(res http2readFrameResult) bool {
<span id="L3915" class="ln">  3915	</span>	sc.serveG.check()
<span id="L3916" class="ln">  3916	</span>	err := res.err
<span id="L3917" class="ln">  3917	</span>	if err != nil {
<span id="L3918" class="ln">  3918	</span>		if err == http2ErrFrameTooLarge {
<span id="L3919" class="ln">  3919	</span>			sc.goAway(http2ErrCodeFrameSize)
<span id="L3920" class="ln">  3920	</span>			return true
<span id="L3921" class="ln">  3921	</span>		}
<span id="L3922" class="ln">  3922	</span>		clientGone := err == io.EOF || err == io.ErrUnexpectedEOF || http2isClosedConnError(err)
<span id="L3923" class="ln">  3923	</span>		if clientGone {
<span id="L3924" class="ln">  3924	</span>
<span id="L3925" class="ln">  3925	</span>			return false
<span id="L3926" class="ln">  3926	</span>		}
<span id="L3927" class="ln">  3927	</span>	} else {
<span id="L3928" class="ln">  3928	</span>		f := res.f
<span id="L3929" class="ln">  3929	</span>		if http2VerboseLogs {
<span id="L3930" class="ln">  3930	</span>			sc.vlogf(&#34;http2: server read frame %v&#34;, http2summarizeFrame(f))
<span id="L3931" class="ln">  3931	</span>		}
<span id="L3932" class="ln">  3932	</span>		err = sc.processFrame(f)
<span id="L3933" class="ln">  3933	</span>		if err == nil {
<span id="L3934" class="ln">  3934	</span>			return true
<span id="L3935" class="ln">  3935	</span>		}
<span id="L3936" class="ln">  3936	</span>	}
<span id="L3937" class="ln">  3937	</span>
<span id="L3938" class="ln">  3938	</span>	switch ev := err.(type) {
<span id="L3939" class="ln">  3939	</span>	case http2StreamError:
<span id="L3940" class="ln">  3940	</span>		sc.resetStream(ev)
<span id="L3941" class="ln">  3941	</span>		return true
<span id="L3942" class="ln">  3942	</span>	case http2goAwayFlowError:
<span id="L3943" class="ln">  3943	</span>		sc.goAway(http2ErrCodeFlowControl)
<span id="L3944" class="ln">  3944	</span>		return true
<span id="L3945" class="ln">  3945	</span>	case http2ConnectionError:
<span id="L3946" class="ln">  3946	</span>		sc.logf(&#34;http2: server connection error from %v: %v&#34;, sc.conn.RemoteAddr(), ev)
<span id="L3947" class="ln">  3947	</span>		sc.goAway(http2ErrCode(ev))
<span id="L3948" class="ln">  3948	</span>		return true
<span id="L3949" class="ln">  3949	</span>	default:
<span id="L3950" class="ln">  3950	</span>		if res.err != nil {
<span id="L3951" class="ln">  3951	</span>			sc.vlogf(&#34;http2: server closing client connection; error reading frame from client %s: %v&#34;, sc.conn.RemoteAddr(), err)
<span id="L3952" class="ln">  3952	</span>		} else {
<span id="L3953" class="ln">  3953	</span>			sc.logf(&#34;http2: server closing client connection: %v&#34;, err)
<span id="L3954" class="ln">  3954	</span>		}
<span id="L3955" class="ln">  3955	</span>		return false
<span id="L3956" class="ln">  3956	</span>	}
<span id="L3957" class="ln">  3957	</span>}
<span id="L3958" class="ln">  3958	</span>
<span id="L3959" class="ln">  3959	</span>func (sc *http2serverConn) processFrame(f http2Frame) error {
<span id="L3960" class="ln">  3960	</span>	sc.serveG.check()
<span id="L3961" class="ln">  3961	</span>
<span id="L3962" class="ln">  3962	</span>	if !sc.sawFirstSettings {
<span id="L3963" class="ln">  3963	</span>		if _, ok := f.(*http2SettingsFrame); !ok {
<span id="L3964" class="ln">  3964	</span>			return http2ConnectionError(http2ErrCodeProtocol)
<span id="L3965" class="ln">  3965	</span>		}
<span id="L3966" class="ln">  3966	</span>		sc.sawFirstSettings = true
<span id="L3967" class="ln">  3967	</span>	}
<span id="L3968" class="ln">  3968	</span>
<span id="L3969" class="ln">  3969	</span>	switch f := f.(type) {
<span id="L3970" class="ln">  3970	</span>	case *http2SettingsFrame:
<span id="L3971" class="ln">  3971	</span>		return sc.processSettings(f)
<span id="L3972" class="ln">  3972	</span>	case *http2MetaHeadersFrame:
<span id="L3973" class="ln">  3973	</span>		return sc.processHeaders(f)
<span id="L3974" class="ln">  3974	</span>	case *http2WindowUpdateFrame:
<span id="L3975" class="ln">  3975	</span>		return sc.processWindowUpdate(f)
<span id="L3976" class="ln">  3976	</span>	case *http2PingFrame:
<span id="L3977" class="ln">  3977	</span>		return sc.processPing(f)
<span id="L3978" class="ln">  3978	</span>	case *http2DataFrame:
<span id="L3979" class="ln">  3979	</span>		return sc.processData(f)
<span id="L3980" class="ln">  3980	</span>	case *http2RSTStreamFrame:
<span id="L3981" class="ln">  3981	</span>		return sc.processResetStream(f)
<span id="L3982" class="ln">  3982	</span>	case *http2PriorityFrame:
<span id="L3983" class="ln">  3983	</span>		return sc.processPriority(f)
<span id="L3984" class="ln">  3984	</span>	case *http2GoAwayFrame:
<span id="L3985" class="ln">  3985	</span>		return sc.processGoAway(f)
<span id="L3986" class="ln">  3986	</span>	case *http2PushPromiseFrame:
<span id="L3987" class="ln">  3987	</span>
<span id="L3988" class="ln">  3988	</span>		return http2ConnectionError(http2ErrCodeProtocol)
<span id="L3989" class="ln">  3989	</span>	default:
<span id="L3990" class="ln">  3990	</span>		sc.vlogf(&#34;http2: server ignoring frame: %v&#34;, f.Header())
<span id="L3991" class="ln">  3991	</span>		return nil
<span id="L3992" class="ln">  3992	</span>	}
<span id="L3993" class="ln">  3993	</span>}
<span id="L3994" class="ln">  3994	</span>
<span id="L3995" class="ln">  3995	</span>func (sc *http2serverConn) processPing(f *http2PingFrame) error {
<span id="L3996" class="ln">  3996	</span>	sc.serveG.check()
<span id="L3997" class="ln">  3997	</span>	if f.IsAck() {
<span id="L3998" class="ln">  3998	</span>
<span id="L3999" class="ln">  3999	</span>		return nil
<span id="L4000" class="ln">  4000	</span>	}
<span id="L4001" class="ln">  4001	</span>	if f.StreamID != 0 {
<span id="L4002" class="ln">  4002	</span>
<span id="L4003" class="ln">  4003	</span>		return http2ConnectionError(http2ErrCodeProtocol)
<span id="L4004" class="ln">  4004	</span>	}
<span id="L4005" class="ln">  4005	</span>	if sc.inGoAway &amp;&amp; sc.goAwayCode != http2ErrCodeNo {
<span id="L4006" class="ln">  4006	</span>		return nil
<span id="L4007" class="ln">  4007	</span>	}
<span id="L4008" class="ln">  4008	</span>	sc.writeFrame(http2FrameWriteRequest{write: http2writePingAck{f}})
<span id="L4009" class="ln">  4009	</span>	return nil
<span id="L4010" class="ln">  4010	</span>}
<span id="L4011" class="ln">  4011	</span>
<span id="L4012" class="ln">  4012	</span>func (sc *http2serverConn) processWindowUpdate(f *http2WindowUpdateFrame) error {
<span id="L4013" class="ln">  4013	</span>	sc.serveG.check()
<span id="L4014" class="ln">  4014	</span>	switch {
<span id="L4015" class="ln">  4015	</span>	case f.StreamID != 0:
<span id="L4016" class="ln">  4016	</span>		state, st := sc.state(f.StreamID)
<span id="L4017" class="ln">  4017	</span>		if state == http2stateIdle {
<span id="L4018" class="ln">  4018	</span>
<span id="L4019" class="ln">  4019	</span>			return http2ConnectionError(http2ErrCodeProtocol)
<span id="L4020" class="ln">  4020	</span>		}
<span id="L4021" class="ln">  4021	</span>		if st == nil {
<span id="L4022" class="ln">  4022	</span>
<span id="L4023" class="ln">  4023	</span>			return nil
<span id="L4024" class="ln">  4024	</span>		}
<span id="L4025" class="ln">  4025	</span>		if !st.flow.add(int32(f.Increment)) {
<span id="L4026" class="ln">  4026	</span>			return http2streamError(f.StreamID, http2ErrCodeFlowControl)
<span id="L4027" class="ln">  4027	</span>		}
<span id="L4028" class="ln">  4028	</span>	default:
<span id="L4029" class="ln">  4029	</span>		if !sc.flow.add(int32(f.Increment)) {
<span id="L4030" class="ln">  4030	</span>			return http2goAwayFlowError{}
<span id="L4031" class="ln">  4031	</span>		}
<span id="L4032" class="ln">  4032	</span>	}
<span id="L4033" class="ln">  4033	</span>	sc.scheduleFrameWrite()
<span id="L4034" class="ln">  4034	</span>	return nil
<span id="L4035" class="ln">  4035	</span>}
<span id="L4036" class="ln">  4036	</span>
<span id="L4037" class="ln">  4037	</span>func (sc *http2serverConn) processResetStream(f *http2RSTStreamFrame) error {
<span id="L4038" class="ln">  4038	</span>	sc.serveG.check()
<span id="L4039" class="ln">  4039	</span>
<span id="L4040" class="ln">  4040	</span>	state, st := sc.state(f.StreamID)
<span id="L4041" class="ln">  4041	</span>	if state == http2stateIdle {
<span id="L4042" class="ln">  4042	</span>
<span id="L4043" class="ln">  4043	</span>		return http2ConnectionError(http2ErrCodeProtocol)
<span id="L4044" class="ln">  4044	</span>	}
<span id="L4045" class="ln">  4045	</span>	if st != nil {
<span id="L4046" class="ln">  4046	</span>		st.cancelCtx()
<span id="L4047" class="ln">  4047	</span>		sc.closeStream(st, http2streamError(f.StreamID, f.ErrCode))
<span id="L4048" class="ln">  4048	</span>	}
<span id="L4049" class="ln">  4049	</span>	return nil
<span id="L4050" class="ln">  4050	</span>}
<span id="L4051" class="ln">  4051	</span>
<span id="L4052" class="ln">  4052	</span>func (sc *http2serverConn) closeStream(st *http2stream, err error) {
<span id="L4053" class="ln">  4053	</span>	sc.serveG.check()
<span id="L4054" class="ln">  4054	</span>	if st.state == http2stateIdle || st.state == http2stateClosed {
<span id="L4055" class="ln">  4055	</span>		panic(fmt.Sprintf(&#34;invariant; can&#39;t close stream in state %v&#34;, st.state))
<span id="L4056" class="ln">  4056	</span>	}
<span id="L4057" class="ln">  4057	</span>	st.state = http2stateClosed
<span id="L4058" class="ln">  4058	</span>	if st.isPushed() {
<span id="L4059" class="ln">  4059	</span>		sc.curPushedStreams--
<span id="L4060" class="ln">  4060	</span>	} else {
<span id="L4061" class="ln">  4061	</span>		sc.curClientStreams--
<span id="L4062" class="ln">  4062	</span>	}
<span id="L4063" class="ln">  4063	</span>	delete(sc.streams, st.id)
<span id="L4064" class="ln">  4064	</span>	if len(sc.streams) == 0 {
<span id="L4065" class="ln">  4065	</span>		sc.setConnState(StateIdle)
<span id="L4066" class="ln">  4066	</span>		if sc.srv.IdleTimeout != 0 {
<span id="L4067" class="ln">  4067	</span>			sc.idleTimer.Reset(sc.srv.IdleTimeout)
<span id="L4068" class="ln">  4068	</span>		}
<span id="L4069" class="ln">  4069	</span>		if http2h1ServerKeepAlivesDisabled(sc.hs) {
<span id="L4070" class="ln">  4070	</span>			sc.startGracefulShutdown()
<span id="L4071" class="ln">  4071	</span>		}
<span id="L4072" class="ln">  4072	</span>	}
<span id="L4073" class="ln">  4073	</span>	if p := st.body; p != nil {
<span id="L4074" class="ln">  4074	</span>
<span id="L4075" class="ln">  4075	</span>		sc.sendWindowUpdate(nil, p.Len())
<span id="L4076" class="ln">  4076	</span>
<span id="L4077" class="ln">  4077	</span>		p.CloseWithError(err)
<span id="L4078" class="ln">  4078	</span>	}
<span id="L4079" class="ln">  4079	</span>	st.cw.Close()
<span id="L4080" class="ln">  4080	</span>	sc.writeSched.CloseStream(st.id)
<span id="L4081" class="ln">  4081	</span>}
<span id="L4082" class="ln">  4082	</span>
<span id="L4083" class="ln">  4083	</span>func (sc *http2serverConn) processSettings(f *http2SettingsFrame) error {
<span id="L4084" class="ln">  4084	</span>	sc.serveG.check()
<span id="L4085" class="ln">  4085	</span>	if f.IsAck() {
<span id="L4086" class="ln">  4086	</span>		sc.unackedSettings--
<span id="L4087" class="ln">  4087	</span>		if sc.unackedSettings &lt; 0 {
<span id="L4088" class="ln">  4088	</span>
<span id="L4089" class="ln">  4089	</span>			return http2ConnectionError(http2ErrCodeProtocol)
<span id="L4090" class="ln">  4090	</span>		}
<span id="L4091" class="ln">  4091	</span>		return nil
<span id="L4092" class="ln">  4092	</span>	}
<span id="L4093" class="ln">  4093	</span>	if err := f.ForeachSetting(sc.processSetting); err != nil {
<span id="L4094" class="ln">  4094	</span>		return err
<span id="L4095" class="ln">  4095	</span>	}
<span id="L4096" class="ln">  4096	</span>	sc.needToSendSettingsAck = true
<span id="L4097" class="ln">  4097	</span>	sc.scheduleFrameWrite()
<span id="L4098" class="ln">  4098	</span>	return nil
<span id="L4099" class="ln">  4099	</span>}
<span id="L4100" class="ln">  4100	</span>
<span id="L4101" class="ln">  4101	</span>func (sc *http2serverConn) processSetting(s http2Setting) error {
<span id="L4102" class="ln">  4102	</span>	sc.serveG.check()
<span id="L4103" class="ln">  4103	</span>	if err := s.Valid(); err != nil {
<span id="L4104" class="ln">  4104	</span>		return err
<span id="L4105" class="ln">  4105	</span>	}
<span id="L4106" class="ln">  4106	</span>	if http2VerboseLogs {
<span id="L4107" class="ln">  4107	</span>		sc.vlogf(&#34;http2: server processing setting %v&#34;, s)
<span id="L4108" class="ln">  4108	</span>	}
<span id="L4109" class="ln">  4109	</span>	switch s.ID {
<span id="L4110" class="ln">  4110	</span>	case http2SettingHeaderTableSize:
<span id="L4111" class="ln">  4111	</span>		sc.headerTableSize = s.Val
<span id="L4112" class="ln">  4112	</span>		sc.hpackEncoder.SetMaxDynamicTableSize(s.Val)
<span id="L4113" class="ln">  4113	</span>	case http2SettingEnablePush:
<span id="L4114" class="ln">  4114	</span>		sc.pushEnabled = s.Val != 0
<span id="L4115" class="ln">  4115	</span>	case http2SettingMaxConcurrentStreams:
<span id="L4116" class="ln">  4116	</span>		sc.clientMaxStreams = s.Val
<span id="L4117" class="ln">  4117	</span>	case http2SettingInitialWindowSize:
<span id="L4118" class="ln">  4118	</span>		return sc.processSettingInitialWindowSize(s.Val)
<span id="L4119" class="ln">  4119	</span>	case http2SettingMaxFrameSize:
<span id="L4120" class="ln">  4120	</span>		sc.maxFrameSize = int32(s.Val)
<span id="L4121" class="ln">  4121	</span>	case http2SettingMaxHeaderListSize:
<span id="L4122" class="ln">  4122	</span>		sc.peerMaxHeaderListSize = s.Val
<span id="L4123" class="ln">  4123	</span>	default:
<span id="L4124" class="ln">  4124	</span>
<span id="L4125" class="ln">  4125	</span>		if http2VerboseLogs {
<span id="L4126" class="ln">  4126	</span>			sc.vlogf(&#34;http2: server ignoring unknown setting %v&#34;, s)
<span id="L4127" class="ln">  4127	</span>		}
<span id="L4128" class="ln">  4128	</span>	}
<span id="L4129" class="ln">  4129	</span>	return nil
<span id="L4130" class="ln">  4130	</span>}
<span id="L4131" class="ln">  4131	</span>
<span id="L4132" class="ln">  4132	</span>func (sc *http2serverConn) processSettingInitialWindowSize(val uint32) error {
<span id="L4133" class="ln">  4133	</span>	sc.serveG.check()
<span id="L4134" class="ln">  4134	</span>
<span id="L4135" class="ln">  4135	</span>	old := sc.initialWindowSize
<span id="L4136" class="ln">  4136	</span>	sc.initialWindowSize = int32(val)
<span id="L4137" class="ln">  4137	</span>	growth := sc.initialWindowSize - old
<span id="L4138" class="ln">  4138	</span>	for _, st := range sc.streams {
<span id="L4139" class="ln">  4139	</span>		if !st.flow.add(growth) {
<span id="L4140" class="ln">  4140	</span>
<span id="L4141" class="ln">  4141	</span>			return http2ConnectionError(http2ErrCodeFlowControl)
<span id="L4142" class="ln">  4142	</span>		}
<span id="L4143" class="ln">  4143	</span>	}
<span id="L4144" class="ln">  4144	</span>	return nil
<span id="L4145" class="ln">  4145	</span>}
<span id="L4146" class="ln">  4146	</span>
<span id="L4147" class="ln">  4147	</span>func (sc *http2serverConn) processData(f *http2DataFrame) error {
<span id="L4148" class="ln">  4148	</span>	sc.serveG.check()
<span id="L4149" class="ln">  4149	</span>	if sc.inGoAway &amp;&amp; sc.goAwayCode != http2ErrCodeNo {
<span id="L4150" class="ln">  4150	</span>		return nil
<span id="L4151" class="ln">  4151	</span>	}
<span id="L4152" class="ln">  4152	</span>	data := f.Data()
<span id="L4153" class="ln">  4153	</span>
<span id="L4154" class="ln">  4154	</span>	id := f.Header().StreamID
<span id="L4155" class="ln">  4155	</span>	state, st := sc.state(id)
<span id="L4156" class="ln">  4156	</span>	if id == 0 || state == http2stateIdle {
<span id="L4157" class="ln">  4157	</span>
<span id="L4158" class="ln">  4158	</span>		return http2ConnectionError(http2ErrCodeProtocol)
<span id="L4159" class="ln">  4159	</span>	}
<span id="L4160" class="ln">  4160	</span>	if st == nil || state != http2stateOpen || st.gotTrailerHeader || st.resetQueued {
<span id="L4161" class="ln">  4161	</span>
<span id="L4162" class="ln">  4162	</span>		if sc.inflow.available() &lt; int32(f.Length) {
<span id="L4163" class="ln">  4163	</span>			return http2streamError(id, http2ErrCodeFlowControl)
<span id="L4164" class="ln">  4164	</span>		}
<span id="L4165" class="ln">  4165	</span>
<span id="L4166" class="ln">  4166	</span>		sc.inflow.take(int32(f.Length))
<span id="L4167" class="ln">  4167	</span>		sc.sendWindowUpdate(nil, int(f.Length))
<span id="L4168" class="ln">  4168	</span>
<span id="L4169" class="ln">  4169	</span>		if st != nil &amp;&amp; st.resetQueued {
<span id="L4170" class="ln">  4170	</span>
<span id="L4171" class="ln">  4171	</span>			return nil
<span id="L4172" class="ln">  4172	</span>		}
<span id="L4173" class="ln">  4173	</span>		return http2streamError(id, http2ErrCodeStreamClosed)
<span id="L4174" class="ln">  4174	</span>	}
<span id="L4175" class="ln">  4175	</span>	if st.body == nil {
<span id="L4176" class="ln">  4176	</span>		panic(&#34;internal error: should have a body in this state&#34;)
<span id="L4177" class="ln">  4177	</span>	}
<span id="L4178" class="ln">  4178	</span>
<span id="L4179" class="ln">  4179	</span>	if st.declBodyBytes != -1 &amp;&amp; st.bodyBytes+int64(len(data)) &gt; st.declBodyBytes {
<span id="L4180" class="ln">  4180	</span>		st.body.CloseWithError(fmt.Errorf(&#34;sender tried to send more than declared Content-Length of %d bytes&#34;, st.declBodyBytes))
<span id="L4181" class="ln">  4181	</span>		return http2streamError(id, http2ErrCodeStreamClosed)
<span id="L4182" class="ln">  4182	</span>	}
<span id="L4183" class="ln">  4183	</span>	if f.Length &gt; 0 {
<span id="L4184" class="ln">  4184	</span>
<span id="L4185" class="ln">  4185	</span>		if st.inflow.available() &lt; int32(f.Length) {
<span id="L4186" class="ln">  4186	</span>			return http2streamError(id, http2ErrCodeFlowControl)
<span id="L4187" class="ln">  4187	</span>		}
<span id="L4188" class="ln">  4188	</span>		st.inflow.take(int32(f.Length))
<span id="L4189" class="ln">  4189	</span>
<span id="L4190" class="ln">  4190	</span>		if len(data) &gt; 0 {
<span id="L4191" class="ln">  4191	</span>			wrote, err := st.body.Write(data)
<span id="L4192" class="ln">  4192	</span>			if err != nil {
<span id="L4193" class="ln">  4193	</span>				return http2streamError(id, http2ErrCodeStreamClosed)
<span id="L4194" class="ln">  4194	</span>			}
<span id="L4195" class="ln">  4195	</span>			if wrote != len(data) {
<span id="L4196" class="ln">  4196	</span>				panic(&#34;internal error: bad Writer&#34;)
<span id="L4197" class="ln">  4197	</span>			}
<span id="L4198" class="ln">  4198	</span>			st.bodyBytes += int64(len(data))
<span id="L4199" class="ln">  4199	</span>		}
<span id="L4200" class="ln">  4200	</span>
<span id="L4201" class="ln">  4201	</span>		if pad := int32(f.Length) - int32(len(data)); pad &gt; 0 {
<span id="L4202" class="ln">  4202	</span>			sc.sendWindowUpdate32(nil, pad)
<span id="L4203" class="ln">  4203	</span>			sc.sendWindowUpdate32(st, pad)
<span id="L4204" class="ln">  4204	</span>		}
<span id="L4205" class="ln">  4205	</span>	}
<span id="L4206" class="ln">  4206	</span>	if f.StreamEnded() {
<span id="L4207" class="ln">  4207	</span>		st.endStream()
<span id="L4208" class="ln">  4208	</span>	}
<span id="L4209" class="ln">  4209	</span>	return nil
<span id="L4210" class="ln">  4210	</span>}
<span id="L4211" class="ln">  4211	</span>
<span id="L4212" class="ln">  4212	</span>func (sc *http2serverConn) processGoAway(f *http2GoAwayFrame) error {
<span id="L4213" class="ln">  4213	</span>	sc.serveG.check()
<span id="L4214" class="ln">  4214	</span>	if f.ErrCode != http2ErrCodeNo {
<span id="L4215" class="ln">  4215	</span>		sc.logf(&#34;http2: received GOAWAY %+v, starting graceful shutdown&#34;, f)
<span id="L4216" class="ln">  4216	</span>	} else {
<span id="L4217" class="ln">  4217	</span>		sc.vlogf(&#34;http2: received GOAWAY %+v, starting graceful shutdown&#34;, f)
<span id="L4218" class="ln">  4218	</span>	}
<span id="L4219" class="ln">  4219	</span>	sc.startGracefulShutdown()
<span id="L4220" class="ln">  4220	</span>
<span id="L4221" class="ln">  4221	</span>	sc.pushEnabled = false
<span id="L4222" class="ln">  4222	</span>	return nil
<span id="L4223" class="ln">  4223	</span>}
<span id="L4224" class="ln">  4224	</span>
<span id="L4225" class="ln">  4225	</span><span class="comment">// isPushed reports whether the stream is server-initiated.</span>
<span id="L4226" class="ln">  4226	</span>func (st *http2stream) isPushed() bool {
<span id="L4227" class="ln">  4227	</span>	return st.id%2 == 0
<span id="L4228" class="ln">  4228	</span>}
<span id="L4229" class="ln">  4229	</span>
<span id="L4230" class="ln">  4230	</span><span class="comment">// endStream closes a Request.Body&#39;s pipe. It is called when a DATA</span>
<span id="L4231" class="ln">  4231	</span><span class="comment">// frame says a request body is over (or after trailers).</span>
<span id="L4232" class="ln">  4232	</span>func (st *http2stream) endStream() {
<span id="L4233" class="ln">  4233	</span>	sc := st.sc
<span id="L4234" class="ln">  4234	</span>	sc.serveG.check()
<span id="L4235" class="ln">  4235	</span>
<span id="L4236" class="ln">  4236	</span>	if st.declBodyBytes != -1 &amp;&amp; st.declBodyBytes != st.bodyBytes {
<span id="L4237" class="ln">  4237	</span>		st.body.CloseWithError(fmt.Errorf(&#34;request declared a Content-Length of %d but only wrote %d bytes&#34;,
<span id="L4238" class="ln">  4238	</span>			st.declBodyBytes, st.bodyBytes))
<span id="L4239" class="ln">  4239	</span>	} else {
<span id="L4240" class="ln">  4240	</span>		st.body.closeWithErrorAndCode(io.EOF, st.copyTrailersToHandlerRequest)
<span id="L4241" class="ln">  4241	</span>		st.body.CloseWithError(io.EOF)
<span id="L4242" class="ln">  4242	</span>	}
<span id="L4243" class="ln">  4243	</span>	st.state = http2stateHalfClosedRemote
<span id="L4244" class="ln">  4244	</span>}
<span id="L4245" class="ln">  4245	</span>
<span id="L4246" class="ln">  4246	</span><span class="comment">// copyTrailersToHandlerRequest is run in the Handler&#39;s goroutine in</span>
<span id="L4247" class="ln">  4247	</span><span class="comment">// its Request.Body.Read just before it gets io.EOF.</span>
<span id="L4248" class="ln">  4248	</span>func (st *http2stream) copyTrailersToHandlerRequest() {
<span id="L4249" class="ln">  4249	</span>	for k, vv := range st.trailer {
<span id="L4250" class="ln">  4250	</span>		if _, ok := st.reqTrailer[k]; ok {
<span id="L4251" class="ln">  4251	</span>
<span id="L4252" class="ln">  4252	</span>			st.reqTrailer[k] = vv
<span id="L4253" class="ln">  4253	</span>		}
<span id="L4254" class="ln">  4254	</span>	}
<span id="L4255" class="ln">  4255	</span>}
<span id="L4256" class="ln">  4256	</span>
<span id="L4257" class="ln">  4257	</span>func (sc *http2serverConn) processHeaders(f *http2MetaHeadersFrame) error {
<span id="L4258" class="ln">  4258	</span>	sc.serveG.check()
<span id="L4259" class="ln">  4259	</span>	id := f.StreamID
<span id="L4260" class="ln">  4260	</span>	if sc.inGoAway {
<span id="L4261" class="ln">  4261	</span>
<span id="L4262" class="ln">  4262	</span>		return nil
<span id="L4263" class="ln">  4263	</span>	}
<span id="L4264" class="ln">  4264	</span>
<span id="L4265" class="ln">  4265	</span>	if id%2 != 1 {
<span id="L4266" class="ln">  4266	</span>		return http2ConnectionError(http2ErrCodeProtocol)
<span id="L4267" class="ln">  4267	</span>	}
<span id="L4268" class="ln">  4268	</span>
<span id="L4269" class="ln">  4269	</span>	if st := sc.streams[f.StreamID]; st != nil {
<span id="L4270" class="ln">  4270	</span>		if st.resetQueued {
<span id="L4271" class="ln">  4271	</span>
<span id="L4272" class="ln">  4272	</span>			return nil
<span id="L4273" class="ln">  4273	</span>		}
<span id="L4274" class="ln">  4274	</span>		return st.processTrailerHeaders(f)
<span id="L4275" class="ln">  4275	</span>	}
<span id="L4276" class="ln">  4276	</span>
<span id="L4277" class="ln">  4277	</span>	if id &lt;= sc.maxClientStreamID {
<span id="L4278" class="ln">  4278	</span>		return http2ConnectionError(http2ErrCodeProtocol)
<span id="L4279" class="ln">  4279	</span>	}
<span id="L4280" class="ln">  4280	</span>	sc.maxClientStreamID = id
<span id="L4281" class="ln">  4281	</span>
<span id="L4282" class="ln">  4282	</span>	if sc.idleTimer != nil {
<span id="L4283" class="ln">  4283	</span>		sc.idleTimer.Stop()
<span id="L4284" class="ln">  4284	</span>	}
<span id="L4285" class="ln">  4285	</span>
<span id="L4286" class="ln">  4286	</span>	if sc.curClientStreams+1 &gt; sc.advMaxStreams {
<span id="L4287" class="ln">  4287	</span>		if sc.unackedSettings == 0 {
<span id="L4288" class="ln">  4288	</span>
<span id="L4289" class="ln">  4289	</span>			return http2streamError(id, http2ErrCodeProtocol)
<span id="L4290" class="ln">  4290	</span>		}
<span id="L4291" class="ln">  4291	</span>
<span id="L4292" class="ln">  4292	</span>		return http2streamError(id, http2ErrCodeRefusedStream)
<span id="L4293" class="ln">  4293	</span>	}
<span id="L4294" class="ln">  4294	</span>
<span id="L4295" class="ln">  4295	</span>	initialState := http2stateOpen
<span id="L4296" class="ln">  4296	</span>	if f.StreamEnded() {
<span id="L4297" class="ln">  4297	</span>		initialState = http2stateHalfClosedRemote
<span id="L4298" class="ln">  4298	</span>	}
<span id="L4299" class="ln">  4299	</span>	st := sc.newStream(id, 0, initialState)
<span id="L4300" class="ln">  4300	</span>
<span id="L4301" class="ln">  4301	</span>	if f.HasPriority() {
<span id="L4302" class="ln">  4302	</span>		if err := http2checkPriority(f.StreamID, f.Priority); err != nil {
<span id="L4303" class="ln">  4303	</span>			return err
<span id="L4304" class="ln">  4304	</span>		}
<span id="L4305" class="ln">  4305	</span>		sc.writeSched.AdjustStream(st.id, f.Priority)
<span id="L4306" class="ln">  4306	</span>	}
<span id="L4307" class="ln">  4307	</span>
<span id="L4308" class="ln">  4308	</span>	rw, req, err := sc.newWriterAndRequest(st, f)
<span id="L4309" class="ln">  4309	</span>	if err != nil {
<span id="L4310" class="ln">  4310	</span>		return err
<span id="L4311" class="ln">  4311	</span>	}
<span id="L4312" class="ln">  4312	</span>	st.reqTrailer = req.Trailer
<span id="L4313" class="ln">  4313	</span>	if st.reqTrailer != nil {
<span id="L4314" class="ln">  4314	</span>		st.trailer = make(Header)
<span id="L4315" class="ln">  4315	</span>	}
<span id="L4316" class="ln">  4316	</span>	st.body = req.Body.(*http2requestBody).pipe
<span id="L4317" class="ln">  4317	</span>	st.declBodyBytes = req.ContentLength
<span id="L4318" class="ln">  4318	</span>
<span id="L4319" class="ln">  4319	</span>	handler := sc.handler.ServeHTTP
<span id="L4320" class="ln">  4320	</span>	if f.Truncated {
<span id="L4321" class="ln">  4321	</span>
<span id="L4322" class="ln">  4322	</span>		handler = http2handleHeaderListTooLong
<span id="L4323" class="ln">  4323	</span>	} else if err := http2checkValidHTTP2RequestHeaders(req.Header); err != nil {
<span id="L4324" class="ln">  4324	</span>		handler = http2new400Handler(err)
<span id="L4325" class="ln">  4325	</span>	}
<span id="L4326" class="ln">  4326	</span>
<span id="L4327" class="ln">  4327	</span>	if sc.hs.ReadTimeout != 0 {
<span id="L4328" class="ln">  4328	</span>		sc.conn.SetReadDeadline(time.Time{})
<span id="L4329" class="ln">  4329	</span>	}
<span id="L4330" class="ln">  4330	</span>
<span id="L4331" class="ln">  4331	</span>	go sc.runHandler(rw, req, handler)
<span id="L4332" class="ln">  4332	</span>	return nil
<span id="L4333" class="ln">  4333	</span>}
<span id="L4334" class="ln">  4334	</span>
<span id="L4335" class="ln">  4335	</span>func (st *http2stream) processTrailerHeaders(f *http2MetaHeadersFrame) error {
<span id="L4336" class="ln">  4336	</span>	sc := st.sc
<span id="L4337" class="ln">  4337	</span>	sc.serveG.check()
<span id="L4338" class="ln">  4338	</span>	if st.gotTrailerHeader {
<span id="L4339" class="ln">  4339	</span>		return http2ConnectionError(http2ErrCodeProtocol)
<span id="L4340" class="ln">  4340	</span>	}
<span id="L4341" class="ln">  4341	</span>	st.gotTrailerHeader = true
<span id="L4342" class="ln">  4342	</span>	if !f.StreamEnded() {
<span id="L4343" class="ln">  4343	</span>		return http2streamError(st.id, http2ErrCodeProtocol)
<span id="L4344" class="ln">  4344	</span>	}
<span id="L4345" class="ln">  4345	</span>
<span id="L4346" class="ln">  4346	</span>	if len(f.PseudoFields()) &gt; 0 {
<span id="L4347" class="ln">  4347	</span>		return http2streamError(st.id, http2ErrCodeProtocol)
<span id="L4348" class="ln">  4348	</span>	}
<span id="L4349" class="ln">  4349	</span>	if st.trailer != nil {
<span id="L4350" class="ln">  4350	</span>		for _, hf := range f.RegularFields() {
<span id="L4351" class="ln">  4351	</span>			key := sc.canonicalHeader(hf.Name)
<span id="L4352" class="ln">  4352	</span>			if !http2ValidTrailerHeader(key) {
<span id="L4353" class="ln">  4353	</span>
<span id="L4354" class="ln">  4354	</span>				return http2streamError(st.id, http2ErrCodeProtocol)
<span id="L4355" class="ln">  4355	</span>			}
<span id="L4356" class="ln">  4356	</span>			st.trailer[key] = append(st.trailer[key], hf.Value)
<span id="L4357" class="ln">  4357	</span>		}
<span id="L4358" class="ln">  4358	</span>	}
<span id="L4359" class="ln">  4359	</span>	st.endStream()
<span id="L4360" class="ln">  4360	</span>	return nil
<span id="L4361" class="ln">  4361	</span>}
<span id="L4362" class="ln">  4362	</span>
<span id="L4363" class="ln">  4363	</span>func http2checkPriority(streamID uint32, p http2PriorityParam) error {
<span id="L4364" class="ln">  4364	</span>	if streamID == p.StreamDep {
<span id="L4365" class="ln">  4365	</span>
<span id="L4366" class="ln">  4366	</span>		return http2streamError(streamID, http2ErrCodeProtocol)
<span id="L4367" class="ln">  4367	</span>	}
<span id="L4368" class="ln">  4368	</span>	return nil
<span id="L4369" class="ln">  4369	</span>}
<span id="L4370" class="ln">  4370	</span>
<span id="L4371" class="ln">  4371	</span>func (sc *http2serverConn) processPriority(f *http2PriorityFrame) error {
<span id="L4372" class="ln">  4372	</span>	if sc.inGoAway {
<span id="L4373" class="ln">  4373	</span>		return nil
<span id="L4374" class="ln">  4374	</span>	}
<span id="L4375" class="ln">  4375	</span>	if err := http2checkPriority(f.StreamID, f.http2PriorityParam); err != nil {
<span id="L4376" class="ln">  4376	</span>		return err
<span id="L4377" class="ln">  4377	</span>	}
<span id="L4378" class="ln">  4378	</span>	sc.writeSched.AdjustStream(f.StreamID, f.http2PriorityParam)
<span id="L4379" class="ln">  4379	</span>	return nil
<span id="L4380" class="ln">  4380	</span>}
<span id="L4381" class="ln">  4381	</span>
<span id="L4382" class="ln">  4382	</span>func (sc *http2serverConn) newStream(id, pusherID uint32, state http2streamState) *http2stream {
<span id="L4383" class="ln">  4383	</span>	sc.serveG.check()
<span id="L4384" class="ln">  4384	</span>	if id == 0 {
<span id="L4385" class="ln">  4385	</span>		panic(&#34;internal error: cannot create stream with id 0&#34;)
<span id="L4386" class="ln">  4386	</span>	}
<span id="L4387" class="ln">  4387	</span>
<span id="L4388" class="ln">  4388	</span>	ctx, cancelCtx := http2contextWithCancel(sc.baseCtx)
<span id="L4389" class="ln">  4389	</span>	st := &amp;http2stream{
<span id="L4390" class="ln">  4390	</span>		sc:        sc,
<span id="L4391" class="ln">  4391	</span>		id:        id,
<span id="L4392" class="ln">  4392	</span>		state:     state,
<span id="L4393" class="ln">  4393	</span>		ctx:       ctx,
<span id="L4394" class="ln">  4394	</span>		cancelCtx: cancelCtx,
<span id="L4395" class="ln">  4395	</span>	}
<span id="L4396" class="ln">  4396	</span>	st.cw.Init()
<span id="L4397" class="ln">  4397	</span>	st.flow.conn = &amp;sc.flow
<span id="L4398" class="ln">  4398	</span>	st.flow.add(sc.initialWindowSize)
<span id="L4399" class="ln">  4399	</span>	st.inflow.conn = &amp;sc.inflow
<span id="L4400" class="ln">  4400	</span>	st.inflow.add(http2initialWindowSize)
<span id="L4401" class="ln">  4401	</span>
<span id="L4402" class="ln">  4402	</span>	sc.streams[id] = st
<span id="L4403" class="ln">  4403	</span>	sc.writeSched.OpenStream(st.id, http2OpenStreamOptions{PusherID: pusherID})
<span id="L4404" class="ln">  4404	</span>	if st.isPushed() {
<span id="L4405" class="ln">  4405	</span>		sc.curPushedStreams++
<span id="L4406" class="ln">  4406	</span>	} else {
<span id="L4407" class="ln">  4407	</span>		sc.curClientStreams++
<span id="L4408" class="ln">  4408	</span>	}
<span id="L4409" class="ln">  4409	</span>	if sc.curOpenStreams() == 1 {
<span id="L4410" class="ln">  4410	</span>		sc.setConnState(StateActive)
<span id="L4411" class="ln">  4411	</span>	}
<span id="L4412" class="ln">  4412	</span>
<span id="L4413" class="ln">  4413	</span>	return st
<span id="L4414" class="ln">  4414	</span>}
<span id="L4415" class="ln">  4415	</span>
<span id="L4416" class="ln">  4416	</span>func (sc *http2serverConn) newWriterAndRequest(st *http2stream, f *http2MetaHeadersFrame) (*http2responseWriter, *Request, error) {
<span id="L4417" class="ln">  4417	</span>	sc.serveG.check()
<span id="L4418" class="ln">  4418	</span>
<span id="L4419" class="ln">  4419	</span>	rp := http2requestParam{
<span id="L4420" class="ln">  4420	</span>		method:    f.PseudoValue(&#34;method&#34;),
<span id="L4421" class="ln">  4421	</span>		scheme:    f.PseudoValue(&#34;scheme&#34;),
<span id="L4422" class="ln">  4422	</span>		authority: f.PseudoValue(&#34;authority&#34;),
<span id="L4423" class="ln">  4423	</span>		path:      f.PseudoValue(&#34;path&#34;),
<span id="L4424" class="ln">  4424	</span>	}
<span id="L4425" class="ln">  4425	</span>
<span id="L4426" class="ln">  4426	</span>	isConnect := rp.method == &#34;CONNECT&#34;
<span id="L4427" class="ln">  4427	</span>	if isConnect {
<span id="L4428" class="ln">  4428	</span>		if rp.path != &#34;&#34; || rp.scheme != &#34;&#34; || rp.authority == &#34;&#34; {
<span id="L4429" class="ln">  4429	</span>			return nil, nil, http2streamError(f.StreamID, http2ErrCodeProtocol)
<span id="L4430" class="ln">  4430	</span>		}
<span id="L4431" class="ln">  4431	</span>	} else if rp.method == &#34;&#34; || rp.path == &#34;&#34; || (rp.scheme != &#34;https&#34; &amp;&amp; rp.scheme != &#34;http&#34;) {
<span id="L4432" class="ln">  4432	</span>
<span id="L4433" class="ln">  4433	</span>		return nil, nil, http2streamError(f.StreamID, http2ErrCodeProtocol)
<span id="L4434" class="ln">  4434	</span>	}
<span id="L4435" class="ln">  4435	</span>
<span id="L4436" class="ln">  4436	</span>	bodyOpen := !f.StreamEnded()
<span id="L4437" class="ln">  4437	</span>	if rp.method == &#34;HEAD&#34; &amp;&amp; bodyOpen {
<span id="L4438" class="ln">  4438	</span>
<span id="L4439" class="ln">  4439	</span>		return nil, nil, http2streamError(f.StreamID, http2ErrCodeProtocol)
<span id="L4440" class="ln">  4440	</span>	}
<span id="L4441" class="ln">  4441	</span>
<span id="L4442" class="ln">  4442	</span>	rp.header = make(Header)
<span id="L4443" class="ln">  4443	</span>	for _, hf := range f.RegularFields() {
<span id="L4444" class="ln">  4444	</span>		rp.header.Add(sc.canonicalHeader(hf.Name), hf.Value)
<span id="L4445" class="ln">  4445	</span>	}
<span id="L4446" class="ln">  4446	</span>	if rp.authority == &#34;&#34; {
<span id="L4447" class="ln">  4447	</span>		rp.authority = rp.header.Get(&#34;Host&#34;)
<span id="L4448" class="ln">  4448	</span>	}
<span id="L4449" class="ln">  4449	</span>
<span id="L4450" class="ln">  4450	</span>	rw, req, err := sc.newWriterAndRequestNoBody(st, rp)
<span id="L4451" class="ln">  4451	</span>	if err != nil {
<span id="L4452" class="ln">  4452	</span>		return nil, nil, err
<span id="L4453" class="ln">  4453	</span>	}
<span id="L4454" class="ln">  4454	</span>	if bodyOpen {
<span id="L4455" class="ln">  4455	</span>		st.reqBuf = http2getRequestBodyBuf()
<span id="L4456" class="ln">  4456	</span>		req.Body.(*http2requestBody).pipe = &amp;http2pipe{
<span id="L4457" class="ln">  4457	</span>			b: &amp;http2fixedBuffer{buf: st.reqBuf},
<span id="L4458" class="ln">  4458	</span>		}
<span id="L4459" class="ln">  4459	</span>
<span id="L4460" class="ln">  4460	</span>		if vv, ok := rp.header[&#34;Content-Length&#34;]; ok {
<span id="L4461" class="ln">  4461	</span>			req.ContentLength, _ = strconv.ParseInt(vv[0], 10, 64)
<span id="L4462" class="ln">  4462	</span>		} else {
<span id="L4463" class="ln">  4463	</span>			req.ContentLength = -1
<span id="L4464" class="ln">  4464	</span>		}
<span id="L4465" class="ln">  4465	</span>	}
<span id="L4466" class="ln">  4466	</span>	return rw, req, nil
<span id="L4467" class="ln">  4467	</span>}
<span id="L4468" class="ln">  4468	</span>
<span id="L4469" class="ln">  4469	</span>type http2requestParam struct {
<span id="L4470" class="ln">  4470	</span>	method                  string
<span id="L4471" class="ln">  4471	</span>	scheme, authority, path string
<span id="L4472" class="ln">  4472	</span>	header                  Header
<span id="L4473" class="ln">  4473	</span>}
<span id="L4474" class="ln">  4474	</span>
<span id="L4475" class="ln">  4475	</span>func (sc *http2serverConn) newWriterAndRequestNoBody(st *http2stream, rp http2requestParam) (*http2responseWriter, *Request, error) {
<span id="L4476" class="ln">  4476	</span>	sc.serveG.check()
<span id="L4477" class="ln">  4477	</span>
<span id="L4478" class="ln">  4478	</span>	var tlsState *tls.ConnectionState <span class="comment">// nil if not scheme https</span>
<span id="L4479" class="ln">  4479	</span>	if rp.scheme == &#34;https&#34; {
<span id="L4480" class="ln">  4480	</span>		tlsState = sc.tlsState
<span id="L4481" class="ln">  4481	</span>	}
<span id="L4482" class="ln">  4482	</span>
<span id="L4483" class="ln">  4483	</span>	needsContinue := rp.header.Get(&#34;Expect&#34;) == &#34;100-continue&#34;
<span id="L4484" class="ln">  4484	</span>	if needsContinue {
<span id="L4485" class="ln">  4485	</span>		rp.header.Del(&#34;Expect&#34;)
<span id="L4486" class="ln">  4486	</span>	}
<span id="L4487" class="ln">  4487	</span>
<span id="L4488" class="ln">  4488	</span>	if cookies := rp.header[&#34;Cookie&#34;]; len(cookies) &gt; 1 {
<span id="L4489" class="ln">  4489	</span>		rp.header.Set(&#34;Cookie&#34;, strings.Join(cookies, &#34;; &#34;))
<span id="L4490" class="ln">  4490	</span>	}
<span id="L4491" class="ln">  4491	</span>
<span id="L4492" class="ln">  4492	</span>	<span class="comment">// Setup Trailers</span>
<span id="L4493" class="ln">  4493	</span>	var trailer Header
<span id="L4494" class="ln">  4494	</span>	for _, v := range rp.header[&#34;Trailer&#34;] {
<span id="L4495" class="ln">  4495	</span>		for _, key := range strings.Split(v, &#34;,&#34;) {
<span id="L4496" class="ln">  4496	</span>			key = CanonicalHeaderKey(strings.TrimSpace(key))
<span id="L4497" class="ln">  4497	</span>			switch key {
<span id="L4498" class="ln">  4498	</span>			case &#34;Transfer-Encoding&#34;, &#34;Trailer&#34;, &#34;Content-Length&#34;:
<span id="L4499" class="ln">  4499	</span>
<span id="L4500" class="ln">  4500	</span>			default:
<span id="L4501" class="ln">  4501	</span>				if trailer == nil {
<span id="L4502" class="ln">  4502	</span>					trailer = make(Header)
<span id="L4503" class="ln">  4503	</span>				}
<span id="L4504" class="ln">  4504	</span>				trailer[key] = nil
<span id="L4505" class="ln">  4505	</span>			}
<span id="L4506" class="ln">  4506	</span>		}
<span id="L4507" class="ln">  4507	</span>	}
<span id="L4508" class="ln">  4508	</span>	delete(rp.header, &#34;Trailer&#34;)
<span id="L4509" class="ln">  4509	</span>
<span id="L4510" class="ln">  4510	</span>	var url_ *url.URL
<span id="L4511" class="ln">  4511	</span>	var requestURI string
<span id="L4512" class="ln">  4512	</span>	if rp.method == &#34;CONNECT&#34; {
<span id="L4513" class="ln">  4513	</span>		url_ = &amp;url.URL{Host: rp.authority}
<span id="L4514" class="ln">  4514	</span>		requestURI = rp.authority
<span id="L4515" class="ln">  4515	</span>	} else {
<span id="L4516" class="ln">  4516	</span>		var err error
<span id="L4517" class="ln">  4517	</span>		url_, err = url.ParseRequestURI(rp.path)
<span id="L4518" class="ln">  4518	</span>		if err != nil {
<span id="L4519" class="ln">  4519	</span>			return nil, nil, http2streamError(st.id, http2ErrCodeProtocol)
<span id="L4520" class="ln">  4520	</span>		}
<span id="L4521" class="ln">  4521	</span>		requestURI = rp.path
<span id="L4522" class="ln">  4522	</span>	}
<span id="L4523" class="ln">  4523	</span>
<span id="L4524" class="ln">  4524	</span>	body := &amp;http2requestBody{
<span id="L4525" class="ln">  4525	</span>		conn:          sc,
<span id="L4526" class="ln">  4526	</span>		stream:        st,
<span id="L4527" class="ln">  4527	</span>		needsContinue: needsContinue,
<span id="L4528" class="ln">  4528	</span>	}
<span id="L4529" class="ln">  4529	</span>	req := &amp;Request{
<span id="L4530" class="ln">  4530	</span>		Method:     rp.method,
<span id="L4531" class="ln">  4531	</span>		URL:        url_,
<span id="L4532" class="ln">  4532	</span>		RemoteAddr: sc.remoteAddrStr,
<span id="L4533" class="ln">  4533	</span>		Header:     rp.header,
<span id="L4534" class="ln">  4534	</span>		RequestURI: requestURI,
<span id="L4535" class="ln">  4535	</span>		Proto:      &#34;HTTP/2.0&#34;,
<span id="L4536" class="ln">  4536	</span>		ProtoMajor: 2,
<span id="L4537" class="ln">  4537	</span>		ProtoMinor: 0,
<span id="L4538" class="ln">  4538	</span>		TLS:        tlsState,
<span id="L4539" class="ln">  4539	</span>		Host:       rp.authority,
<span id="L4540" class="ln">  4540	</span>		Body:       body,
<span id="L4541" class="ln">  4541	</span>		Trailer:    trailer,
<span id="L4542" class="ln">  4542	</span>	}
<span id="L4543" class="ln">  4543	</span>	req = http2requestWithContext(req, st.ctx)
<span id="L4544" class="ln">  4544	</span>
<span id="L4545" class="ln">  4545	</span>	rws := http2responseWriterStatePool.Get().(*http2responseWriterState)
<span id="L4546" class="ln">  4546	</span>	bwSave := rws.bw
<span id="L4547" class="ln">  4547	</span>	*rws = http2responseWriterState{}
<span id="L4548" class="ln">  4548	</span>	rws.conn = sc
<span id="L4549" class="ln">  4549	</span>	rws.bw = bwSave
<span id="L4550" class="ln">  4550	</span>	rws.bw.Reset(http2chunkWriter{rws})
<span id="L4551" class="ln">  4551	</span>	rws.stream = st
<span id="L4552" class="ln">  4552	</span>	rws.req = req
<span id="L4553" class="ln">  4553	</span>	rws.body = body
<span id="L4554" class="ln">  4554	</span>
<span id="L4555" class="ln">  4555	</span>	rw := &amp;http2responseWriter{rws: rws}
<span id="L4556" class="ln">  4556	</span>	return rw, req, nil
<span id="L4557" class="ln">  4557	</span>}
<span id="L4558" class="ln">  4558	</span>
<span id="L4559" class="ln">  4559	</span>var http2reqBodyCache = make(chan []byte, 8)
<span id="L4560" class="ln">  4560	</span>
<span id="L4561" class="ln">  4561	</span>func http2getRequestBodyBuf() []byte {
<span id="L4562" class="ln">  4562	</span>	select {
<span id="L4563" class="ln">  4563	</span>	case b := &lt;-http2reqBodyCache:
<span id="L4564" class="ln">  4564	</span>		return b
<span id="L4565" class="ln">  4565	</span>	default:
<span id="L4566" class="ln">  4566	</span>		return make([]byte, http2initialWindowSize)
<span id="L4567" class="ln">  4567	</span>	}
<span id="L4568" class="ln">  4568	</span>}
<span id="L4569" class="ln">  4569	</span>
<span id="L4570" class="ln">  4570	</span>func http2putRequestBodyBuf(b []byte) {
<span id="L4571" class="ln">  4571	</span>	select {
<span id="L4572" class="ln">  4572	</span>	case http2reqBodyCache &lt;- b:
<span id="L4573" class="ln">  4573	</span>	default:
<span id="L4574" class="ln">  4574	</span>	}
<span id="L4575" class="ln">  4575	</span>}
<span id="L4576" class="ln">  4576	</span>
<span id="L4577" class="ln">  4577	</span><span class="comment">// Run on its own goroutine.</span>
<span id="L4578" class="ln">  4578	</span>func (sc *http2serverConn) runHandler(rw *http2responseWriter, req *Request, handler func(ResponseWriter, *Request)) {
<span id="L4579" class="ln">  4579	</span>	didPanic := true
<span id="L4580" class="ln">  4580	</span>	defer func() {
<span id="L4581" class="ln">  4581	</span>		rw.rws.stream.cancelCtx()
<span id="L4582" class="ln">  4582	</span>		if didPanic {
<span id="L4583" class="ln">  4583	</span>			e := recover()
<span id="L4584" class="ln">  4584	</span>			sc.writeFrameFromHandler(http2FrameWriteRequest{
<span id="L4585" class="ln">  4585	</span>				write:  http2handlerPanicRST{rw.rws.stream.id},
<span id="L4586" class="ln">  4586	</span>				stream: rw.rws.stream,
<span id="L4587" class="ln">  4587	</span>			})
<span id="L4588" class="ln">  4588	</span>
<span id="L4589" class="ln">  4589	</span>			if http2shouldLogPanic(e) {
<span id="L4590" class="ln">  4590	</span>				const size = 64 &lt;&lt; 10
<span id="L4591" class="ln">  4591	</span>				buf := make([]byte, size)
<span id="L4592" class="ln">  4592	</span>				buf = buf[:runtime.Stack(buf, false)]
<span id="L4593" class="ln">  4593	</span>				sc.logf(&#34;http2: panic serving %v: %v\n%s&#34;, sc.conn.RemoteAddr(), e, buf)
<span id="L4594" class="ln">  4594	</span>			}
<span id="L4595" class="ln">  4595	</span>			return
<span id="L4596" class="ln">  4596	</span>		}
<span id="L4597" class="ln">  4597	</span>		rw.handlerDone()
<span id="L4598" class="ln">  4598	</span>	}()
<span id="L4599" class="ln">  4599	</span>	handler(rw, req)
<span id="L4600" class="ln">  4600	</span>	didPanic = false
<span id="L4601" class="ln">  4601	</span>}
<span id="L4602" class="ln">  4602	</span>
<span id="L4603" class="ln">  4603	</span>func http2handleHeaderListTooLong(w ResponseWriter, r *Request) {
<span id="L4604" class="ln">  4604	</span>	<span class="comment">// 10.5.1 Limits on Header Block Size:</span>
<span id="L4605" class="ln">  4605	</span>	<span class="comment">// .. &#34;A server that receives a larger header block than it is</span>
<span id="L4606" class="ln">  4606	</span>	<span class="comment">// willing to handle can send an HTTP 431 (Request Header Fields Too</span>
<span id="L4607" class="ln">  4607	</span>	<span class="comment">// Large) status code&#34;</span>
<span id="L4608" class="ln">  4608	</span>	const statusRequestHeaderFieldsTooLarge = 431 <span class="comment">// only in Go 1.6+</span>
<span id="L4609" class="ln">  4609	</span>	w.WriteHeader(statusRequestHeaderFieldsTooLarge)
<span id="L4610" class="ln">  4610	</span>	io.WriteString(w, &#34;&lt;h1&gt;HTTP Error 431&lt;/h1&gt;&lt;p&gt;Request Header Field(s) Too Large&lt;/p&gt;&#34;)
<span id="L4611" class="ln">  4611	</span>}
<span id="L4612" class="ln">  4612	</span>
<span id="L4613" class="ln">  4613	</span><span class="comment">// called from handler goroutines.</span>
<span id="L4614" class="ln">  4614	</span><span class="comment">// h may be nil.</span>
<span id="L4615" class="ln">  4615	</span>func (sc *http2serverConn) writeHeaders(st *http2stream, headerData *http2writeResHeaders) error {
<span id="L4616" class="ln">  4616	</span>	sc.serveG.checkNotOn()
<span id="L4617" class="ln">  4617	</span>	var errc chan error
<span id="L4618" class="ln">  4618	</span>	if headerData.h != nil {
<span id="L4619" class="ln">  4619	</span>
<span id="L4620" class="ln">  4620	</span>		errc = http2errChanPool.Get().(chan error)
<span id="L4621" class="ln">  4621	</span>	}
<span id="L4622" class="ln">  4622	</span>	if err := sc.writeFrameFromHandler(http2FrameWriteRequest{
<span id="L4623" class="ln">  4623	</span>		write:  headerData,
<span id="L4624" class="ln">  4624	</span>		stream: st,
<span id="L4625" class="ln">  4625	</span>		done:   errc,
<span id="L4626" class="ln">  4626	</span>	}); err != nil {
<span id="L4627" class="ln">  4627	</span>		return err
<span id="L4628" class="ln">  4628	</span>	}
<span id="L4629" class="ln">  4629	</span>	if errc != nil {
<span id="L4630" class="ln">  4630	</span>		select {
<span id="L4631" class="ln">  4631	</span>		case err := &lt;-errc:
<span id="L4632" class="ln">  4632	</span>			http2errChanPool.Put(errc)
<span id="L4633" class="ln">  4633	</span>			return err
<span id="L4634" class="ln">  4634	</span>		case &lt;-sc.doneServing:
<span id="L4635" class="ln">  4635	</span>			return http2errClientDisconnected
<span id="L4636" class="ln">  4636	</span>		case &lt;-st.cw:
<span id="L4637" class="ln">  4637	</span>			return http2errStreamClosed
<span id="L4638" class="ln">  4638	</span>		}
<span id="L4639" class="ln">  4639	</span>	}
<span id="L4640" class="ln">  4640	</span>	return nil
<span id="L4641" class="ln">  4641	</span>}
<span id="L4642" class="ln">  4642	</span>
<span id="L4643" class="ln">  4643	</span><span class="comment">// called from handler goroutines.</span>
<span id="L4644" class="ln">  4644	</span>func (sc *http2serverConn) write100ContinueHeaders(st *http2stream) {
<span id="L4645" class="ln">  4645	</span>	sc.writeFrameFromHandler(http2FrameWriteRequest{
<span id="L4646" class="ln">  4646	</span>		write:  http2write100ContinueHeadersFrame{st.id},
<span id="L4647" class="ln">  4647	</span>		stream: st,
<span id="L4648" class="ln">  4648	</span>	})
<span id="L4649" class="ln">  4649	</span>}
<span id="L4650" class="ln">  4650	</span>
<span id="L4651" class="ln">  4651	</span><span class="comment">// A bodyReadMsg tells the server loop that the http.Handler read n</span>
<span id="L4652" class="ln">  4652	</span><span class="comment">// bytes of the DATA from the client on the given stream.</span>
<span id="L4653" class="ln">  4653	</span>type http2bodyReadMsg struct {
<span id="L4654" class="ln">  4654	</span>	st *http2stream
<span id="L4655" class="ln">  4655	</span>	n  int
<span id="L4656" class="ln">  4656	</span>}
<span id="L4657" class="ln">  4657	</span>
<span id="L4658" class="ln">  4658	</span><span class="comment">// called from handler goroutines.</span>
<span id="L4659" class="ln">  4659	</span><span class="comment">// Notes that the handler for the given stream ID read n bytes of its body</span>
<span id="L4660" class="ln">  4660	</span><span class="comment">// and schedules flow control tokens to be sent.</span>
<span id="L4661" class="ln">  4661	</span>func (sc *http2serverConn) noteBodyReadFromHandler(st *http2stream, n int, err error) {
<span id="L4662" class="ln">  4662	</span>	sc.serveG.checkNotOn()
<span id="L4663" class="ln">  4663	</span>	if n &gt; 0 {
<span id="L4664" class="ln">  4664	</span>		select {
<span id="L4665" class="ln">  4665	</span>		case sc.bodyReadCh &lt;- http2bodyReadMsg{st, n}:
<span id="L4666" class="ln">  4666	</span>		case &lt;-sc.doneServing:
<span id="L4667" class="ln">  4667	</span>		}
<span id="L4668" class="ln">  4668	</span>	}
<span id="L4669" class="ln">  4669	</span>	if err == io.EOF {
<span id="L4670" class="ln">  4670	</span>		if buf := st.reqBuf; buf != nil {
<span id="L4671" class="ln">  4671	</span>			st.reqBuf = nil
<span id="L4672" class="ln">  4672	</span>			http2putRequestBodyBuf(buf)
<span id="L4673" class="ln">  4673	</span>		}
<span id="L4674" class="ln">  4674	</span>	}
<span id="L4675" class="ln">  4675	</span>}
<span id="L4676" class="ln">  4676	</span>
<span id="L4677" class="ln">  4677	</span>func (sc *http2serverConn) noteBodyRead(st *http2stream, n int) {
<span id="L4678" class="ln">  4678	</span>	sc.serveG.check()
<span id="L4679" class="ln">  4679	</span>	sc.sendWindowUpdate(nil, n)
<span id="L4680" class="ln">  4680	</span>	if st.state != http2stateHalfClosedRemote &amp;&amp; st.state != http2stateClosed {
<span id="L4681" class="ln">  4681	</span>
<span id="L4682" class="ln">  4682	</span>		sc.sendWindowUpdate(st, n)
<span id="L4683" class="ln">  4683	</span>	}
<span id="L4684" class="ln">  4684	</span>}
<span id="L4685" class="ln">  4685	</span>
<span id="L4686" class="ln">  4686	</span><span class="comment">// st may be nil for conn-level</span>
<span id="L4687" class="ln">  4687	</span>func (sc *http2serverConn) sendWindowUpdate(st *http2stream, n int) {
<span id="L4688" class="ln">  4688	</span>	sc.serveG.check()
<span id="L4689" class="ln">  4689	</span>	<span class="comment">// &#34;The legal range for the increment to the flow control</span>
<span id="L4690" class="ln">  4690	</span>	<span class="comment">// window is 1 to 2^31-1 (2,147,483,647) octets.&#34;</span>
<span id="L4691" class="ln">  4691	</span>	<span class="comment">// A Go Read call on 64-bit machines could in theory read</span>
<span id="L4692" class="ln">  4692	</span>	<span class="comment">// a larger Read than this. Very unlikely, but we handle it here</span>
<span id="L4693" class="ln">  4693	</span>	<span class="comment">// rather than elsewhere for now.</span>
<span id="L4694" class="ln">  4694	</span>	const maxUint31 = 1&lt;&lt;31 - 1
<span id="L4695" class="ln">  4695	</span>	for n &gt;= maxUint31 {
<span id="L4696" class="ln">  4696	</span>		sc.sendWindowUpdate32(st, maxUint31)
<span id="L4697" class="ln">  4697	</span>		n -= maxUint31
<span id="L4698" class="ln">  4698	</span>	}
<span id="L4699" class="ln">  4699	</span>	sc.sendWindowUpdate32(st, int32(n))
<span id="L4700" class="ln">  4700	</span>}
<span id="L4701" class="ln">  4701	</span>
<span id="L4702" class="ln">  4702	</span><span class="comment">// st may be nil for conn-level</span>
<span id="L4703" class="ln">  4703	</span>func (sc *http2serverConn) sendWindowUpdate32(st *http2stream, n int32) {
<span id="L4704" class="ln">  4704	</span>	sc.serveG.check()
<span id="L4705" class="ln">  4705	</span>	if n == 0 {
<span id="L4706" class="ln">  4706	</span>		return
<span id="L4707" class="ln">  4707	</span>	}
<span id="L4708" class="ln">  4708	</span>	if n &lt; 0 {
<span id="L4709" class="ln">  4709	</span>		panic(&#34;negative update&#34;)
<span id="L4710" class="ln">  4710	</span>	}
<span id="L4711" class="ln">  4711	</span>	var streamID uint32
<span id="L4712" class="ln">  4712	</span>	if st != nil {
<span id="L4713" class="ln">  4713	</span>		streamID = st.id
<span id="L4714" class="ln">  4714	</span>	}
<span id="L4715" class="ln">  4715	</span>	sc.writeFrame(http2FrameWriteRequest{
<span id="L4716" class="ln">  4716	</span>		write:  http2writeWindowUpdate{streamID: streamID, n: uint32(n)},
<span id="L4717" class="ln">  4717	</span>		stream: st,
<span id="L4718" class="ln">  4718	</span>	})
<span id="L4719" class="ln">  4719	</span>	var ok bool
<span id="L4720" class="ln">  4720	</span>	if st == nil {
<span id="L4721" class="ln">  4721	</span>		ok = sc.inflow.add(n)
<span id="L4722" class="ln">  4722	</span>	} else {
<span id="L4723" class="ln">  4723	</span>		ok = st.inflow.add(n)
<span id="L4724" class="ln">  4724	</span>	}
<span id="L4725" class="ln">  4725	</span>	if !ok {
<span id="L4726" class="ln">  4726	</span>		panic(&#34;internal error; sent too many window updates without decrements?&#34;)
<span id="L4727" class="ln">  4727	</span>	}
<span id="L4728" class="ln">  4728	</span>}
<span id="L4729" class="ln">  4729	</span>
<span id="L4730" class="ln">  4730	</span><span class="comment">// requestBody is the Handler&#39;s Request.Body type.</span>
<span id="L4731" class="ln">  4731	</span><span class="comment">// Read and Close may be called concurrently.</span>
<span id="L4732" class="ln">  4732	</span>type http2requestBody struct {
<span id="L4733" class="ln">  4733	</span>	stream        *http2stream
<span id="L4734" class="ln">  4734	</span>	conn          *http2serverConn
<span id="L4735" class="ln">  4735	</span>	closed        bool       <span class="comment">// for use by Close only</span>
<span id="L4736" class="ln">  4736	</span>	sawEOF        bool       <span class="comment">// for use by Read only</span>
<span id="L4737" class="ln">  4737	</span>	pipe          *http2pipe <span class="comment">// non-nil if we have a HTTP entity message body</span>
<span id="L4738" class="ln">  4738	</span>	needsContinue bool       <span class="comment">// need to send a 100-continue</span>
<span id="L4739" class="ln">  4739	</span>}
<span id="L4740" class="ln">  4740	</span>
<span id="L4741" class="ln">  4741	</span>func (b *http2requestBody) Close() error {
<span id="L4742" class="ln">  4742	</span>	if b.pipe != nil &amp;&amp; !b.closed {
<span id="L4743" class="ln">  4743	</span>		b.pipe.BreakWithError(http2errClosedBody)
<span id="L4744" class="ln">  4744	</span>	}
<span id="L4745" class="ln">  4745	</span>	b.closed = true
<span id="L4746" class="ln">  4746	</span>	return nil
<span id="L4747" class="ln">  4747	</span>}
<span id="L4748" class="ln">  4748	</span>
<span id="L4749" class="ln">  4749	</span>func (b *http2requestBody) Read(p []byte) (n int, err error) {
<span id="L4750" class="ln">  4750	</span>	if b.needsContinue {
<span id="L4751" class="ln">  4751	</span>		b.needsContinue = false
<span id="L4752" class="ln">  4752	</span>		b.conn.write100ContinueHeaders(b.stream)
<span id="L4753" class="ln">  4753	</span>	}
<span id="L4754" class="ln">  4754	</span>	if b.pipe == nil || b.sawEOF {
<span id="L4755" class="ln">  4755	</span>		return 0, io.EOF
<span id="L4756" class="ln">  4756	</span>	}
<span id="L4757" class="ln">  4757	</span>	n, err = b.pipe.Read(p)
<span id="L4758" class="ln">  4758	</span>	if err == io.EOF {
<span id="L4759" class="ln">  4759	</span>		b.sawEOF = true
<span id="L4760" class="ln">  4760	</span>	}
<span id="L4761" class="ln">  4761	</span>	if b.conn == nil &amp;&amp; http2inTests {
<span id="L4762" class="ln">  4762	</span>		return
<span id="L4763" class="ln">  4763	</span>	}
<span id="L4764" class="ln">  4764	</span>	b.conn.noteBodyReadFromHandler(b.stream, n, err)
<span id="L4765" class="ln">  4765	</span>	return
<span id="L4766" class="ln">  4766	</span>}
<span id="L4767" class="ln">  4767	</span>
<span id="L4768" class="ln">  4768	</span><span class="comment">// responseWriter is the http.ResponseWriter implementation.  It&#39;s</span>
<span id="L4769" class="ln">  4769	</span><span class="comment">// intentionally small (1 pointer wide) to minimize garbage.  The</span>
<span id="L4770" class="ln">  4770	</span><span class="comment">// responseWriterState pointer inside is zeroed at the end of a</span>
<span id="L4771" class="ln">  4771	</span><span class="comment">// request (in handlerDone) and calls on the responseWriter thereafter</span>
<span id="L4772" class="ln">  4772	</span><span class="comment">// simply crash (caller&#39;s mistake), but the much larger responseWriterState</span>
<span id="L4773" class="ln">  4773	</span><span class="comment">// and buffers are reused between multiple requests.</span>
<span id="L4774" class="ln">  4774	</span>type http2responseWriter struct {
<span id="L4775" class="ln">  4775	</span>	rws *http2responseWriterState
<span id="L4776" class="ln">  4776	</span>}
<span id="L4777" class="ln">  4777	</span>
<span id="L4778" class="ln">  4778	</span><span class="comment">// Optional http.ResponseWriter interfaces implemented.</span>
<span id="L4779" class="ln">  4779	</span>var (
<span id="L4780" class="ln">  4780	</span>	_ CloseNotifier     = (*http2responseWriter)(nil)
<span id="L4781" class="ln">  4781	</span>	_ Flusher           = (*http2responseWriter)(nil)
<span id="L4782" class="ln">  4782	</span>	_ http2stringWriter = (*http2responseWriter)(nil)
<span id="L4783" class="ln">  4783	</span>)
<span id="L4784" class="ln">  4784	</span>
<span id="L4785" class="ln">  4785	</span>type http2responseWriterState struct {
<span id="L4786" class="ln">  4786	</span>	<span class="comment">// immutable within a request:</span>
<span id="L4787" class="ln">  4787	</span>	stream *http2stream
<span id="L4788" class="ln">  4788	</span>	req    *Request
<span id="L4789" class="ln">  4789	</span>	body   *http2requestBody <span class="comment">// to close at end of request, if DATA frames didn&#39;t</span>
<span id="L4790" class="ln">  4790	</span>	conn   *http2serverConn
<span id="L4791" class="ln">  4791	</span>
<span id="L4792" class="ln">  4792	</span>	<span class="comment">// TODO: adjust buffer writing sizes based on server config, frame size updates from peer, etc</span>
<span id="L4793" class="ln">  4793	</span>	bw *bufio.Writer <span class="comment">// writing to a chunkWriter{this *responseWriterState}</span>
<span id="L4794" class="ln">  4794	</span>
<span id="L4795" class="ln">  4795	</span>	<span class="comment">// mutated by http.Handler goroutine:</span>
<span id="L4796" class="ln">  4796	</span>	handlerHeader Header   <span class="comment">// nil until called</span>
<span id="L4797" class="ln">  4797	</span>	snapHeader    Header   <span class="comment">// snapshot of handlerHeader at WriteHeader time</span>
<span id="L4798" class="ln">  4798	</span>	trailers      []string <span class="comment">// set in writeChunk</span>
<span id="L4799" class="ln">  4799	</span>	status        int      <span class="comment">// status code passed to WriteHeader</span>
<span id="L4800" class="ln">  4800	</span>	wroteHeader   bool     <span class="comment">// WriteHeader called (explicitly or implicitly). Not necessarily sent to user yet.</span>
<span id="L4801" class="ln">  4801	</span>	sentHeader    bool     <span class="comment">// have we sent the header frame?</span>
<span id="L4802" class="ln">  4802	</span>	handlerDone   bool     <span class="comment">// handler has finished</span>
<span id="L4803" class="ln">  4803	</span>
<span id="L4804" class="ln">  4804	</span>	sentContentLen int64 <span class="comment">// non-zero if handler set a Content-Length header</span>
<span id="L4805" class="ln">  4805	</span>	wroteBytes     int64
<span id="L4806" class="ln">  4806	</span>
<span id="L4807" class="ln">  4807	</span>	closeNotifierMu sync.Mutex <span class="comment">// guards closeNotifierCh</span>
<span id="L4808" class="ln">  4808	</span>	closeNotifierCh chan bool  <span class="comment">// nil until first used</span>
<span id="L4809" class="ln">  4809	</span>}
<span id="L4810" class="ln">  4810	</span>
<span id="L4811" class="ln">  4811	</span>type http2chunkWriter struct{ rws *http2responseWriterState }
<span id="L4812" class="ln">  4812	</span>
<span id="L4813" class="ln">  4813	</span>func (cw http2chunkWriter) Write(p []byte) (n int, err error) { return cw.rws.writeChunk(p) }
<span id="L4814" class="ln">  4814	</span>
<span id="L4815" class="ln">  4815	</span>func (rws *http2responseWriterState) hasTrailers() bool { return len(rws.trailers) != 0 }
<span id="L4816" class="ln">  4816	</span>
<span id="L4817" class="ln">  4817	</span><span class="comment">// declareTrailer is called for each Trailer header when the</span>
<span id="L4818" class="ln">  4818	</span><span class="comment">// response header is written. It notes that a header will need to be</span>
<span id="L4819" class="ln">  4819	</span><span class="comment">// written in the trailers at the end of the response.</span>
<span id="L4820" class="ln">  4820	</span>func (rws *http2responseWriterState) declareTrailer(k string) {
<span id="L4821" class="ln">  4821	</span>	k = CanonicalHeaderKey(k)
<span id="L4822" class="ln">  4822	</span>	if !http2ValidTrailerHeader(k) {
<span id="L4823" class="ln">  4823	</span>
<span id="L4824" class="ln">  4824	</span>		rws.conn.logf(&#34;ignoring invalid trailer %q&#34;, k)
<span id="L4825" class="ln">  4825	</span>		return
<span id="L4826" class="ln">  4826	</span>	}
<span id="L4827" class="ln">  4827	</span>	if !http2strSliceContains(rws.trailers, k) {
<span id="L4828" class="ln">  4828	</span>		rws.trailers = append(rws.trailers, k)
<span id="L4829" class="ln">  4829	</span>	}
<span id="L4830" class="ln">  4830	</span>}
<span id="L4831" class="ln">  4831	</span>
<span id="L4832" class="ln">  4832	</span><span class="comment">// writeChunk writes chunks from the bufio.Writer. But because</span>
<span id="L4833" class="ln">  4833	</span><span class="comment">// bufio.Writer may bypass its chunking, sometimes p may be</span>
<span id="L4834" class="ln">  4834	</span><span class="comment">// arbitrarily large.</span>
<span id="L4835" class="ln">  4835	</span><span class="comment">//</span>
<span id="L4836" class="ln">  4836	</span><span class="comment">// writeChunk is also responsible (on the first chunk) for sending the</span>
<span id="L4837" class="ln">  4837	</span><span class="comment">// HEADER response.</span>
<span id="L4838" class="ln">  4838	</span>func (rws *http2responseWriterState) writeChunk(p []byte) (n int, err error) {
<span id="L4839" class="ln">  4839	</span>	if !rws.wroteHeader {
<span id="L4840" class="ln">  4840	</span>		rws.writeHeader(200)
<span id="L4841" class="ln">  4841	</span>	}
<span id="L4842" class="ln">  4842	</span>
<span id="L4843" class="ln">  4843	</span>	isHeadResp := rws.req.Method == &#34;HEAD&#34;
<span id="L4844" class="ln">  4844	</span>	if !rws.sentHeader {
<span id="L4845" class="ln">  4845	</span>		rws.sentHeader = true
<span id="L4846" class="ln">  4846	</span>		var ctype, clen string
<span id="L4847" class="ln">  4847	</span>		if clen = rws.snapHeader.Get(&#34;Content-Length&#34;); clen != &#34;&#34; {
<span id="L4848" class="ln">  4848	</span>			rws.snapHeader.Del(&#34;Content-Length&#34;)
<span id="L4849" class="ln">  4849	</span>			clen64, err := strconv.ParseInt(clen, 10, 64)
<span id="L4850" class="ln">  4850	</span>			if err == nil &amp;&amp; clen64 &gt;= 0 {
<span id="L4851" class="ln">  4851	</span>				rws.sentContentLen = clen64
<span id="L4852" class="ln">  4852	</span>			} else {
<span id="L4853" class="ln">  4853	</span>				clen = &#34;&#34;
<span id="L4854" class="ln">  4854	</span>			}
<span id="L4855" class="ln">  4855	</span>		}
<span id="L4856" class="ln">  4856	</span>		if clen == &#34;&#34; &amp;&amp; rws.handlerDone &amp;&amp; http2bodyAllowedForStatus(rws.status) &amp;&amp; (len(p) &gt; 0 || !isHeadResp) {
<span id="L4857" class="ln">  4857	</span>			clen = strconv.Itoa(len(p))
<span id="L4858" class="ln">  4858	</span>		}
<span id="L4859" class="ln">  4859	</span>		_, hasContentType := rws.snapHeader[&#34;Content-Type&#34;]
<span id="L4860" class="ln">  4860	</span>		if !hasContentType &amp;&amp; http2bodyAllowedForStatus(rws.status) {
<span id="L4861" class="ln">  4861	</span>			ctype = DetectContentType(p)
<span id="L4862" class="ln">  4862	</span>		}
<span id="L4863" class="ln">  4863	</span>		var date string
<span id="L4864" class="ln">  4864	</span>		if _, ok := rws.snapHeader[&#34;Date&#34;]; !ok {
<span id="L4865" class="ln">  4865	</span>
<span id="L4866" class="ln">  4866	</span>			date = time.Now().UTC().Format(TimeFormat)
<span id="L4867" class="ln">  4867	</span>		}
<span id="L4868" class="ln">  4868	</span>
<span id="L4869" class="ln">  4869	</span>		for _, v := range rws.snapHeader[&#34;Trailer&#34;] {
<span id="L4870" class="ln">  4870	</span>			http2foreachHeaderElement(v, rws.declareTrailer)
<span id="L4871" class="ln">  4871	</span>		}
<span id="L4872" class="ln">  4872	</span>
<span id="L4873" class="ln">  4873	</span>		endStream := (rws.handlerDone &amp;&amp; !rws.hasTrailers() &amp;&amp; len(p) == 0) || isHeadResp
<span id="L4874" class="ln">  4874	</span>		err = rws.conn.writeHeaders(rws.stream, &amp;http2writeResHeaders{
<span id="L4875" class="ln">  4875	</span>			streamID:      rws.stream.id,
<span id="L4876" class="ln">  4876	</span>			httpResCode:   rws.status,
<span id="L4877" class="ln">  4877	</span>			h:             rws.snapHeader,
<span id="L4878" class="ln">  4878	</span>			endStream:     endStream,
<span id="L4879" class="ln">  4879	</span>			contentType:   ctype,
<span id="L4880" class="ln">  4880	</span>			contentLength: clen,
<span id="L4881" class="ln">  4881	</span>			date:          date,
<span id="L4882" class="ln">  4882	</span>		})
<span id="L4883" class="ln">  4883	</span>		if err != nil {
<span id="L4884" class="ln">  4884	</span>			return 0, err
<span id="L4885" class="ln">  4885	</span>		}
<span id="L4886" class="ln">  4886	</span>		if endStream {
<span id="L4887" class="ln">  4887	</span>			return 0, nil
<span id="L4888" class="ln">  4888	</span>		}
<span id="L4889" class="ln">  4889	</span>	}
<span id="L4890" class="ln">  4890	</span>	if isHeadResp {
<span id="L4891" class="ln">  4891	</span>		return len(p), nil
<span id="L4892" class="ln">  4892	</span>	}
<span id="L4893" class="ln">  4893	</span>	if len(p) == 0 &amp;&amp; !rws.handlerDone {
<span id="L4894" class="ln">  4894	</span>		return 0, nil
<span id="L4895" class="ln">  4895	</span>	}
<span id="L4896" class="ln">  4896	</span>
<span id="L4897" class="ln">  4897	</span>	if rws.handlerDone {
<span id="L4898" class="ln">  4898	</span>		rws.promoteUndeclaredTrailers()
<span id="L4899" class="ln">  4899	</span>	}
<span id="L4900" class="ln">  4900	</span>
<span id="L4901" class="ln">  4901	</span>	endStream := rws.handlerDone &amp;&amp; !rws.hasTrailers()
<span id="L4902" class="ln">  4902	</span>	if len(p) &gt; 0 || endStream {
<span id="L4903" class="ln">  4903	</span>
<span id="L4904" class="ln">  4904	</span>		if err := rws.conn.writeDataFromHandler(rws.stream, p, endStream); err != nil {
<span id="L4905" class="ln">  4905	</span>			return 0, err
<span id="L4906" class="ln">  4906	</span>		}
<span id="L4907" class="ln">  4907	</span>	}
<span id="L4908" class="ln">  4908	</span>
<span id="L4909" class="ln">  4909	</span>	if rws.handlerDone &amp;&amp; rws.hasTrailers() {
<span id="L4910" class="ln">  4910	</span>		err = rws.conn.writeHeaders(rws.stream, &amp;http2writeResHeaders{
<span id="L4911" class="ln">  4911	</span>			streamID:  rws.stream.id,
<span id="L4912" class="ln">  4912	</span>			h:         rws.handlerHeader,
<span id="L4913" class="ln">  4913	</span>			trailers:  rws.trailers,
<span id="L4914" class="ln">  4914	</span>			endStream: true,
<span id="L4915" class="ln">  4915	</span>		})
<span id="L4916" class="ln">  4916	</span>		return len(p), err
<span id="L4917" class="ln">  4917	</span>	}
<span id="L4918" class="ln">  4918	</span>	return len(p), nil
<span id="L4919" class="ln">  4919	</span>}
<span id="L4920" class="ln">  4920	</span>
<span id="L4921" class="ln">  4921	</span><span class="comment">// TrailerPrefix is a magic prefix for ResponseWriter.Header map keys</span>
<span id="L4922" class="ln">  4922	</span><span class="comment">// that, if present, signals that the map entry is actually for</span>
<span id="L4923" class="ln">  4923	</span><span class="comment">// the response trailers, and not the response headers. The prefix</span>
<span id="L4924" class="ln">  4924	</span><span class="comment">// is stripped after the ServeHTTP call finishes and the values are</span>
<span id="L4925" class="ln">  4925	</span><span class="comment">// sent in the trailers.</span>
<span id="L4926" class="ln">  4926	</span><span class="comment">//</span>
<span id="L4927" class="ln">  4927	</span><span class="comment">// This mechanism is intended only for trailers that are not known</span>
<span id="L4928" class="ln">  4928	</span><span class="comment">// prior to the headers being written. If the set of trailers is fixed</span>
<span id="L4929" class="ln">  4929	</span><span class="comment">// or known before the header is written, the normal Go trailers mechanism</span>
<span id="L4930" class="ln">  4930	</span><span class="comment">// is preferred:</span>
<span id="L4931" class="ln">  4931	</span><span class="comment">//    https://golang.org/pkg/net/http/#ResponseWriter</span>
<span id="L4932" class="ln">  4932	</span><span class="comment">//    https://golang.org/pkg/net/http/#example_ResponseWriter_trailers</span>
<span id="L4933" class="ln">  4933	</span>const http2TrailerPrefix = &#34;Trailer:&#34;
<span id="L4934" class="ln">  4934	</span>
<span id="L4935" class="ln">  4935	</span><span class="comment">// promoteUndeclaredTrailers permits http.Handlers to set trailers</span>
<span id="L4936" class="ln">  4936	</span><span class="comment">// after the header has already been flushed. Because the Go</span>
<span id="L4937" class="ln">  4937	</span><span class="comment">// ResponseWriter interface has no way to set Trailers (only the</span>
<span id="L4938" class="ln">  4938	</span><span class="comment">// Header), and because we didn&#39;t want to expand the ResponseWriter</span>
<span id="L4939" class="ln">  4939	</span><span class="comment">// interface, and because nobody used trailers, and because RFC 2616</span>
<span id="L4940" class="ln">  4940	</span><span class="comment">// says you SHOULD (but not must) predeclare any trailers in the</span>
<span id="L4941" class="ln">  4941	</span><span class="comment">// header, the official ResponseWriter rules said trailers in Go must</span>
<span id="L4942" class="ln">  4942	</span><span class="comment">// be predeclared, and then we reuse the same ResponseWriter.Header()</span>
<span id="L4943" class="ln">  4943	</span><span class="comment">// map to mean both Headers and Trailers.  When it&#39;s time to write the</span>
<span id="L4944" class="ln">  4944	</span><span class="comment">// Trailers, we pick out the fields of Headers that were declared as</span>
<span id="L4945" class="ln">  4945	</span><span class="comment">// trailers. That worked for a while, until we found the first major</span>
<span id="L4946" class="ln">  4946	</span><span class="comment">// user of Trailers in the wild: gRPC (using them only over http2),</span>
<span id="L4947" class="ln">  4947	</span><span class="comment">// and gRPC libraries permit setting trailers mid-stream without</span>
<span id="L4948" class="ln">  4948	</span><span class="comment">// predeclarnig them. So: change of plans. We still permit the old</span>
<span id="L4949" class="ln">  4949	</span><span class="comment">// way, but we also permit this hack: if a Header() key begins with</span>
<span id="L4950" class="ln">  4950	</span><span class="comment">// &#34;Trailer:&#34;, the suffix of that key is a Trailer. Because &#39;:&#39; is an</span>
<span id="L4951" class="ln">  4951	</span><span class="comment">// invalid token byte anyway, there is no ambiguity. (And it&#39;s already</span>
<span id="L4952" class="ln">  4952	</span><span class="comment">// filtered out) It&#39;s mildly hacky, but not terrible.</span>
<span id="L4953" class="ln">  4953	</span><span class="comment">//</span>
<span id="L4954" class="ln">  4954	</span><span class="comment">// This method runs after the Handler is done and promotes any Header</span>
<span id="L4955" class="ln">  4955	</span><span class="comment">// fields to be trailers.</span>
<span id="L4956" class="ln">  4956	</span>func (rws *http2responseWriterState) promoteUndeclaredTrailers() {
<span id="L4957" class="ln">  4957	</span>	for k, vv := range rws.handlerHeader {
<span id="L4958" class="ln">  4958	</span>		if !strings.HasPrefix(k, http2TrailerPrefix) {
<span id="L4959" class="ln">  4959	</span>			continue
<span id="L4960" class="ln">  4960	</span>		}
<span id="L4961" class="ln">  4961	</span>		trailerKey := strings.TrimPrefix(k, http2TrailerPrefix)
<span id="L4962" class="ln">  4962	</span>		rws.declareTrailer(trailerKey)
<span id="L4963" class="ln">  4963	</span>		rws.handlerHeader[CanonicalHeaderKey(trailerKey)] = vv
<span id="L4964" class="ln">  4964	</span>	}
<span id="L4965" class="ln">  4965	</span>
<span id="L4966" class="ln">  4966	</span>	if len(rws.trailers) &gt; 1 {
<span id="L4967" class="ln">  4967	</span>		sorter := http2sorterPool.Get().(*http2sorter)
<span id="L4968" class="ln">  4968	</span>		sorter.SortStrings(rws.trailers)
<span id="L4969" class="ln">  4969	</span>		http2sorterPool.Put(sorter)
<span id="L4970" class="ln">  4970	</span>	}
<span id="L4971" class="ln">  4971	</span>}
<span id="L4972" class="ln">  4972	</span>
<span id="L4973" class="ln">  4973	</span>func (w *http2responseWriter) Flush() {
<span id="L4974" class="ln">  4974	</span>	rws := w.rws
<span id="L4975" class="ln">  4975	</span>	if rws == nil {
<span id="L4976" class="ln">  4976	</span>		panic(&#34;Header called after Handler finished&#34;)
<span id="L4977" class="ln">  4977	</span>	}
<span id="L4978" class="ln">  4978	</span>	if rws.bw.Buffered() &gt; 0 {
<span id="L4979" class="ln">  4979	</span>		if err := rws.bw.Flush(); err != nil {
<span id="L4980" class="ln">  4980	</span>
<span id="L4981" class="ln">  4981	</span>			return
<span id="L4982" class="ln">  4982	</span>		}
<span id="L4983" class="ln">  4983	</span>	} else {
<span id="L4984" class="ln">  4984	</span>
<span id="L4985" class="ln">  4985	</span>		rws.writeChunk(nil)
<span id="L4986" class="ln">  4986	</span>	}
<span id="L4987" class="ln">  4987	</span>}
<span id="L4988" class="ln">  4988	</span>
<span id="L4989" class="ln">  4989	</span>func (w *http2responseWriter) CloseNotify() &lt;-chan bool {
<span id="L4990" class="ln">  4990	</span>	rws := w.rws
<span id="L4991" class="ln">  4991	</span>	if rws == nil {
<span id="L4992" class="ln">  4992	</span>		panic(&#34;CloseNotify called after Handler finished&#34;)
<span id="L4993" class="ln">  4993	</span>	}
<span id="L4994" class="ln">  4994	</span>	rws.closeNotifierMu.Lock()
<span id="L4995" class="ln">  4995	</span>	ch := rws.closeNotifierCh
<span id="L4996" class="ln">  4996	</span>	if ch == nil {
<span id="L4997" class="ln">  4997	</span>		ch = make(chan bool, 1)
<span id="L4998" class="ln">  4998	</span>		rws.closeNotifierCh = ch
<span id="L4999" class="ln">  4999	</span>		cw := rws.stream.cw
<span id="L5000" class="ln">  5000	</span>		go func() {
<span id="L5001" class="ln">  5001	</span>			cw.Wait()
<span id="L5002" class="ln">  5002	</span>			ch &lt;- true
<span id="L5003" class="ln">  5003	</span>		}()
<span id="L5004" class="ln">  5004	</span>	}
<span id="L5005" class="ln">  5005	</span>	rws.closeNotifierMu.Unlock()
<span id="L5006" class="ln">  5006	</span>	return ch
<span id="L5007" class="ln">  5007	</span>}
<span id="L5008" class="ln">  5008	</span>
<span id="L5009" class="ln">  5009	</span>func (w *http2responseWriter) Header() Header {
<span id="L5010" class="ln">  5010	</span>	rws := w.rws
<span id="L5011" class="ln">  5011	</span>	if rws == nil {
<span id="L5012" class="ln">  5012	</span>		panic(&#34;Header called after Handler finished&#34;)
<span id="L5013" class="ln">  5013	</span>	}
<span id="L5014" class="ln">  5014	</span>	if rws.handlerHeader == nil {
<span id="L5015" class="ln">  5015	</span>		rws.handlerHeader = make(Header)
<span id="L5016" class="ln">  5016	</span>	}
<span id="L5017" class="ln">  5017	</span>	return rws.handlerHeader
<span id="L5018" class="ln">  5018	</span>}
<span id="L5019" class="ln">  5019	</span>
<span id="L5020" class="ln">  5020	</span>func (w *http2responseWriter) WriteHeader(code int) {
<span id="L5021" class="ln">  5021	</span>	rws := w.rws
<span id="L5022" class="ln">  5022	</span>	if rws == nil {
<span id="L5023" class="ln">  5023	</span>		panic(&#34;WriteHeader called after Handler finished&#34;)
<span id="L5024" class="ln">  5024	</span>	}
<span id="L5025" class="ln">  5025	</span>	rws.writeHeader(code)
<span id="L5026" class="ln">  5026	</span>}
<span id="L5027" class="ln">  5027	</span>
<span id="L5028" class="ln">  5028	</span>func (rws *http2responseWriterState) writeHeader(code int) {
<span id="L5029" class="ln">  5029	</span>	if !rws.wroteHeader {
<span id="L5030" class="ln">  5030	</span>		rws.wroteHeader = true
<span id="L5031" class="ln">  5031	</span>		rws.status = code
<span id="L5032" class="ln">  5032	</span>		if len(rws.handlerHeader) &gt; 0 {
<span id="L5033" class="ln">  5033	</span>			rws.snapHeader = http2cloneHeader(rws.handlerHeader)
<span id="L5034" class="ln">  5034	</span>		}
<span id="L5035" class="ln">  5035	</span>	}
<span id="L5036" class="ln">  5036	</span>}
<span id="L5037" class="ln">  5037	</span>
<span id="L5038" class="ln">  5038	</span>func http2cloneHeader(h Header) Header {
<span id="L5039" class="ln">  5039	</span>	h2 := make(Header, len(h))
<span id="L5040" class="ln">  5040	</span>	for k, vv := range h {
<span id="L5041" class="ln">  5041	</span>		vv2 := make([]string, len(vv))
<span id="L5042" class="ln">  5042	</span>		copy(vv2, vv)
<span id="L5043" class="ln">  5043	</span>		h2[k] = vv2
<span id="L5044" class="ln">  5044	</span>	}
<span id="L5045" class="ln">  5045	</span>	return h2
<span id="L5046" class="ln">  5046	</span>}
<span id="L5047" class="ln">  5047	</span>
<span id="L5048" class="ln">  5048	</span><span class="comment">// The Life Of A Write is like this:</span>
<span id="L5049" class="ln">  5049	</span><span class="comment">//</span>
<span id="L5050" class="ln">  5050	</span><span class="comment">// * Handler calls w.Write or w.WriteString -&gt;</span>
<span id="L5051" class="ln">  5051	</span><span class="comment">// * -&gt; rws.bw (*bufio.Writer) -&gt;</span>
<span id="L5052" class="ln">  5052	</span><span class="comment">// * (Handler migth call Flush)</span>
<span id="L5053" class="ln">  5053	</span><span class="comment">// * -&gt; chunkWriter{rws}</span>
<span id="L5054" class="ln">  5054	</span><span class="comment">// * -&gt; responseWriterState.writeChunk(p []byte)</span>
<span id="L5055" class="ln">  5055	</span><span class="comment">// * -&gt; responseWriterState.writeChunk (most of the magic; see comment there)</span>
<span id="L5056" class="ln">  5056	</span>func (w *http2responseWriter) Write(p []byte) (n int, err error) {
<span id="L5057" class="ln">  5057	</span>	return w.write(len(p), p, &#34;&#34;)
<span id="L5058" class="ln">  5058	</span>}
<span id="L5059" class="ln">  5059	</span>
<span id="L5060" class="ln">  5060	</span>func (w *http2responseWriter) WriteString(s string) (n int, err error) {
<span id="L5061" class="ln">  5061	</span>	return w.write(len(s), nil, s)
<span id="L5062" class="ln">  5062	</span>}
<span id="L5063" class="ln">  5063	</span>
<span id="L5064" class="ln">  5064	</span><span class="comment">// either dataB or dataS is non-zero.</span>
<span id="L5065" class="ln">  5065	</span>func (w *http2responseWriter) write(lenData int, dataB []byte, dataS string) (n int, err error) {
<span id="L5066" class="ln">  5066	</span>	rws := w.rws
<span id="L5067" class="ln">  5067	</span>	if rws == nil {
<span id="L5068" class="ln">  5068	</span>		panic(&#34;Write called after Handler finished&#34;)
<span id="L5069" class="ln">  5069	</span>	}
<span id="L5070" class="ln">  5070	</span>	if !rws.wroteHeader {
<span id="L5071" class="ln">  5071	</span>		w.WriteHeader(200)
<span id="L5072" class="ln">  5072	</span>	}
<span id="L5073" class="ln">  5073	</span>	if !http2bodyAllowedForStatus(rws.status) {
<span id="L5074" class="ln">  5074	</span>		return 0, ErrBodyNotAllowed
<span id="L5075" class="ln">  5075	</span>	}
<span id="L5076" class="ln">  5076	</span>	rws.wroteBytes += int64(len(dataB)) + int64(len(dataS))
<span id="L5077" class="ln">  5077	</span>	if rws.sentContentLen != 0 &amp;&amp; rws.wroteBytes &gt; rws.sentContentLen {
<span id="L5078" class="ln">  5078	</span>
<span id="L5079" class="ln">  5079	</span>		return 0, errors.New(&#34;http2: handler wrote more than declared Content-Length&#34;)
<span id="L5080" class="ln">  5080	</span>	}
<span id="L5081" class="ln">  5081	</span>
<span id="L5082" class="ln">  5082	</span>	if dataB != nil {
<span id="L5083" class="ln">  5083	</span>		return rws.bw.Write(dataB)
<span id="L5084" class="ln">  5084	</span>	} else {
<span id="L5085" class="ln">  5085	</span>		return rws.bw.WriteString(dataS)
<span id="L5086" class="ln">  5086	</span>	}
<span id="L5087" class="ln">  5087	</span>}
<span id="L5088" class="ln">  5088	</span>
<span id="L5089" class="ln">  5089	</span>func (w *http2responseWriter) handlerDone() {
<span id="L5090" class="ln">  5090	</span>	rws := w.rws
<span id="L5091" class="ln">  5091	</span>	rws.handlerDone = true
<span id="L5092" class="ln">  5092	</span>	w.Flush()
<span id="L5093" class="ln">  5093	</span>	w.rws = nil
<span id="L5094" class="ln">  5094	</span>	http2responseWriterStatePool.Put(rws)
<span id="L5095" class="ln">  5095	</span>}
<span id="L5096" class="ln">  5096	</span>
<span id="L5097" class="ln">  5097	</span><span class="comment">// Push errors.</span>
<span id="L5098" class="ln">  5098	</span>var (
<span id="L5099" class="ln">  5099	</span>	http2ErrRecursivePush    = errors.New(&#34;http2: recursive push not allowed&#34;)
<span id="L5100" class="ln">  5100	</span>	http2ErrPushLimitReached = errors.New(&#34;http2: push would exceed peer&#39;s SETTINGS_MAX_CONCURRENT_STREAMS&#34;)
<span id="L5101" class="ln">  5101	</span>)
<span id="L5102" class="ln">  5102	</span>
<span id="L5103" class="ln">  5103	</span><span class="comment">// pushOptions is the internal version of http.PushOptions, which we</span>
<span id="L5104" class="ln">  5104	</span><span class="comment">// cannot include here because it&#39;s only defined in Go 1.8 and later.</span>
<span id="L5105" class="ln">  5105	</span>type http2pushOptions struct {
<span id="L5106" class="ln">  5106	</span>	Method string
<span id="L5107" class="ln">  5107	</span>	Header Header
<span id="L5108" class="ln">  5108	</span>}
<span id="L5109" class="ln">  5109	</span>
<span id="L5110" class="ln">  5110	</span>func (w *http2responseWriter) push(target string, opts http2pushOptions) error {
<span id="L5111" class="ln">  5111	</span>	st := w.rws.stream
<span id="L5112" class="ln">  5112	</span>	sc := st.sc
<span id="L5113" class="ln">  5113	</span>	sc.serveG.checkNotOn()
<span id="L5114" class="ln">  5114	</span>
<span id="L5115" class="ln">  5115	</span>	if st.isPushed() {
<span id="L5116" class="ln">  5116	</span>		return http2ErrRecursivePush
<span id="L5117" class="ln">  5117	</span>	}
<span id="L5118" class="ln">  5118	</span>
<span id="L5119" class="ln">  5119	</span>	if opts.Method == &#34;&#34; {
<span id="L5120" class="ln">  5120	</span>		opts.Method = &#34;GET&#34;
<span id="L5121" class="ln">  5121	</span>	}
<span id="L5122" class="ln">  5122	</span>	if opts.Header == nil {
<span id="L5123" class="ln">  5123	</span>		opts.Header = Header{}
<span id="L5124" class="ln">  5124	</span>	}
<span id="L5125" class="ln">  5125	</span>	wantScheme := &#34;http&#34;
<span id="L5126" class="ln">  5126	</span>	if w.rws.req.TLS != nil {
<span id="L5127" class="ln">  5127	</span>		wantScheme = &#34;https&#34;
<span id="L5128" class="ln">  5128	</span>	}
<span id="L5129" class="ln">  5129	</span>
<span id="L5130" class="ln">  5130	</span>	u, err := url.Parse(target)
<span id="L5131" class="ln">  5131	</span>	if err != nil {
<span id="L5132" class="ln">  5132	</span>		return err
<span id="L5133" class="ln">  5133	</span>	}
<span id="L5134" class="ln">  5134	</span>	if u.Scheme == &#34;&#34; {
<span id="L5135" class="ln">  5135	</span>		if !strings.HasPrefix(target, &#34;/&#34;) {
<span id="L5136" class="ln">  5136	</span>			return fmt.Errorf(&#34;target must be an absolute URL or an absolute path: %q&#34;, target)
<span id="L5137" class="ln">  5137	</span>		}
<span id="L5138" class="ln">  5138	</span>		u.Scheme = wantScheme
<span id="L5139" class="ln">  5139	</span>		u.Host = w.rws.req.Host
<span id="L5140" class="ln">  5140	</span>	} else {
<span id="L5141" class="ln">  5141	</span>		if u.Scheme != wantScheme {
<span id="L5142" class="ln">  5142	</span>			return fmt.Errorf(&#34;cannot push URL with scheme %q from request with scheme %q&#34;, u.Scheme, wantScheme)
<span id="L5143" class="ln">  5143	</span>		}
<span id="L5144" class="ln">  5144	</span>		if u.Host == &#34;&#34; {
<span id="L5145" class="ln">  5145	</span>			return errors.New(&#34;URL must have a host&#34;)
<span id="L5146" class="ln">  5146	</span>		}
<span id="L5147" class="ln">  5147	</span>	}
<span id="L5148" class="ln">  5148	</span>	for k := range opts.Header {
<span id="L5149" class="ln">  5149	</span>		if strings.HasPrefix(k, &#34;:&#34;) {
<span id="L5150" class="ln">  5150	</span>			return fmt.Errorf(&#34;promised request headers cannot include pseudo header %q&#34;, k)
<span id="L5151" class="ln">  5151	</span>		}
<span id="L5152" class="ln">  5152	</span>
<span id="L5153" class="ln">  5153	</span>		switch strings.ToLower(k) {
<span id="L5154" class="ln">  5154	</span>		case &#34;content-length&#34;, &#34;content-encoding&#34;, &#34;trailer&#34;, &#34;te&#34;, &#34;expect&#34;, &#34;host&#34;:
<span id="L5155" class="ln">  5155	</span>			return fmt.Errorf(&#34;promised request headers cannot include %q&#34;, k)
<span id="L5156" class="ln">  5156	</span>		}
<span id="L5157" class="ln">  5157	</span>	}
<span id="L5158" class="ln">  5158	</span>	if err := http2checkValidHTTP2RequestHeaders(opts.Header); err != nil {
<span id="L5159" class="ln">  5159	</span>		return err
<span id="L5160" class="ln">  5160	</span>	}
<span id="L5161" class="ln">  5161	</span>
<span id="L5162" class="ln">  5162	</span>	if opts.Method != &#34;GET&#34; &amp;&amp; opts.Method != &#34;HEAD&#34; {
<span id="L5163" class="ln">  5163	</span>		return fmt.Errorf(&#34;method %q must be GET or HEAD&#34;, opts.Method)
<span id="L5164" class="ln">  5164	</span>	}
<span id="L5165" class="ln">  5165	</span>
<span id="L5166" class="ln">  5166	</span>	msg := http2startPushRequest{
<span id="L5167" class="ln">  5167	</span>		parent: st,
<span id="L5168" class="ln">  5168	</span>		method: opts.Method,
<span id="L5169" class="ln">  5169	</span>		url:    u,
<span id="L5170" class="ln">  5170	</span>		header: http2cloneHeader(opts.Header),
<span id="L5171" class="ln">  5171	</span>		done:   http2errChanPool.Get().(chan error),
<span id="L5172" class="ln">  5172	</span>	}
<span id="L5173" class="ln">  5173	</span>
<span id="L5174" class="ln">  5174	</span>	select {
<span id="L5175" class="ln">  5175	</span>	case &lt;-sc.doneServing:
<span id="L5176" class="ln">  5176	</span>		return http2errClientDisconnected
<span id="L5177" class="ln">  5177	</span>	case &lt;-st.cw:
<span id="L5178" class="ln">  5178	</span>		return http2errStreamClosed
<span id="L5179" class="ln">  5179	</span>	case sc.wantStartPushCh &lt;- msg:
<span id="L5180" class="ln">  5180	</span>	}
<span id="L5181" class="ln">  5181	</span>
<span id="L5182" class="ln">  5182	</span>	select {
<span id="L5183" class="ln">  5183	</span>	case &lt;-sc.doneServing:
<span id="L5184" class="ln">  5184	</span>		return http2errClientDisconnected
<span id="L5185" class="ln">  5185	</span>	case &lt;-st.cw:
<span id="L5186" class="ln">  5186	</span>		return http2errStreamClosed
<span id="L5187" class="ln">  5187	</span>	case err := &lt;-msg.done:
<span id="L5188" class="ln">  5188	</span>		http2errChanPool.Put(msg.done)
<span id="L5189" class="ln">  5189	</span>		return err
<span id="L5190" class="ln">  5190	</span>	}
<span id="L5191" class="ln">  5191	</span>}
<span id="L5192" class="ln">  5192	</span>
<span id="L5193" class="ln">  5193	</span>type http2startPushRequest struct {
<span id="L5194" class="ln">  5194	</span>	parent *http2stream
<span id="L5195" class="ln">  5195	</span>	method string
<span id="L5196" class="ln">  5196	</span>	url    *url.URL
<span id="L5197" class="ln">  5197	</span>	header Header
<span id="L5198" class="ln">  5198	</span>	done   chan error
<span id="L5199" class="ln">  5199	</span>}
<span id="L5200" class="ln">  5200	</span>
<span id="L5201" class="ln">  5201	</span>func (sc *http2serverConn) startPush(msg http2startPushRequest) {
<span id="L5202" class="ln">  5202	</span>	sc.serveG.check()
<span id="L5203" class="ln">  5203	</span>
<span id="L5204" class="ln">  5204	</span>	if msg.parent.state != http2stateOpen &amp;&amp; msg.parent.state != http2stateHalfClosedRemote {
<span id="L5205" class="ln">  5205	</span>
<span id="L5206" class="ln">  5206	</span>		msg.done &lt;- http2errStreamClosed
<span id="L5207" class="ln">  5207	</span>		return
<span id="L5208" class="ln">  5208	</span>	}
<span id="L5209" class="ln">  5209	</span>
<span id="L5210" class="ln">  5210	</span>	if !sc.pushEnabled {
<span id="L5211" class="ln">  5211	</span>		msg.done &lt;- ErrNotSupported
<span id="L5212" class="ln">  5212	</span>		return
<span id="L5213" class="ln">  5213	</span>	}
<span id="L5214" class="ln">  5214	</span>
<span id="L5215" class="ln">  5215	</span>	allocatePromisedID := func() (uint32, error) {
<span id="L5216" class="ln">  5216	</span>		sc.serveG.check()
<span id="L5217" class="ln">  5217	</span>
<span id="L5218" class="ln">  5218	</span>		if !sc.pushEnabled {
<span id="L5219" class="ln">  5219	</span>			return 0, ErrNotSupported
<span id="L5220" class="ln">  5220	</span>		}
<span id="L5221" class="ln">  5221	</span>
<span id="L5222" class="ln">  5222	</span>		if sc.curPushedStreams+1 &gt; sc.clientMaxStreams {
<span id="L5223" class="ln">  5223	</span>			return 0, http2ErrPushLimitReached
<span id="L5224" class="ln">  5224	</span>		}
<span id="L5225" class="ln">  5225	</span>
<span id="L5226" class="ln">  5226	</span>		if sc.maxPushPromiseID+2 &gt;= 1&lt;&lt;31 {
<span id="L5227" class="ln">  5227	</span>			sc.startGracefulShutdown()
<span id="L5228" class="ln">  5228	</span>			return 0, http2ErrPushLimitReached
<span id="L5229" class="ln">  5229	</span>		}
<span id="L5230" class="ln">  5230	</span>		sc.maxPushPromiseID += 2
<span id="L5231" class="ln">  5231	</span>		promisedID := sc.maxPushPromiseID
<span id="L5232" class="ln">  5232	</span>
<span id="L5233" class="ln">  5233	</span>		promised := sc.newStream(promisedID, msg.parent.id, http2stateHalfClosedRemote)
<span id="L5234" class="ln">  5234	</span>		rw, req, err := sc.newWriterAndRequestNoBody(promised, http2requestParam{
<span id="L5235" class="ln">  5235	</span>			method:    msg.method,
<span id="L5236" class="ln">  5236	</span>			scheme:    msg.url.Scheme,
<span id="L5237" class="ln">  5237	</span>			authority: msg.url.Host,
<span id="L5238" class="ln">  5238	</span>			path:      msg.url.RequestURI(),
<span id="L5239" class="ln">  5239	</span>			header:    http2cloneHeader(msg.header),
<span id="L5240" class="ln">  5240	</span>		})
<span id="L5241" class="ln">  5241	</span>		if err != nil {
<span id="L5242" class="ln">  5242	</span>
<span id="L5243" class="ln">  5243	</span>			panic(fmt.Sprintf(&#34;newWriterAndRequestNoBody(%+v): %v&#34;, msg.url, err))
<span id="L5244" class="ln">  5244	</span>		}
<span id="L5245" class="ln">  5245	</span>
<span id="L5246" class="ln">  5246	</span>		go sc.runHandler(rw, req, sc.handler.ServeHTTP)
<span id="L5247" class="ln">  5247	</span>		return promisedID, nil
<span id="L5248" class="ln">  5248	</span>	}
<span id="L5249" class="ln">  5249	</span>
<span id="L5250" class="ln">  5250	</span>	sc.writeFrame(http2FrameWriteRequest{
<span id="L5251" class="ln">  5251	</span>		write: &amp;http2writePushPromise{
<span id="L5252" class="ln">  5252	</span>			streamID:           msg.parent.id,
<span id="L5253" class="ln">  5253	</span>			method:             msg.method,
<span id="L5254" class="ln">  5254	</span>			url:                msg.url,
<span id="L5255" class="ln">  5255	</span>			h:                  msg.header,
<span id="L5256" class="ln">  5256	</span>			allocatePromisedID: allocatePromisedID,
<span id="L5257" class="ln">  5257	</span>		},
<span id="L5258" class="ln">  5258	</span>		stream: msg.parent,
<span id="L5259" class="ln">  5259	</span>		done:   msg.done,
<span id="L5260" class="ln">  5260	</span>	})
<span id="L5261" class="ln">  5261	</span>}
<span id="L5262" class="ln">  5262	</span>
<span id="L5263" class="ln">  5263	</span><span class="comment">// foreachHeaderElement splits v according to the &#34;#rule&#34; construction</span>
<span id="L5264" class="ln">  5264	</span><span class="comment">// in RFC 2616 section 2.1 and calls fn for each non-empty element.</span>
<span id="L5265" class="ln">  5265	</span>func http2foreachHeaderElement(v string, fn func(string)) {
<span id="L5266" class="ln">  5266	</span>	v = textproto.TrimString(v)
<span id="L5267" class="ln">  5267	</span>	if v == &#34;&#34; {
<span id="L5268" class="ln">  5268	</span>		return
<span id="L5269" class="ln">  5269	</span>	}
<span id="L5270" class="ln">  5270	</span>	if !strings.Contains(v, &#34;,&#34;) {
<span id="L5271" class="ln">  5271	</span>		fn(v)
<span id="L5272" class="ln">  5272	</span>		return
<span id="L5273" class="ln">  5273	</span>	}
<span id="L5274" class="ln">  5274	</span>	for _, f := range strings.Split(v, &#34;,&#34;) {
<span id="L5275" class="ln">  5275	</span>		if f = textproto.TrimString(f); f != &#34;&#34; {
<span id="L5276" class="ln">  5276	</span>			fn(f)
<span id="L5277" class="ln">  5277	</span>		}
<span id="L5278" class="ln">  5278	</span>	}
<span id="L5279" class="ln">  5279	</span>}
<span id="L5280" class="ln">  5280	</span>
<span id="L5281" class="ln">  5281	</span><span class="comment">// From http://httpwg.org/specs/rfc7540.html#rfc.section.8.1.2.2</span>
<span id="L5282" class="ln">  5282	</span>var http2connHeaders = []string{
<span id="L5283" class="ln">  5283	</span>	&#34;Connection&#34;,
<span id="L5284" class="ln">  5284	</span>	&#34;Keep-Alive&#34;,
<span id="L5285" class="ln">  5285	</span>	&#34;Proxy-Connection&#34;,
<span id="L5286" class="ln">  5286	</span>	&#34;Transfer-Encoding&#34;,
<span id="L5287" class="ln">  5287	</span>	&#34;Upgrade&#34;,
<span id="L5288" class="ln">  5288	</span>}
<span id="L5289" class="ln">  5289	</span>
<span id="L5290" class="ln">  5290	</span><span class="comment">// checkValidHTTP2RequestHeaders checks whether h is a valid HTTP/2 request,</span>
<span id="L5291" class="ln">  5291	</span><span class="comment">// per RFC 7540 Section 8.1.2.2.</span>
<span id="L5292" class="ln">  5292	</span><span class="comment">// The returned error is reported to users.</span>
<span id="L5293" class="ln">  5293	</span>func http2checkValidHTTP2RequestHeaders(h Header) error {
<span id="L5294" class="ln">  5294	</span>	for _, k := range http2connHeaders {
<span id="L5295" class="ln">  5295	</span>		if _, ok := h[k]; ok {
<span id="L5296" class="ln">  5296	</span>			return fmt.Errorf(&#34;request header %q is not valid in HTTP/2&#34;, k)
<span id="L5297" class="ln">  5297	</span>		}
<span id="L5298" class="ln">  5298	</span>	}
<span id="L5299" class="ln">  5299	</span>	te := h[&#34;Te&#34;]
<span id="L5300" class="ln">  5300	</span>	if len(te) &gt; 0 &amp;&amp; (len(te) &gt; 1 || (te[0] != &#34;trailers&#34; &amp;&amp; te[0] != &#34;&#34;)) {
<span id="L5301" class="ln">  5301	</span>		return errors.New(`request header &#34;TE&#34; may only be &#34;trailers&#34; in HTTP/2`)
<span id="L5302" class="ln">  5302	</span>	}
<span id="L5303" class="ln">  5303	</span>	return nil
<span id="L5304" class="ln">  5304	</span>}
<span id="L5305" class="ln">  5305	</span>
<span id="L5306" class="ln">  5306	</span>func http2new400Handler(err error) HandlerFunc {
<span id="L5307" class="ln">  5307	</span>	return func(w ResponseWriter, r *Request) {
<span id="L5308" class="ln">  5308	</span>		Error(w, err.Error(), StatusBadRequest)
<span id="L5309" class="ln">  5309	</span>	}
<span id="L5310" class="ln">  5310	</span>}
<span id="L5311" class="ln">  5311	</span>
<span id="L5312" class="ln">  5312	</span><span class="comment">// ValidTrailerHeader reports whether name is a valid header field name to appear</span>
<span id="L5313" class="ln">  5313	</span><span class="comment">// in trailers.</span>
<span id="L5314" class="ln">  5314	</span><span class="comment">// See: http://tools.ietf.org/html/rfc7230#section-4.1.2</span>
<span id="L5315" class="ln">  5315	</span>func http2ValidTrailerHeader(name string) bool {
<span id="L5316" class="ln">  5316	</span>	name = CanonicalHeaderKey(name)
<span id="L5317" class="ln">  5317	</span>	if strings.HasPrefix(name, &#34;If-&#34;) || http2badTrailer[name] {
<span id="L5318" class="ln">  5318	</span>		return false
<span id="L5319" class="ln">  5319	</span>	}
<span id="L5320" class="ln">  5320	</span>	return true
<span id="L5321" class="ln">  5321	</span>}
<span id="L5322" class="ln">  5322	</span>
<span id="L5323" class="ln">  5323	</span>var http2badTrailer = map[string]bool{
<span id="L5324" class="ln">  5324	</span>	&#34;Authorization&#34;:       true,
<span id="L5325" class="ln">  5325	</span>	&#34;Cache-Control&#34;:       true,
<span id="L5326" class="ln">  5326	</span>	&#34;Connection&#34;:          true,
<span id="L5327" class="ln">  5327	</span>	&#34;Content-Encoding&#34;:    true,
<span id="L5328" class="ln">  5328	</span>	&#34;Content-Length&#34;:      true,
<span id="L5329" class="ln">  5329	</span>	&#34;Content-Range&#34;:       true,
<span id="L5330" class="ln">  5330	</span>	&#34;Content-Type&#34;:        true,
<span id="L5331" class="ln">  5331	</span>	&#34;Expect&#34;:              true,
<span id="L5332" class="ln">  5332	</span>	&#34;Host&#34;:                true,
<span id="L5333" class="ln">  5333	</span>	&#34;Keep-Alive&#34;:          true,
<span id="L5334" class="ln">  5334	</span>	&#34;Max-Forwards&#34;:        true,
<span id="L5335" class="ln">  5335	</span>	&#34;Pragma&#34;:              true,
<span id="L5336" class="ln">  5336	</span>	&#34;Proxy-Authenticate&#34;:  true,
<span id="L5337" class="ln">  5337	</span>	&#34;Proxy-Authorization&#34;: true,
<span id="L5338" class="ln">  5338	</span>	&#34;Proxy-Connection&#34;:    true,
<span id="L5339" class="ln">  5339	</span>	&#34;Range&#34;:               true,
<span id="L5340" class="ln">  5340	</span>	&#34;Realm&#34;:               true,
<span id="L5341" class="ln">  5341	</span>	&#34;Te&#34;:                  true,
<span id="L5342" class="ln">  5342	</span>	&#34;Trailer&#34;:             true,
<span id="L5343" class="ln">  5343	</span>	&#34;Transfer-Encoding&#34;:   true,
<span id="L5344" class="ln">  5344	</span>	&#34;Www-Authenticate&#34;:    true,
<span id="L5345" class="ln">  5345	</span>}
<span id="L5346" class="ln">  5346	</span>
<span id="L5347" class="ln">  5347	</span><span class="comment">// h1ServerShutdownChan returns a channel that will be closed when the</span>
<span id="L5348" class="ln">  5348	</span><span class="comment">// provided *http.Server wants to shut down.</span>
<span id="L5349" class="ln">  5349	</span><span class="comment">//</span>
<span id="L5350" class="ln">  5350	</span><span class="comment">// This is a somewhat hacky way to get at http1 innards. It works</span>
<span id="L5351" class="ln">  5351	</span><span class="comment">// when the http2 code is bundled into the net/http package in the</span>
<span id="L5352" class="ln">  5352	</span><span class="comment">// standard library. The alternatives ended up making the cmd/go tool</span>
<span id="L5353" class="ln">  5353	</span><span class="comment">// depend on http Servers. This is the lightest option for now.</span>
<span id="L5354" class="ln">  5354	</span><span class="comment">// This is tested via the TestServeShutdown* tests in net/http.</span>
<span id="L5355" class="ln">  5355	</span>func http2h1ServerShutdownChan(hs *Server) &lt;-chan struct{} {
<span id="L5356" class="ln">  5356	</span>	if fn := http2testh1ServerShutdownChan; fn != nil {
<span id="L5357" class="ln">  5357	</span>		return fn(hs)
<span id="L5358" class="ln">  5358	</span>	}
<span id="L5359" class="ln">  5359	</span>	var x interface{} = hs
<span id="L5360" class="ln">  5360	</span>	type I interface {
<span id="L5361" class="ln">  5361	</span>		getDoneChan() &lt;-chan struct{}
<span id="L5362" class="ln">  5362	</span>	}
<span id="L5363" class="ln">  5363	</span>	if hs, ok := x.(I); ok {
<span id="L5364" class="ln">  5364	</span>		return hs.getDoneChan()
<span id="L5365" class="ln">  5365	</span>	}
<span id="L5366" class="ln">  5366	</span>	return nil
<span id="L5367" class="ln">  5367	</span>}
<span id="L5368" class="ln">  5368	</span>
<span id="L5369" class="ln">  5369	</span><span class="comment">// optional test hook for h1ServerShutdownChan.</span>
<span id="L5370" class="ln">  5370	</span>var http2testh1ServerShutdownChan func(hs *Server) &lt;-chan struct{}
<span id="L5371" class="ln">  5371	</span>
<span id="L5372" class="ln">  5372	</span><span class="comment">// h1ServerKeepAlivesDisabled reports whether hs has its keep-alives</span>
<span id="L5373" class="ln">  5373	</span><span class="comment">// disabled. See comments on h1ServerShutdownChan above for why</span>
<span id="L5374" class="ln">  5374	</span><span class="comment">// the code is written this way.</span>
<span id="L5375" class="ln">  5375	</span>func http2h1ServerKeepAlivesDisabled(hs *Server) bool {
<span id="L5376" class="ln">  5376	</span>	var x interface{} = hs
<span id="L5377" class="ln">  5377	</span>	type I interface {
<span id="L5378" class="ln">  5378	</span>		doKeepAlives() bool
<span id="L5379" class="ln">  5379	</span>	}
<span id="L5380" class="ln">  5380	</span>	if hs, ok := x.(I); ok {
<span id="L5381" class="ln">  5381	</span>		return !hs.doKeepAlives()
<span id="L5382" class="ln">  5382	</span>	}
<span id="L5383" class="ln">  5383	</span>	return false
<span id="L5384" class="ln">  5384	</span>}
<span id="L5385" class="ln">  5385	</span>
<span id="L5386" class="ln">  5386	</span>const (
<span id="L5387" class="ln">  5387	</span>	<span class="comment">// transportDefaultConnFlow is how many connection-level flow control</span>
<span id="L5388" class="ln">  5388	</span>	<span class="comment">// tokens we give the server at start-up, past the default 64k.</span>
<span id="L5389" class="ln">  5389	</span>	http2transportDefaultConnFlow = 1 &lt;&lt; 30
<span id="L5390" class="ln">  5390	</span>
<span id="L5391" class="ln">  5391	</span>	<span class="comment">// transportDefaultStreamFlow is how many stream-level flow</span>
<span id="L5392" class="ln">  5392	</span>	<span class="comment">// control tokens we announce to the peer, and how many bytes</span>
<span id="L5393" class="ln">  5393	</span>	<span class="comment">// we buffer per stream.</span>
<span id="L5394" class="ln">  5394	</span>	http2transportDefaultStreamFlow = 4 &lt;&lt; 20
<span id="L5395" class="ln">  5395	</span>
<span id="L5396" class="ln">  5396	</span>	<span class="comment">// transportDefaultStreamMinRefresh is the minimum number of bytes we&#39;ll send</span>
<span id="L5397" class="ln">  5397	</span>	<span class="comment">// a stream-level WINDOW_UPDATE for at a time.</span>
<span id="L5398" class="ln">  5398	</span>	http2transportDefaultStreamMinRefresh = 4 &lt;&lt; 10
<span id="L5399" class="ln">  5399	</span>
<span id="L5400" class="ln">  5400	</span>	http2defaultUserAgent = &#34;Go-http-client/2.0&#34;
<span id="L5401" class="ln">  5401	</span>)
<span id="L5402" class="ln">  5402	</span>
<span id="L5403" class="ln">  5403	</span><span class="comment">// Transport is an HTTP/2 Transport.</span>
<span id="L5404" class="ln">  5404	</span><span class="comment">//</span>
<span id="L5405" class="ln">  5405	</span><span class="comment">// A Transport internally caches connections to servers. It is safe</span>
<span id="L5406" class="ln">  5406	</span><span class="comment">// for concurrent use by multiple goroutines.</span>
<span id="L5407" class="ln">  5407	</span>type http2Transport struct {
<span id="L5408" class="ln">  5408	</span>	<span class="comment">// DialTLS specifies an optional dial function for creating</span>
<span id="L5409" class="ln">  5409	</span>	<span class="comment">// TLS connections for requests.</span>
<span id="L5410" class="ln">  5410	</span>	<span class="comment">//</span>
<span id="L5411" class="ln">  5411	</span>	<span class="comment">// If DialTLS is nil, tls.Dial is used.</span>
<span id="L5412" class="ln">  5412	</span>	<span class="comment">//</span>
<span id="L5413" class="ln">  5413	</span>	<span class="comment">// If the returned net.Conn has a ConnectionState method like tls.Conn,</span>
<span id="L5414" class="ln">  5414	</span>	<span class="comment">// it will be used to set http.Response.TLS.</span>
<span id="L5415" class="ln">  5415	</span>	DialTLS func(network, addr string, cfg *tls.Config) (net.Conn, error)
<span id="L5416" class="ln">  5416	</span>
<span id="L5417" class="ln">  5417	</span>	<span class="comment">// TLSClientConfig specifies the TLS configuration to use with</span>
<span id="L5418" class="ln">  5418	</span>	<span class="comment">// tls.Client. If nil, the default configuration is used.</span>
<span id="L5419" class="ln">  5419	</span>	TLSClientConfig *tls.Config
<span id="L5420" class="ln">  5420	</span>
<span id="L5421" class="ln">  5421	</span>	<span class="comment">// ConnPool optionally specifies an alternate connection pool to use.</span>
<span id="L5422" class="ln">  5422	</span>	<span class="comment">// If nil, the default is used.</span>
<span id="L5423" class="ln">  5423	</span>	ConnPool http2ClientConnPool
<span id="L5424" class="ln">  5424	</span>
<span id="L5425" class="ln">  5425	</span>	<span class="comment">// DisableCompression, if true, prevents the Transport from</span>
<span id="L5426" class="ln">  5426	</span>	<span class="comment">// requesting compression with an &#34;Accept-Encoding: gzip&#34;</span>
<span id="L5427" class="ln">  5427	</span>	<span class="comment">// request header when the Request contains no existing</span>
<span id="L5428" class="ln">  5428	</span>	<span class="comment">// Accept-Encoding value. If the Transport requests gzip on</span>
<span id="L5429" class="ln">  5429	</span>	<span class="comment">// its own and gets a gzipped response, it&#39;s transparently</span>
<span id="L5430" class="ln">  5430	</span>	<span class="comment">// decoded in the Response.Body. However, if the user</span>
<span id="L5431" class="ln">  5431	</span>	<span class="comment">// explicitly requested gzip it is not automatically</span>
<span id="L5432" class="ln">  5432	</span>	<span class="comment">// uncompressed.</span>
<span id="L5433" class="ln">  5433	</span>	DisableCompression bool
<span id="L5434" class="ln">  5434	</span>
<span id="L5435" class="ln">  5435	</span>	<span class="comment">// AllowHTTP, if true, permits HTTP/2 requests using the insecure,</span>
<span id="L5436" class="ln">  5436	</span>	<span class="comment">// plain-text &#34;http&#34; scheme. Note that this does not enable h2c support.</span>
<span id="L5437" class="ln">  5437	</span>	AllowHTTP bool
<span id="L5438" class="ln">  5438	</span>
<span id="L5439" class="ln">  5439	</span>	<span class="comment">// MaxHeaderListSize is the http2 SETTINGS_MAX_HEADER_LIST_SIZE to</span>
<span id="L5440" class="ln">  5440	</span>	<span class="comment">// send in the initial settings frame. It is how many bytes</span>
<span id="L5441" class="ln">  5441	</span>	<span class="comment">// of response headers are allow. Unlike the http2 spec, zero here</span>
<span id="L5442" class="ln">  5442	</span>	<span class="comment">// means to use a default limit (currently 10MB). If you actually</span>
<span id="L5443" class="ln">  5443	</span>	<span class="comment">// want to advertise an ulimited value to the peer, Transport</span>
<span id="L5444" class="ln">  5444	</span>	<span class="comment">// interprets the highest possible value here (0xffffffff or 1&lt;&lt;32-1)</span>
<span id="L5445" class="ln">  5445	</span>	<span class="comment">// to mean no limit.</span>
<span id="L5446" class="ln">  5446	</span>	MaxHeaderListSize uint32
<span id="L5447" class="ln">  5447	</span>
<span id="L5448" class="ln">  5448	</span>	<span class="comment">// t1, if non-nil, is the standard library Transport using</span>
<span id="L5449" class="ln">  5449	</span>	<span class="comment">// this transport. Its settings are used (but not its</span>
<span id="L5450" class="ln">  5450	</span>	<span class="comment">// RoundTrip method, etc).</span>
<span id="L5451" class="ln">  5451	</span>	t1 *Transport
<span id="L5452" class="ln">  5452	</span>
<span id="L5453" class="ln">  5453	</span>	connPoolOnce  sync.Once
<span id="L5454" class="ln">  5454	</span>	connPoolOrDef http2ClientConnPool <span class="comment">// non-nil version of ConnPool</span>
<span id="L5455" class="ln">  5455	</span>}
<span id="L5456" class="ln">  5456	</span>
<span id="L5457" class="ln">  5457	</span>func (t *http2Transport) maxHeaderListSize() uint32 {
<span id="L5458" class="ln">  5458	</span>	if t.MaxHeaderListSize == 0 {
<span id="L5459" class="ln">  5459	</span>		return 10 &lt;&lt; 20
<span id="L5460" class="ln">  5460	</span>	}
<span id="L5461" class="ln">  5461	</span>	if t.MaxHeaderListSize == 0xffffffff {
<span id="L5462" class="ln">  5462	</span>		return 0
<span id="L5463" class="ln">  5463	</span>	}
<span id="L5464" class="ln">  5464	</span>	return t.MaxHeaderListSize
<span id="L5465" class="ln">  5465	</span>}
<span id="L5466" class="ln">  5466	</span>
<span id="L5467" class="ln">  5467	</span>func (t *http2Transport) disableCompression() bool {
<span id="L5468" class="ln">  5468	</span>	return t.DisableCompression || (t.t1 != nil &amp;&amp; t.t1.DisableCompression)
<span id="L5469" class="ln">  5469	</span>}
<span id="L5470" class="ln">  5470	</span>
<span id="L5471" class="ln">  5471	</span>var http2errTransportVersion = errors.New(&#34;http2: ConfigureTransport is only supported starting at Go 1.6&#34;)
<span id="L5472" class="ln">  5472	</span>
<span id="L5473" class="ln">  5473	</span><span class="comment">// ConfigureTransport configures a net/http HTTP/1 Transport to use HTTP/2.</span>
<span id="L5474" class="ln">  5474	</span><span class="comment">// It requires Go 1.6 or later and returns an error if the net/http package is too old</span>
<span id="L5475" class="ln">  5475	</span><span class="comment">// or if t1 has already been HTTP/2-enabled.</span>
<span id="L5476" class="ln">  5476	</span>func http2ConfigureTransport(t1 *Transport) error {
<span id="L5477" class="ln">  5477	</span>	_, err := http2configureTransport(t1)
<span id="L5478" class="ln">  5478	</span>	return err
<span id="L5479" class="ln">  5479	</span>}
<span id="L5480" class="ln">  5480	</span>
<span id="L5481" class="ln">  5481	</span>func (t *http2Transport) connPool() http2ClientConnPool {
<span id="L5482" class="ln">  5482	</span>	t.connPoolOnce.Do(t.initConnPool)
<span id="L5483" class="ln">  5483	</span>	return t.connPoolOrDef
<span id="L5484" class="ln">  5484	</span>}
<span id="L5485" class="ln">  5485	</span>
<span id="L5486" class="ln">  5486	</span>func (t *http2Transport) initConnPool() {
<span id="L5487" class="ln">  5487	</span>	if t.ConnPool != nil {
<span id="L5488" class="ln">  5488	</span>		t.connPoolOrDef = t.ConnPool
<span id="L5489" class="ln">  5489	</span>	} else {
<span id="L5490" class="ln">  5490	</span>		t.connPoolOrDef = &amp;http2clientConnPool{t: t}
<span id="L5491" class="ln">  5491	</span>	}
<span id="L5492" class="ln">  5492	</span>}
<span id="L5493" class="ln">  5493	</span>
<span id="L5494" class="ln">  5494	</span><span class="comment">// ClientConn is the state of a single HTTP/2 client connection to an</span>
<span id="L5495" class="ln">  5495	</span><span class="comment">// HTTP/2 server.</span>
<span id="L5496" class="ln">  5496	</span>type http2ClientConn struct {
<span id="L5497" class="ln">  5497	</span>	t         *http2Transport
<span id="L5498" class="ln">  5498	</span>	tconn     net.Conn             <span class="comment">// usually *tls.Conn, except specialized impls</span>
<span id="L5499" class="ln">  5499	</span>	tlsState  *tls.ConnectionState <span class="comment">// nil only for specialized impls</span>
<span id="L5500" class="ln">  5500	</span>	singleUse bool                 <span class="comment">// whether being used for a single http.Request</span>
<span id="L5501" class="ln">  5501	</span>
<span id="L5502" class="ln">  5502	</span>	<span class="comment">// readLoop goroutine fields:</span>
<span id="L5503" class="ln">  5503	</span>	readerDone chan struct{} <span class="comment">// closed on error</span>
<span id="L5504" class="ln">  5504	</span>	readerErr  error         <span class="comment">// set before readerDone is closed</span>
<span id="L5505" class="ln">  5505	</span>
<span id="L5506" class="ln">  5506	</span>	idleTimeout time.Duration <span class="comment">// or 0 for never</span>
<span id="L5507" class="ln">  5507	</span>	idleTimer   *time.Timer
<span id="L5508" class="ln">  5508	</span>
<span id="L5509" class="ln">  5509	</span>	mu              sync.Mutex <span class="comment">// guards following</span>
<span id="L5510" class="ln">  5510	</span>	cond            *sync.Cond <span class="comment">// hold mu; broadcast on flow/closed changes</span>
<span id="L5511" class="ln">  5511	</span>	flow            http2flow  <span class="comment">// our conn-level flow control quota (cs.flow is per stream)</span>
<span id="L5512" class="ln">  5512	</span>	inflow          http2flow  <span class="comment">// peer&#39;s conn-level flow control</span>
<span id="L5513" class="ln">  5513	</span>	closed          bool
<span id="L5514" class="ln">  5514	</span>	wantSettingsAck bool                          <span class="comment">// we sent a SETTINGS frame and haven&#39;t heard back</span>
<span id="L5515" class="ln">  5515	</span>	goAway          *http2GoAwayFrame             <span class="comment">// if non-nil, the GoAwayFrame we received</span>
<span id="L5516" class="ln">  5516	</span>	goAwayDebug     string                        <span class="comment">// goAway frame&#39;s debug data, retained as a string</span>
<span id="L5517" class="ln">  5517	</span>	streams         map[uint32]*http2clientStream <span class="comment">// client-initiated</span>
<span id="L5518" class="ln">  5518	</span>	nextStreamID    uint32
<span id="L5519" class="ln">  5519	</span>	pings           map[[8]byte]chan struct{} <span class="comment">// in flight ping data to notification channel</span>
<span id="L5520" class="ln">  5520	</span>	bw              *bufio.Writer
<span id="L5521" class="ln">  5521	</span>	br              *bufio.Reader
<span id="L5522" class="ln">  5522	</span>	fr              *http2Framer
<span id="L5523" class="ln">  5523	</span>	lastActive      time.Time
<span id="L5524" class="ln">  5524	</span>	<span class="comment">// Settings from peer: (also guarded by mu)</span>
<span id="L5525" class="ln">  5525	</span>	maxFrameSize         uint32
<span id="L5526" class="ln">  5526	</span>	maxConcurrentStreams uint32
<span id="L5527" class="ln">  5527	</span>	initialWindowSize    uint32
<span id="L5528" class="ln">  5528	</span>
<span id="L5529" class="ln">  5529	</span>	hbuf    bytes.Buffer <span class="comment">// HPACK encoder writes into this</span>
<span id="L5530" class="ln">  5530	</span>	henc    *hpack.Encoder
<span id="L5531" class="ln">  5531	</span>	freeBuf [][]byte
<span id="L5532" class="ln">  5532	</span>
<span id="L5533" class="ln">  5533	</span>	wmu  sync.Mutex <span class="comment">// held while writing; acquire AFTER mu if holding both</span>
<span id="L5534" class="ln">  5534	</span>	werr error      <span class="comment">// first write error that has occurred</span>
<span id="L5535" class="ln">  5535	</span>}
<span id="L5536" class="ln">  5536	</span>
<span id="L5537" class="ln">  5537	</span><span class="comment">// clientStream is the state for a single HTTP/2 stream. One of these</span>
<span id="L5538" class="ln">  5538	</span><span class="comment">// is created for each Transport.RoundTrip call.</span>
<span id="L5539" class="ln">  5539	</span>type http2clientStream struct {
<span id="L5540" class="ln">  5540	</span>	cc            *http2ClientConn
<span id="L5541" class="ln">  5541	</span>	req           *Request
<span id="L5542" class="ln">  5542	</span>	trace         *http2clientTrace <span class="comment">// or nil</span>
<span id="L5543" class="ln">  5543	</span>	ID            uint32
<span id="L5544" class="ln">  5544	</span>	resc          chan http2resAndError
<span id="L5545" class="ln">  5545	</span>	bufPipe       http2pipe <span class="comment">// buffered pipe with the flow-controlled response payload</span>
<span id="L5546" class="ln">  5546	</span>	startedWrite  bool      <span class="comment">// started request body write; guarded by cc.mu</span>
<span id="L5547" class="ln">  5547	</span>	requestedGzip bool
<span id="L5548" class="ln">  5548	</span>	on100         func() <span class="comment">// optional code to run if get a 100 continue response</span>
<span id="L5549" class="ln">  5549	</span>
<span id="L5550" class="ln">  5550	</span>	flow        http2flow <span class="comment">// guarded by cc.mu</span>
<span id="L5551" class="ln">  5551	</span>	inflow      http2flow <span class="comment">// guarded by cc.mu</span>
<span id="L5552" class="ln">  5552	</span>	bytesRemain int64     <span class="comment">// -1 means unknown; owned by transportResponseBody.Read</span>
<span id="L5553" class="ln">  5553	</span>	readErr     error     <span class="comment">// sticky read error; owned by transportResponseBody.Read</span>
<span id="L5554" class="ln">  5554	</span>	stopReqBody error     <span class="comment">// if non-nil, stop writing req body; guarded by cc.mu</span>
<span id="L5555" class="ln">  5555	</span>	didReset    bool      <span class="comment">// whether we sent a RST_STREAM to the server; guarded by cc.mu</span>
<span id="L5556" class="ln">  5556	</span>
<span id="L5557" class="ln">  5557	</span>	peerReset chan struct{} <span class="comment">// closed on peer reset</span>
<span id="L5558" class="ln">  5558	</span>	resetErr  error         <span class="comment">// populated before peerReset is closed</span>
<span id="L5559" class="ln">  5559	</span>
<span id="L5560" class="ln">  5560	</span>	done chan struct{} <span class="comment">// closed when stream remove from cc.streams map; close calls guarded by cc.mu</span>
<span id="L5561" class="ln">  5561	</span>
<span id="L5562" class="ln">  5562	</span>	<span class="comment">// owned by clientConnReadLoop:</span>
<span id="L5563" class="ln">  5563	</span>	firstByte    bool <span class="comment">// got the first response byte</span>
<span id="L5564" class="ln">  5564	</span>	pastHeaders  bool <span class="comment">// got first MetaHeadersFrame (actual headers)</span>
<span id="L5565" class="ln">  5565	</span>	pastTrailers bool <span class="comment">// got optional second MetaHeadersFrame (trailers)</span>
<span id="L5566" class="ln">  5566	</span>
<span id="L5567" class="ln">  5567	</span>	trailer    Header  <span class="comment">// accumulated trailers</span>
<span id="L5568" class="ln">  5568	</span>	resTrailer *Header <span class="comment">// client&#39;s Response.Trailer</span>
<span id="L5569" class="ln">  5569	</span>}
<span id="L5570" class="ln">  5570	</span>
<span id="L5571" class="ln">  5571	</span><span class="comment">// awaitRequestCancel runs in its own goroutine and waits for the user</span>
<span id="L5572" class="ln">  5572	</span><span class="comment">// to cancel a RoundTrip request, its context to expire, or for the</span>
<span id="L5573" class="ln">  5573	</span><span class="comment">// request to be done (any way it might be removed from the cc.streams</span>
<span id="L5574" class="ln">  5574	</span><span class="comment">// map: peer reset, successful completion, TCP connection breakage,</span>
<span id="L5575" class="ln">  5575	</span><span class="comment">// etc)</span>
<span id="L5576" class="ln">  5576	</span>func (cs *http2clientStream) awaitRequestCancel(req *Request) {
<span id="L5577" class="ln">  5577	</span>	ctx := http2reqContext(req)
<span id="L5578" class="ln">  5578	</span>	if req.Cancel == nil &amp;&amp; ctx.Done() == nil {
<span id="L5579" class="ln">  5579	</span>		return
<span id="L5580" class="ln">  5580	</span>	}
<span id="L5581" class="ln">  5581	</span>	select {
<span id="L5582" class="ln">  5582	</span>	case &lt;-req.Cancel:
<span id="L5583" class="ln">  5583	</span>		cs.cancelStream()
<span id="L5584" class="ln">  5584	</span>		cs.bufPipe.CloseWithError(http2errRequestCanceled)
<span id="L5585" class="ln">  5585	</span>	case &lt;-ctx.Done():
<span id="L5586" class="ln">  5586	</span>		cs.cancelStream()
<span id="L5587" class="ln">  5587	</span>		cs.bufPipe.CloseWithError(ctx.Err())
<span id="L5588" class="ln">  5588	</span>	case &lt;-cs.done:
<span id="L5589" class="ln">  5589	</span>	}
<span id="L5590" class="ln">  5590	</span>}
<span id="L5591" class="ln">  5591	</span>
<span id="L5592" class="ln">  5592	</span>func (cs *http2clientStream) cancelStream() {
<span id="L5593" class="ln">  5593	</span>	cs.cc.mu.Lock()
<span id="L5594" class="ln">  5594	</span>	didReset := cs.didReset
<span id="L5595" class="ln">  5595	</span>	cs.didReset = true
<span id="L5596" class="ln">  5596	</span>	cs.cc.mu.Unlock()
<span id="L5597" class="ln">  5597	</span>
<span id="L5598" class="ln">  5598	</span>	if !didReset {
<span id="L5599" class="ln">  5599	</span>		cs.cc.writeStreamReset(cs.ID, http2ErrCodeCancel, nil)
<span id="L5600" class="ln">  5600	</span>	}
<span id="L5601" class="ln">  5601	</span>}
<span id="L5602" class="ln">  5602	</span>
<span id="L5603" class="ln">  5603	</span><span class="comment">// checkResetOrDone reports any error sent in a RST_STREAM frame by the</span>
<span id="L5604" class="ln">  5604	</span><span class="comment">// server, or errStreamClosed if the stream is complete.</span>
<span id="L5605" class="ln">  5605	</span>func (cs *http2clientStream) checkResetOrDone() error {
<span id="L5606" class="ln">  5606	</span>	select {
<span id="L5607" class="ln">  5607	</span>	case &lt;-cs.peerReset:
<span id="L5608" class="ln">  5608	</span>		return cs.resetErr
<span id="L5609" class="ln">  5609	</span>	case &lt;-cs.done:
<span id="L5610" class="ln">  5610	</span>		return http2errStreamClosed
<span id="L5611" class="ln">  5611	</span>	default:
<span id="L5612" class="ln">  5612	</span>		return nil
<span id="L5613" class="ln">  5613	</span>	}
<span id="L5614" class="ln">  5614	</span>}
<span id="L5615" class="ln">  5615	</span>
<span id="L5616" class="ln">  5616	</span>func (cs *http2clientStream) abortRequestBodyWrite(err error) {
<span id="L5617" class="ln">  5617	</span>	if err == nil {
<span id="L5618" class="ln">  5618	</span>		panic(&#34;nil error&#34;)
<span id="L5619" class="ln">  5619	</span>	}
<span id="L5620" class="ln">  5620	</span>	cc := cs.cc
<span id="L5621" class="ln">  5621	</span>	cc.mu.Lock()
<span id="L5622" class="ln">  5622	</span>	cs.stopReqBody = err
<span id="L5623" class="ln">  5623	</span>	cc.cond.Broadcast()
<span id="L5624" class="ln">  5624	</span>	cc.mu.Unlock()
<span id="L5625" class="ln">  5625	</span>}
<span id="L5626" class="ln">  5626	</span>
<span id="L5627" class="ln">  5627	</span>type http2stickyErrWriter struct {
<span id="L5628" class="ln">  5628	</span>	w   io.Writer
<span id="L5629" class="ln">  5629	</span>	err *error
<span id="L5630" class="ln">  5630	</span>}
<span id="L5631" class="ln">  5631	</span>
<span id="L5632" class="ln">  5632	</span>func (sew http2stickyErrWriter) Write(p []byte) (n int, err error) {
<span id="L5633" class="ln">  5633	</span>	if *sew.err != nil {
<span id="L5634" class="ln">  5634	</span>		return 0, *sew.err
<span id="L5635" class="ln">  5635	</span>	}
<span id="L5636" class="ln">  5636	</span>	n, err = sew.w.Write(p)
<span id="L5637" class="ln">  5637	</span>	*sew.err = err
<span id="L5638" class="ln">  5638	</span>	return
<span id="L5639" class="ln">  5639	</span>}
<span id="L5640" class="ln">  5640	</span>
<span id="L5641" class="ln">  5641	</span>var http2ErrNoCachedConn = errors.New(&#34;http2: no cached connection was available&#34;)
<span id="L5642" class="ln">  5642	</span>
<span id="L5643" class="ln">  5643	</span><span class="comment">// RoundTripOpt are options for the Transport.RoundTripOpt method.</span>
<span id="L5644" class="ln">  5644	</span>type http2RoundTripOpt struct {
<span id="L5645" class="ln">  5645	</span>	<span class="comment">// OnlyCachedConn controls whether RoundTripOpt may</span>
<span id="L5646" class="ln">  5646	</span>	<span class="comment">// create a new TCP connection. If set true and</span>
<span id="L5647" class="ln">  5647	</span>	<span class="comment">// no cached connection is available, RoundTripOpt</span>
<span id="L5648" class="ln">  5648	</span>	<span class="comment">// will return ErrNoCachedConn.</span>
<span id="L5649" class="ln">  5649	</span>	OnlyCachedConn bool
<span id="L5650" class="ln">  5650	</span>}
<span id="L5651" class="ln">  5651	</span>
<span id="L5652" class="ln">  5652	</span>func (t *http2Transport) RoundTrip(req *Request) (*Response, error) {
<span id="L5653" class="ln">  5653	</span>	return t.RoundTripOpt(req, http2RoundTripOpt{})
<span id="L5654" class="ln">  5654	</span>}
<span id="L5655" class="ln">  5655	</span>
<span id="L5656" class="ln">  5656	</span><span class="comment">// authorityAddr returns a given authority (a host/IP, or host:port / ip:port)</span>
<span id="L5657" class="ln">  5657	</span><span class="comment">// and returns a host:port. The port 443 is added if needed.</span>
<span id="L5658" class="ln">  5658	</span>func http2authorityAddr(scheme string, authority string) (addr string) {
<span id="L5659" class="ln">  5659	</span>	host, port, err := net.SplitHostPort(authority)
<span id="L5660" class="ln">  5660	</span>	if err != nil {
<span id="L5661" class="ln">  5661	</span>		port = &#34;443&#34;
<span id="L5662" class="ln">  5662	</span>		if scheme == &#34;http&#34; {
<span id="L5663" class="ln">  5663	</span>			port = &#34;80&#34;
<span id="L5664" class="ln">  5664	</span>		}
<span id="L5665" class="ln">  5665	</span>		host = authority
<span id="L5666" class="ln">  5666	</span>	}
<span id="L5667" class="ln">  5667	</span>	if a, err := idna.ToASCII(host); err == nil {
<span id="L5668" class="ln">  5668	</span>		host = a
<span id="L5669" class="ln">  5669	</span>	}
<span id="L5670" class="ln">  5670	</span>
<span id="L5671" class="ln">  5671	</span>	if strings.HasPrefix(host, &#34;[&#34;) &amp;&amp; strings.HasSuffix(host, &#34;]&#34;) {
<span id="L5672" class="ln">  5672	</span>		return host + &#34;:&#34; + port
<span id="L5673" class="ln">  5673	</span>	}
<span id="L5674" class="ln">  5674	</span>	return net.JoinHostPort(host, port)
<span id="L5675" class="ln">  5675	</span>}
<span id="L5676" class="ln">  5676	</span>
<span id="L5677" class="ln">  5677	</span><span class="comment">// RoundTripOpt is like RoundTrip, but takes options.</span>
<span id="L5678" class="ln">  5678	</span>func (t *http2Transport) RoundTripOpt(req *Request, opt http2RoundTripOpt) (*Response, error) {
<span id="L5679" class="ln">  5679	</span>	if !(req.URL.Scheme == &#34;https&#34; || (req.URL.Scheme == &#34;http&#34; &amp;&amp; t.AllowHTTP)) {
<span id="L5680" class="ln">  5680	</span>		return nil, errors.New(&#34;http2: unsupported scheme&#34;)
<span id="L5681" class="ln">  5681	</span>	}
<span id="L5682" class="ln">  5682	</span>
<span id="L5683" class="ln">  5683	</span>	addr := http2authorityAddr(req.URL.Scheme, req.URL.Host)
<span id="L5684" class="ln">  5684	</span>	for {
<span id="L5685" class="ln">  5685	</span>		cc, err := t.connPool().GetClientConn(req, addr)
<span id="L5686" class="ln">  5686	</span>		if err != nil {
<span id="L5687" class="ln">  5687	</span>			t.vlogf(&#34;http2: Transport failed to get client conn for %s: %v&#34;, addr, err)
<span id="L5688" class="ln">  5688	</span>			return nil, err
<span id="L5689" class="ln">  5689	</span>		}
<span id="L5690" class="ln">  5690	</span>		http2traceGotConn(req, cc)
<span id="L5691" class="ln">  5691	</span>		res, err := cc.RoundTrip(req)
<span id="L5692" class="ln">  5692	</span>		if err != nil {
<span id="L5693" class="ln">  5693	</span>			if req, err = http2shouldRetryRequest(req, err); err == nil {
<span id="L5694" class="ln">  5694	</span>				continue
<span id="L5695" class="ln">  5695	</span>			}
<span id="L5696" class="ln">  5696	</span>		}
<span id="L5697" class="ln">  5697	</span>		if err != nil {
<span id="L5698" class="ln">  5698	</span>			t.vlogf(&#34;RoundTrip failure: %v&#34;, err)
<span id="L5699" class="ln">  5699	</span>			return nil, err
<span id="L5700" class="ln">  5700	</span>		}
<span id="L5701" class="ln">  5701	</span>		return res, nil
<span id="L5702" class="ln">  5702	</span>	}
<span id="L5703" class="ln">  5703	</span>}
<span id="L5704" class="ln">  5704	</span>
<span id="L5705" class="ln">  5705	</span><span class="comment">// CloseIdleConnections closes any connections which were previously</span>
<span id="L5706" class="ln">  5706	</span><span class="comment">// connected from previous requests but are now sitting idle.</span>
<span id="L5707" class="ln">  5707	</span><span class="comment">// It does not interrupt any connections currently in use.</span>
<span id="L5708" class="ln">  5708	</span>func (t *http2Transport) CloseIdleConnections() {
<span id="L5709" class="ln">  5709	</span>	if cp, ok := t.connPool().(http2clientConnPoolIdleCloser); ok {
<span id="L5710" class="ln">  5710	</span>		cp.closeIdleConnections()
<span id="L5711" class="ln">  5711	</span>	}
<span id="L5712" class="ln">  5712	</span>}
<span id="L5713" class="ln">  5713	</span>
<span id="L5714" class="ln">  5714	</span>var (
<span id="L5715" class="ln">  5715	</span>	http2errClientConnClosed   = errors.New(&#34;http2: client conn is closed&#34;)
<span id="L5716" class="ln">  5716	</span>	http2errClientConnUnusable = errors.New(&#34;http2: client conn not usable&#34;)
<span id="L5717" class="ln">  5717	</span>
<span id="L5718" class="ln">  5718	</span>	http2errClientConnGotGoAway                 = errors.New(&#34;http2: Transport received Server&#39;s graceful shutdown GOAWAY&#34;)
<span id="L5719" class="ln">  5719	</span>	http2errClientConnGotGoAwayAfterSomeReqBody = errors.New(&#34;http2: Transport received Server&#39;s graceful shutdown GOAWAY; some request body already written&#34;)
<span id="L5720" class="ln">  5720	</span>)
<span id="L5721" class="ln">  5721	</span>
<span id="L5722" class="ln">  5722	</span><span class="comment">// shouldRetryRequest is called by RoundTrip when a request fails to get</span>
<span id="L5723" class="ln">  5723	</span><span class="comment">// response headers. It is always called with a non-nil error.</span>
<span id="L5724" class="ln">  5724	</span><span class="comment">// It returns either a request to retry (either the same request, or a</span>
<span id="L5725" class="ln">  5725	</span><span class="comment">// modified clone), or an error if the request can&#39;t be replayed.</span>
<span id="L5726" class="ln">  5726	</span>func http2shouldRetryRequest(req *Request, err error) (*Request, error) {
<span id="L5727" class="ln">  5727	</span>	switch err {
<span id="L5728" class="ln">  5728	</span>	default:
<span id="L5729" class="ln">  5729	</span>		return nil, err
<span id="L5730" class="ln">  5730	</span>	case http2errClientConnUnusable, http2errClientConnGotGoAway:
<span id="L5731" class="ln">  5731	</span>		return req, nil
<span id="L5732" class="ln">  5732	</span>	case http2errClientConnGotGoAwayAfterSomeReqBody:
<span id="L5733" class="ln">  5733	</span>
<span id="L5734" class="ln">  5734	</span>		if req.Body == nil || http2reqBodyIsNoBody(req.Body) {
<span id="L5735" class="ln">  5735	</span>			return req, nil
<span id="L5736" class="ln">  5736	</span>		}
<span id="L5737" class="ln">  5737	</span>
<span id="L5738" class="ln">  5738	</span>		getBody := http2reqGetBody(req)
<span id="L5739" class="ln">  5739	</span>		if getBody == nil {
<span id="L5740" class="ln">  5740	</span>			return nil, errors.New(&#34;http2: Transport: peer server initiated graceful shutdown after some of Request.Body was written; define Request.GetBody to avoid this error&#34;)
<span id="L5741" class="ln">  5741	</span>		}
<span id="L5742" class="ln">  5742	</span>		body, err := getBody()
<span id="L5743" class="ln">  5743	</span>		if err != nil {
<span id="L5744" class="ln">  5744	</span>			return nil, err
<span id="L5745" class="ln">  5745	</span>		}
<span id="L5746" class="ln">  5746	</span>		newReq := *req
<span id="L5747" class="ln">  5747	</span>		newReq.Body = body
<span id="L5748" class="ln">  5748	</span>		return &amp;newReq, nil
<span id="L5749" class="ln">  5749	</span>	}
<span id="L5750" class="ln">  5750	</span>}
<span id="L5751" class="ln">  5751	</span>
<span id="L5752" class="ln">  5752	</span>func (t *http2Transport) dialClientConn(addr string, singleUse bool) (*http2ClientConn, error) {
<span id="L5753" class="ln">  5753	</span>	host, _, err := net.SplitHostPort(addr)
<span id="L5754" class="ln">  5754	</span>	if err != nil {
<span id="L5755" class="ln">  5755	</span>		return nil, err
<span id="L5756" class="ln">  5756	</span>	}
<span id="L5757" class="ln">  5757	</span>	tconn, err := t.dialTLS()(&#34;tcp&#34;, addr, t.newTLSConfig(host))
<span id="L5758" class="ln">  5758	</span>	if err != nil {
<span id="L5759" class="ln">  5759	</span>		return nil, err
<span id="L5760" class="ln">  5760	</span>	}
<span id="L5761" class="ln">  5761	</span>	return t.newClientConn(tconn, singleUse)
<span id="L5762" class="ln">  5762	</span>}
<span id="L5763" class="ln">  5763	</span>
<span id="L5764" class="ln">  5764	</span>func (t *http2Transport) newTLSConfig(host string) *tls.Config {
<span id="L5765" class="ln">  5765	</span>	cfg := new(tls.Config)
<span id="L5766" class="ln">  5766	</span>	if t.TLSClientConfig != nil {
<span id="L5767" class="ln">  5767	</span>		*cfg = *http2cloneTLSConfig(t.TLSClientConfig)
<span id="L5768" class="ln">  5768	</span>	}
<span id="L5769" class="ln">  5769	</span>	if !http2strSliceContains(cfg.NextProtos, http2NextProtoTLS) {
<span id="L5770" class="ln">  5770	</span>		cfg.NextProtos = append([]string{http2NextProtoTLS}, cfg.NextProtos...)
<span id="L5771" class="ln">  5771	</span>	}
<span id="L5772" class="ln">  5772	</span>	if cfg.ServerName == &#34;&#34; {
<span id="L5773" class="ln">  5773	</span>		cfg.ServerName = host
<span id="L5774" class="ln">  5774	</span>	}
<span id="L5775" class="ln">  5775	</span>	return cfg
<span id="L5776" class="ln">  5776	</span>}
<span id="L5777" class="ln">  5777	</span>
<span id="L5778" class="ln">  5778	</span>func (t *http2Transport) dialTLS() func(string, string, *tls.Config) (net.Conn, error) {
<span id="L5779" class="ln">  5779	</span>	if t.DialTLS != nil {
<span id="L5780" class="ln">  5780	</span>		return t.DialTLS
<span id="L5781" class="ln">  5781	</span>	}
<span id="L5782" class="ln">  5782	</span>	return t.dialTLSDefault
<span id="L5783" class="ln">  5783	</span>}
<span id="L5784" class="ln">  5784	</span>
<span id="L5785" class="ln">  5785	</span>func (t *http2Transport) dialTLSDefault(network, addr string, cfg *tls.Config) (net.Conn, error) {
<span id="L5786" class="ln">  5786	</span>	cn, err := tls.Dial(network, addr, cfg)
<span id="L5787" class="ln">  5787	</span>	if err != nil {
<span id="L5788" class="ln">  5788	</span>		return nil, err
<span id="L5789" class="ln">  5789	</span>	}
<span id="L5790" class="ln">  5790	</span>	if err := cn.Handshake(); err != nil {
<span id="L5791" class="ln">  5791	</span>		return nil, err
<span id="L5792" class="ln">  5792	</span>	}
<span id="L5793" class="ln">  5793	</span>	if !cfg.InsecureSkipVerify {
<span id="L5794" class="ln">  5794	</span>		if err := cn.VerifyHostname(cfg.ServerName); err != nil {
<span id="L5795" class="ln">  5795	</span>			return nil, err
<span id="L5796" class="ln">  5796	</span>		}
<span id="L5797" class="ln">  5797	</span>	}
<span id="L5798" class="ln">  5798	</span>	state := cn.ConnectionState()
<span id="L5799" class="ln">  5799	</span>	if p := state.NegotiatedProtocol; p != http2NextProtoTLS {
<span id="L5800" class="ln">  5800	</span>		return nil, fmt.Errorf(&#34;http2: unexpected ALPN protocol %q; want %q&#34;, p, http2NextProtoTLS)
<span id="L5801" class="ln">  5801	</span>	}
<span id="L5802" class="ln">  5802	</span>	if !state.NegotiatedProtocolIsMutual {
<span id="L5803" class="ln">  5803	</span>		return nil, errors.New(&#34;http2: could not negotiate protocol mutually&#34;)
<span id="L5804" class="ln">  5804	</span>	}
<span id="L5805" class="ln">  5805	</span>	return cn, nil
<span id="L5806" class="ln">  5806	</span>}
<span id="L5807" class="ln">  5807	</span>
<span id="L5808" class="ln">  5808	</span><span class="comment">// disableKeepAlives reports whether connections should be closed as</span>
<span id="L5809" class="ln">  5809	</span><span class="comment">// soon as possible after handling the first request.</span>
<span id="L5810" class="ln">  5810	</span>func (t *http2Transport) disableKeepAlives() bool {
<span id="L5811" class="ln">  5811	</span>	return t.t1 != nil &amp;&amp; t.t1.DisableKeepAlives
<span id="L5812" class="ln">  5812	</span>}
<span id="L5813" class="ln">  5813	</span>
<span id="L5814" class="ln">  5814	</span>func (t *http2Transport) expectContinueTimeout() time.Duration {
<span id="L5815" class="ln">  5815	</span>	if t.t1 == nil {
<span id="L5816" class="ln">  5816	</span>		return 0
<span id="L5817" class="ln">  5817	</span>	}
<span id="L5818" class="ln">  5818	</span>	return http2transportExpectContinueTimeout(t.t1)
<span id="L5819" class="ln">  5819	</span>}
<span id="L5820" class="ln">  5820	</span>
<span id="L5821" class="ln">  5821	</span>func (t *http2Transport) NewClientConn(c net.Conn) (*http2ClientConn, error) {
<span id="L5822" class="ln">  5822	</span>	return t.newClientConn(c, false)
<span id="L5823" class="ln">  5823	</span>}
<span id="L5824" class="ln">  5824	</span>
<span id="L5825" class="ln">  5825	</span>func (t *http2Transport) newClientConn(c net.Conn, singleUse bool) (*http2ClientConn, error) {
<span id="L5826" class="ln">  5826	</span>	cc := &amp;http2ClientConn{
<span id="L5827" class="ln">  5827	</span>		t:                    t,
<span id="L5828" class="ln">  5828	</span>		tconn:                c,
<span id="L5829" class="ln">  5829	</span>		readerDone:           make(chan struct{}),
<span id="L5830" class="ln">  5830	</span>		nextStreamID:         1,
<span id="L5831" class="ln">  5831	</span>		maxFrameSize:         16 &lt;&lt; 10,
<span id="L5832" class="ln">  5832	</span>		initialWindowSize:    65535,
<span id="L5833" class="ln">  5833	</span>		maxConcurrentStreams: 1000,
<span id="L5834" class="ln">  5834	</span>		streams:              make(map[uint32]*http2clientStream),
<span id="L5835" class="ln">  5835	</span>		singleUse:            singleUse,
<span id="L5836" class="ln">  5836	</span>		wantSettingsAck:      true,
<span id="L5837" class="ln">  5837	</span>		pings:                make(map[[8]byte]chan struct{}),
<span id="L5838" class="ln">  5838	</span>	}
<span id="L5839" class="ln">  5839	</span>	if d := t.idleConnTimeout(); d != 0 {
<span id="L5840" class="ln">  5840	</span>		cc.idleTimeout = d
<span id="L5841" class="ln">  5841	</span>		cc.idleTimer = time.AfterFunc(d, cc.onIdleTimeout)
<span id="L5842" class="ln">  5842	</span>	}
<span id="L5843" class="ln">  5843	</span>	if http2VerboseLogs {
<span id="L5844" class="ln">  5844	</span>		t.vlogf(&#34;http2: Transport creating client conn %p to %v&#34;, cc, c.RemoteAddr())
<span id="L5845" class="ln">  5845	</span>	}
<span id="L5846" class="ln">  5846	</span>
<span id="L5847" class="ln">  5847	</span>	cc.cond = sync.NewCond(&amp;cc.mu)
<span id="L5848" class="ln">  5848	</span>	cc.flow.add(int32(http2initialWindowSize))
<span id="L5849" class="ln">  5849	</span>
<span id="L5850" class="ln">  5850	</span>	cc.bw = bufio.NewWriter(http2stickyErrWriter{c, &amp;cc.werr})
<span id="L5851" class="ln">  5851	</span>	cc.br = bufio.NewReader(c)
<span id="L5852" class="ln">  5852	</span>	cc.fr = http2NewFramer(cc.bw, cc.br)
<span id="L5853" class="ln">  5853	</span>	cc.fr.ReadMetaHeaders = hpack.NewDecoder(http2initialHeaderTableSize, nil)
<span id="L5854" class="ln">  5854	</span>	cc.fr.MaxHeaderListSize = t.maxHeaderListSize()
<span id="L5855" class="ln">  5855	</span>
<span id="L5856" class="ln">  5856	</span>	cc.henc = hpack.NewEncoder(&amp;cc.hbuf)
<span id="L5857" class="ln">  5857	</span>
<span id="L5858" class="ln">  5858	</span>	if cs, ok := c.(http2connectionStater); ok {
<span id="L5859" class="ln">  5859	</span>		state := cs.ConnectionState()
<span id="L5860" class="ln">  5860	</span>		cc.tlsState = &amp;state
<span id="L5861" class="ln">  5861	</span>	}
<span id="L5862" class="ln">  5862	</span>
<span id="L5863" class="ln">  5863	</span>	initialSettings := []http2Setting{
<span id="L5864" class="ln">  5864	</span>		{ID: http2SettingEnablePush, Val: 0},
<span id="L5865" class="ln">  5865	</span>		{ID: http2SettingInitialWindowSize, Val: http2transportDefaultStreamFlow},
<span id="L5866" class="ln">  5866	</span>	}
<span id="L5867" class="ln">  5867	</span>	if max := t.maxHeaderListSize(); max != 0 {
<span id="L5868" class="ln">  5868	</span>		initialSettings = append(initialSettings, http2Setting{ID: http2SettingMaxHeaderListSize, Val: max})
<span id="L5869" class="ln">  5869	</span>	}
<span id="L5870" class="ln">  5870	</span>
<span id="L5871" class="ln">  5871	</span>	cc.bw.Write(http2clientPreface)
<span id="L5872" class="ln">  5872	</span>	cc.fr.WriteSettings(initialSettings...)
<span id="L5873" class="ln">  5873	</span>	cc.fr.WriteWindowUpdate(0, http2transportDefaultConnFlow)
<span id="L5874" class="ln">  5874	</span>	cc.inflow.add(http2transportDefaultConnFlow + http2initialWindowSize)
<span id="L5875" class="ln">  5875	</span>	cc.bw.Flush()
<span id="L5876" class="ln">  5876	</span>	if cc.werr != nil {
<span id="L5877" class="ln">  5877	</span>		return nil, cc.werr
<span id="L5878" class="ln">  5878	</span>	}
<span id="L5879" class="ln">  5879	</span>
<span id="L5880" class="ln">  5880	</span>	go cc.readLoop()
<span id="L5881" class="ln">  5881	</span>	return cc, nil
<span id="L5882" class="ln">  5882	</span>}
<span id="L5883" class="ln">  5883	</span>
<span id="L5884" class="ln">  5884	</span>func (cc *http2ClientConn) setGoAway(f *http2GoAwayFrame) {
<span id="L5885" class="ln">  5885	</span>	cc.mu.Lock()
<span id="L5886" class="ln">  5886	</span>	defer cc.mu.Unlock()
<span id="L5887" class="ln">  5887	</span>
<span id="L5888" class="ln">  5888	</span>	old := cc.goAway
<span id="L5889" class="ln">  5889	</span>	cc.goAway = f
<span id="L5890" class="ln">  5890	</span>
<span id="L5891" class="ln">  5891	</span>	if cc.goAwayDebug == &#34;&#34; {
<span id="L5892" class="ln">  5892	</span>		cc.goAwayDebug = string(f.DebugData())
<span id="L5893" class="ln">  5893	</span>	}
<span id="L5894" class="ln">  5894	</span>	if old != nil &amp;&amp; old.ErrCode != http2ErrCodeNo {
<span id="L5895" class="ln">  5895	</span>		cc.goAway.ErrCode = old.ErrCode
<span id="L5896" class="ln">  5896	</span>	}
<span id="L5897" class="ln">  5897	</span>	last := f.LastStreamID
<span id="L5898" class="ln">  5898	</span>	for streamID, cs := range cc.streams {
<span id="L5899" class="ln">  5899	</span>		if streamID &gt; last {
<span id="L5900" class="ln">  5900	</span>			select {
<span id="L5901" class="ln">  5901	</span>			case cs.resc &lt;- http2resAndError{err: http2errClientConnGotGoAway}:
<span id="L5902" class="ln">  5902	</span>			default:
<span id="L5903" class="ln">  5903	</span>			}
<span id="L5904" class="ln">  5904	</span>		}
<span id="L5905" class="ln">  5905	</span>	}
<span id="L5906" class="ln">  5906	</span>}
<span id="L5907" class="ln">  5907	</span>
<span id="L5908" class="ln">  5908	</span>func (cc *http2ClientConn) CanTakeNewRequest() bool {
<span id="L5909" class="ln">  5909	</span>	cc.mu.Lock()
<span id="L5910" class="ln">  5910	</span>	defer cc.mu.Unlock()
<span id="L5911" class="ln">  5911	</span>	return cc.canTakeNewRequestLocked()
<span id="L5912" class="ln">  5912	</span>}
<span id="L5913" class="ln">  5913	</span>
<span id="L5914" class="ln">  5914	</span>func (cc *http2ClientConn) canTakeNewRequestLocked() bool {
<span id="L5915" class="ln">  5915	</span>	if cc.singleUse &amp;&amp; cc.nextStreamID &gt; 1 {
<span id="L5916" class="ln">  5916	</span>		return false
<span id="L5917" class="ln">  5917	</span>	}
<span id="L5918" class="ln">  5918	</span>	return cc.goAway == nil &amp;&amp; !cc.closed &amp;&amp;
<span id="L5919" class="ln">  5919	</span>		int64(len(cc.streams)+1) &lt; int64(cc.maxConcurrentStreams) &amp;&amp;
<span id="L5920" class="ln">  5920	</span>		cc.nextStreamID &lt; math.MaxInt32
<span id="L5921" class="ln">  5921	</span>}
<span id="L5922" class="ln">  5922	</span>
<span id="L5923" class="ln">  5923	</span><span class="comment">// onIdleTimeout is called from a time.AfterFunc goroutine.  It will</span>
<span id="L5924" class="ln">  5924	</span><span class="comment">// only be called when we&#39;re idle, but because we&#39;re coming from a new</span>
<span id="L5925" class="ln">  5925	</span><span class="comment">// goroutine, there could be a new request coming in at the same time,</span>
<span id="L5926" class="ln">  5926	</span><span class="comment">// so this simply calls the synchronized closeIfIdle to shut down this</span>
<span id="L5927" class="ln">  5927	</span><span class="comment">// connection. The timer could just call closeIfIdle, but this is more</span>
<span id="L5928" class="ln">  5928	</span><span class="comment">// clear.</span>
<span id="L5929" class="ln">  5929	</span>func (cc *http2ClientConn) onIdleTimeout() {
<span id="L5930" class="ln">  5930	</span>	cc.closeIfIdle()
<span id="L5931" class="ln">  5931	</span>}
<span id="L5932" class="ln">  5932	</span>
<span id="L5933" class="ln">  5933	</span>func (cc *http2ClientConn) closeIfIdle() {
<span id="L5934" class="ln">  5934	</span>	cc.mu.Lock()
<span id="L5935" class="ln">  5935	</span>	if len(cc.streams) &gt; 0 {
<span id="L5936" class="ln">  5936	</span>		cc.mu.Unlock()
<span id="L5937" class="ln">  5937	</span>		return
<span id="L5938" class="ln">  5938	</span>	}
<span id="L5939" class="ln">  5939	</span>	cc.closed = true
<span id="L5940" class="ln">  5940	</span>	nextID := cc.nextStreamID
<span id="L5941" class="ln">  5941	</span>
<span id="L5942" class="ln">  5942	</span>	cc.mu.Unlock()
<span id="L5943" class="ln">  5943	</span>
<span id="L5944" class="ln">  5944	</span>	if http2VerboseLogs {
<span id="L5945" class="ln">  5945	</span>		cc.vlogf(&#34;http2: Transport closing idle conn %p (forSingleUse=%v, maxStream=%v)&#34;, cc, cc.singleUse, nextID-2)
<span id="L5946" class="ln">  5946	</span>	}
<span id="L5947" class="ln">  5947	</span>	cc.tconn.Close()
<span id="L5948" class="ln">  5948	</span>}
<span id="L5949" class="ln">  5949	</span>
<span id="L5950" class="ln">  5950	</span>const http2maxAllocFrameSize = 512 &lt;&lt; 10
<span id="L5951" class="ln">  5951	</span>
<span id="L5952" class="ln">  5952	</span><span class="comment">// frameBuffer returns a scratch buffer suitable for writing DATA frames.</span>
<span id="L5953" class="ln">  5953	</span><span class="comment">// They&#39;re capped at the min of the peer&#39;s max frame size or 512KB</span>
<span id="L5954" class="ln">  5954	</span><span class="comment">// (kinda arbitrarily), but definitely capped so we don&#39;t allocate 4GB</span>
<span id="L5955" class="ln">  5955	</span><span class="comment">// bufers.</span>
<span id="L5956" class="ln">  5956	</span>func (cc *http2ClientConn) frameScratchBuffer() []byte {
<span id="L5957" class="ln">  5957	</span>	cc.mu.Lock()
<span id="L5958" class="ln">  5958	</span>	size := cc.maxFrameSize
<span id="L5959" class="ln">  5959	</span>	if size &gt; http2maxAllocFrameSize {
<span id="L5960" class="ln">  5960	</span>		size = http2maxAllocFrameSize
<span id="L5961" class="ln">  5961	</span>	}
<span id="L5962" class="ln">  5962	</span>	for i, buf := range cc.freeBuf {
<span id="L5963" class="ln">  5963	</span>		if len(buf) &gt;= int(size) {
<span id="L5964" class="ln">  5964	</span>			cc.freeBuf[i] = nil
<span id="L5965" class="ln">  5965	</span>			cc.mu.Unlock()
<span id="L5966" class="ln">  5966	</span>			return buf[:size]
<span id="L5967" class="ln">  5967	</span>		}
<span id="L5968" class="ln">  5968	</span>	}
<span id="L5969" class="ln">  5969	</span>	cc.mu.Unlock()
<span id="L5970" class="ln">  5970	</span>	return make([]byte, size)
<span id="L5971" class="ln">  5971	</span>}
<span id="L5972" class="ln">  5972	</span>
<span id="L5973" class="ln">  5973	</span>func (cc *http2ClientConn) putFrameScratchBuffer(buf []byte) {
<span id="L5974" class="ln">  5974	</span>	cc.mu.Lock()
<span id="L5975" class="ln">  5975	</span>	defer cc.mu.Unlock()
<span id="L5976" class="ln">  5976	</span>	const maxBufs = 4 <span class="comment">// arbitrary; 4 concurrent requests per conn? investigate.</span>
<span id="L5977" class="ln">  5977	</span>	if len(cc.freeBuf) &lt; maxBufs {
<span id="L5978" class="ln">  5978	</span>		cc.freeBuf = append(cc.freeBuf, buf)
<span id="L5979" class="ln">  5979	</span>		return
<span id="L5980" class="ln">  5980	</span>	}
<span id="L5981" class="ln">  5981	</span>	for i, old := range cc.freeBuf {
<span id="L5982" class="ln">  5982	</span>		if old == nil {
<span id="L5983" class="ln">  5983	</span>			cc.freeBuf[i] = buf
<span id="L5984" class="ln">  5984	</span>			return
<span id="L5985" class="ln">  5985	</span>		}
<span id="L5986" class="ln">  5986	</span>	}
<span id="L5987" class="ln">  5987	</span>
<span id="L5988" class="ln">  5988	</span>}
<span id="L5989" class="ln">  5989	</span>
<span id="L5990" class="ln">  5990	</span><span class="comment">// errRequestCanceled is a copy of net/http&#39;s errRequestCanceled because it&#39;s not</span>
<span id="L5991" class="ln">  5991	</span><span class="comment">// exported. At least they&#39;ll be DeepEqual for h1-vs-h2 comparisons tests.</span>
<span id="L5992" class="ln">  5992	</span>var http2errRequestCanceled = errors.New(&#34;net/http: request canceled&#34;)
<span id="L5993" class="ln">  5993	</span>
<span id="L5994" class="ln">  5994	</span>func http2commaSeparatedTrailers(req *Request) (string, error) {
<span id="L5995" class="ln">  5995	</span>	keys := make([]string, 0, len(req.Trailer))
<span id="L5996" class="ln">  5996	</span>	for k := range req.Trailer {
<span id="L5997" class="ln">  5997	</span>		k = CanonicalHeaderKey(k)
<span id="L5998" class="ln">  5998	</span>		switch k {
<span id="L5999" class="ln">  5999	</span>		case &#34;Transfer-Encoding&#34;, &#34;Trailer&#34;, &#34;Content-Length&#34;:
<span id="L6000" class="ln">  6000	</span>			return &#34;&#34;, &amp;http2badStringError{&#34;invalid Trailer key&#34;, k}
<span id="L6001" class="ln">  6001	</span>		}
<span id="L6002" class="ln">  6002	</span>		keys = append(keys, k)
<span id="L6003" class="ln">  6003	</span>	}
<span id="L6004" class="ln">  6004	</span>	if len(keys) &gt; 0 {
<span id="L6005" class="ln">  6005	</span>		sort.Strings(keys)
<span id="L6006" class="ln">  6006	</span>
<span id="L6007" class="ln">  6007	</span>		return strings.Join(keys, &#34;,&#34;), nil
<span id="L6008" class="ln">  6008	</span>	}
<span id="L6009" class="ln">  6009	</span>	return &#34;&#34;, nil
<span id="L6010" class="ln">  6010	</span>}
<span id="L6011" class="ln">  6011	</span>
<span id="L6012" class="ln">  6012	</span>func (cc *http2ClientConn) responseHeaderTimeout() time.Duration {
<span id="L6013" class="ln">  6013	</span>	if cc.t.t1 != nil {
<span id="L6014" class="ln">  6014	</span>		return cc.t.t1.ResponseHeaderTimeout
<span id="L6015" class="ln">  6015	</span>	}
<span id="L6016" class="ln">  6016	</span>
<span id="L6017" class="ln">  6017	</span>	return 0
<span id="L6018" class="ln">  6018	</span>}
<span id="L6019" class="ln">  6019	</span>
<span id="L6020" class="ln">  6020	</span><span class="comment">// checkConnHeaders checks whether req has any invalid connection-level headers.</span>
<span id="L6021" class="ln">  6021	</span><span class="comment">// per RFC 7540 section 8.1.2.2: Connection-Specific Header Fields.</span>
<span id="L6022" class="ln">  6022	</span><span class="comment">// Certain headers are special-cased as okay but not transmitted later.</span>
<span id="L6023" class="ln">  6023	</span>func http2checkConnHeaders(req *Request) error {
<span id="L6024" class="ln">  6024	</span>	if v := req.Header.Get(&#34;Upgrade&#34;); v != &#34;&#34; {
<span id="L6025" class="ln">  6025	</span>		return fmt.Errorf(&#34;http2: invalid Upgrade request header: %q&#34;, req.Header[&#34;Upgrade&#34;])
<span id="L6026" class="ln">  6026	</span>	}
<span id="L6027" class="ln">  6027	</span>	if vv := req.Header[&#34;Transfer-Encoding&#34;]; len(vv) &gt; 0 &amp;&amp; (len(vv) &gt; 1 || vv[0] != &#34;&#34; &amp;&amp; vv[0] != &#34;chunked&#34;) {
<span id="L6028" class="ln">  6028	</span>		return fmt.Errorf(&#34;http2: invalid Transfer-Encoding request header: %q&#34;, vv)
<span id="L6029" class="ln">  6029	</span>	}
<span id="L6030" class="ln">  6030	</span>	if vv := req.Header[&#34;Connection&#34;]; len(vv) &gt; 0 &amp;&amp; (len(vv) &gt; 1 || vv[0] != &#34;&#34; &amp;&amp; vv[0] != &#34;close&#34; &amp;&amp; vv[0] != &#34;keep-alive&#34;) {
<span id="L6031" class="ln">  6031	</span>		return fmt.Errorf(&#34;http2: invalid Connection request header: %q&#34;, vv)
<span id="L6032" class="ln">  6032	</span>	}
<span id="L6033" class="ln">  6033	</span>	return nil
<span id="L6034" class="ln">  6034	</span>}
<span id="L6035" class="ln">  6035	</span>
<span id="L6036" class="ln">  6036	</span><span class="comment">// actualContentLength returns a sanitized version of</span>
<span id="L6037" class="ln">  6037	</span><span class="comment">// req.ContentLength, where 0 actually means zero (not unknown) and -1</span>
<span id="L6038" class="ln">  6038	</span><span class="comment">// means unknown.</span>
<span id="L6039" class="ln">  6039	</span>func http2actualContentLength(req *Request) int64 {
<span id="L6040" class="ln">  6040	</span>	if req.Body == nil {
<span id="L6041" class="ln">  6041	</span>		return 0
<span id="L6042" class="ln">  6042	</span>	}
<span id="L6043" class="ln">  6043	</span>	if req.ContentLength != 0 {
<span id="L6044" class="ln">  6044	</span>		return req.ContentLength
<span id="L6045" class="ln">  6045	</span>	}
<span id="L6046" class="ln">  6046	</span>	return -1
<span id="L6047" class="ln">  6047	</span>}
<span id="L6048" class="ln">  6048	</span>
<span id="L6049" class="ln">  6049	</span>func (cc *http2ClientConn) RoundTrip(req *Request) (*Response, error) {
<span id="L6050" class="ln">  6050	</span>	if err := http2checkConnHeaders(req); err != nil {
<span id="L6051" class="ln">  6051	</span>		return nil, err
<span id="L6052" class="ln">  6052	</span>	}
<span id="L6053" class="ln">  6053	</span>	if cc.idleTimer != nil {
<span id="L6054" class="ln">  6054	</span>		cc.idleTimer.Stop()
<span id="L6055" class="ln">  6055	</span>	}
<span id="L6056" class="ln">  6056	</span>
<span id="L6057" class="ln">  6057	</span>	trailers, err := http2commaSeparatedTrailers(req)
<span id="L6058" class="ln">  6058	</span>	if err != nil {
<span id="L6059" class="ln">  6059	</span>		return nil, err
<span id="L6060" class="ln">  6060	</span>	}
<span id="L6061" class="ln">  6061	</span>	hasTrailers := trailers != &#34;&#34;
<span id="L6062" class="ln">  6062	</span>
<span id="L6063" class="ln">  6063	</span>	cc.mu.Lock()
<span id="L6064" class="ln">  6064	</span>	cc.lastActive = time.Now()
<span id="L6065" class="ln">  6065	</span>	if cc.closed || !cc.canTakeNewRequestLocked() {
<span id="L6066" class="ln">  6066	</span>		cc.mu.Unlock()
<span id="L6067" class="ln">  6067	</span>		return nil, http2errClientConnUnusable
<span id="L6068" class="ln">  6068	</span>	}
<span id="L6069" class="ln">  6069	</span>
<span id="L6070" class="ln">  6070	</span>	body := req.Body
<span id="L6071" class="ln">  6071	</span>	hasBody := body != nil
<span id="L6072" class="ln">  6072	</span>	contentLen := http2actualContentLength(req)
<span id="L6073" class="ln">  6073	</span>
<span id="L6074" class="ln">  6074	</span>	<span class="comment">// TODO(bradfitz): this is a copy of the logic in net/http. Unify somewhere?</span>
<span id="L6075" class="ln">  6075	</span>	var requestedGzip bool
<span id="L6076" class="ln">  6076	</span>	if !cc.t.disableCompression() &amp;&amp;
<span id="L6077" class="ln">  6077	</span>		req.Header.Get(&#34;Accept-Encoding&#34;) == &#34;&#34; &amp;&amp;
<span id="L6078" class="ln">  6078	</span>		req.Header.Get(&#34;Range&#34;) == &#34;&#34; &amp;&amp;
<span id="L6079" class="ln">  6079	</span>		req.Method != &#34;HEAD&#34; {
<span id="L6080" class="ln">  6080	</span>
<span id="L6081" class="ln">  6081	</span>		requestedGzip = true
<span id="L6082" class="ln">  6082	</span>	}
<span id="L6083" class="ln">  6083	</span>
<span id="L6084" class="ln">  6084	</span>	hdrs, err := cc.encodeHeaders(req, requestedGzip, trailers, contentLen)
<span id="L6085" class="ln">  6085	</span>	if err != nil {
<span id="L6086" class="ln">  6086	</span>		cc.mu.Unlock()
<span id="L6087" class="ln">  6087	</span>		return nil, err
<span id="L6088" class="ln">  6088	</span>	}
<span id="L6089" class="ln">  6089	</span>
<span id="L6090" class="ln">  6090	</span>	cs := cc.newStream()
<span id="L6091" class="ln">  6091	</span>	cs.req = req
<span id="L6092" class="ln">  6092	</span>	cs.trace = http2requestTrace(req)
<span id="L6093" class="ln">  6093	</span>	cs.requestedGzip = requestedGzip
<span id="L6094" class="ln">  6094	</span>	bodyWriter := cc.t.getBodyWriterState(cs, body)
<span id="L6095" class="ln">  6095	</span>	cs.on100 = bodyWriter.on100
<span id="L6096" class="ln">  6096	</span>
<span id="L6097" class="ln">  6097	</span>	cc.wmu.Lock()
<span id="L6098" class="ln">  6098	</span>	endStream := !hasBody &amp;&amp; !hasTrailers
<span id="L6099" class="ln">  6099	</span>	werr := cc.writeHeaders(cs.ID, endStream, hdrs)
<span id="L6100" class="ln">  6100	</span>	cc.wmu.Unlock()
<span id="L6101" class="ln">  6101	</span>	http2traceWroteHeaders(cs.trace)
<span id="L6102" class="ln">  6102	</span>	cc.mu.Unlock()
<span id="L6103" class="ln">  6103	</span>
<span id="L6104" class="ln">  6104	</span>	if werr != nil {
<span id="L6105" class="ln">  6105	</span>		if hasBody {
<span id="L6106" class="ln">  6106	</span>			req.Body.Close()
<span id="L6107" class="ln">  6107	</span>			bodyWriter.cancel()
<span id="L6108" class="ln">  6108	</span>		}
<span id="L6109" class="ln">  6109	</span>		cc.forgetStreamID(cs.ID)
<span id="L6110" class="ln">  6110	</span>
<span id="L6111" class="ln">  6111	</span>		http2traceWroteRequest(cs.trace, werr)
<span id="L6112" class="ln">  6112	</span>		return nil, werr
<span id="L6113" class="ln">  6113	</span>	}
<span id="L6114" class="ln">  6114	</span>
<span id="L6115" class="ln">  6115	</span>	var respHeaderTimer &lt;-chan time.Time
<span id="L6116" class="ln">  6116	</span>	if hasBody {
<span id="L6117" class="ln">  6117	</span>		bodyWriter.scheduleBodyWrite()
<span id="L6118" class="ln">  6118	</span>	} else {
<span id="L6119" class="ln">  6119	</span>		http2traceWroteRequest(cs.trace, nil)
<span id="L6120" class="ln">  6120	</span>		if d := cc.responseHeaderTimeout(); d != 0 {
<span id="L6121" class="ln">  6121	</span>			timer := time.NewTimer(d)
<span id="L6122" class="ln">  6122	</span>			defer timer.Stop()
<span id="L6123" class="ln">  6123	</span>			respHeaderTimer = timer.C
<span id="L6124" class="ln">  6124	</span>		}
<span id="L6125" class="ln">  6125	</span>	}
<span id="L6126" class="ln">  6126	</span>
<span id="L6127" class="ln">  6127	</span>	readLoopResCh := cs.resc
<span id="L6128" class="ln">  6128	</span>	bodyWritten := false
<span id="L6129" class="ln">  6129	</span>	ctx := http2reqContext(req)
<span id="L6130" class="ln">  6130	</span>
<span id="L6131" class="ln">  6131	</span>	handleReadLoopResponse := func(re http2resAndError) (*Response, error) {
<span id="L6132" class="ln">  6132	</span>		res := re.res
<span id="L6133" class="ln">  6133	</span>		if re.err != nil || res.StatusCode &gt; 299 {
<span id="L6134" class="ln">  6134	</span>
<span id="L6135" class="ln">  6135	</span>			bodyWriter.cancel()
<span id="L6136" class="ln">  6136	</span>			cs.abortRequestBodyWrite(http2errStopReqBodyWrite)
<span id="L6137" class="ln">  6137	</span>		}
<span id="L6138" class="ln">  6138	</span>		if re.err != nil {
<span id="L6139" class="ln">  6139	</span>			if re.err == http2errClientConnGotGoAway {
<span id="L6140" class="ln">  6140	</span>				cc.mu.Lock()
<span id="L6141" class="ln">  6141	</span>				if cs.startedWrite {
<span id="L6142" class="ln">  6142	</span>					re.err = http2errClientConnGotGoAwayAfterSomeReqBody
<span id="L6143" class="ln">  6143	</span>				}
<span id="L6144" class="ln">  6144	</span>				cc.mu.Unlock()
<span id="L6145" class="ln">  6145	</span>			}
<span id="L6146" class="ln">  6146	</span>			cc.forgetStreamID(cs.ID)
<span id="L6147" class="ln">  6147	</span>			return nil, re.err
<span id="L6148" class="ln">  6148	</span>		}
<span id="L6149" class="ln">  6149	</span>		res.Request = req
<span id="L6150" class="ln">  6150	</span>		res.TLS = cc.tlsState
<span id="L6151" class="ln">  6151	</span>		return res, nil
<span id="L6152" class="ln">  6152	</span>	}
<span id="L6153" class="ln">  6153	</span>
<span id="L6154" class="ln">  6154	</span>	for {
<span id="L6155" class="ln">  6155	</span>		select {
<span id="L6156" class="ln">  6156	</span>		case re := &lt;-readLoopResCh:
<span id="L6157" class="ln">  6157	</span>			return handleReadLoopResponse(re)
<span id="L6158" class="ln">  6158	</span>		case &lt;-respHeaderTimer:
<span id="L6159" class="ln">  6159	</span>			cc.forgetStreamID(cs.ID)
<span id="L6160" class="ln">  6160	</span>			if !hasBody || bodyWritten {
<span id="L6161" class="ln">  6161	</span>				cc.writeStreamReset(cs.ID, http2ErrCodeCancel, nil)
<span id="L6162" class="ln">  6162	</span>			} else {
<span id="L6163" class="ln">  6163	</span>				bodyWriter.cancel()
<span id="L6164" class="ln">  6164	</span>				cs.abortRequestBodyWrite(http2errStopReqBodyWriteAndCancel)
<span id="L6165" class="ln">  6165	</span>			}
<span id="L6166" class="ln">  6166	</span>			return nil, http2errTimeout
<span id="L6167" class="ln">  6167	</span>		case &lt;-ctx.Done():
<span id="L6168" class="ln">  6168	</span>			cc.forgetStreamID(cs.ID)
<span id="L6169" class="ln">  6169	</span>			if !hasBody || bodyWritten {
<span id="L6170" class="ln">  6170	</span>				cc.writeStreamReset(cs.ID, http2ErrCodeCancel, nil)
<span id="L6171" class="ln">  6171	</span>			} else {
<span id="L6172" class="ln">  6172	</span>				bodyWriter.cancel()
<span id="L6173" class="ln">  6173	</span>				cs.abortRequestBodyWrite(http2errStopReqBodyWriteAndCancel)
<span id="L6174" class="ln">  6174	</span>			}
<span id="L6175" class="ln">  6175	</span>			return nil, ctx.Err()
<span id="L6176" class="ln">  6176	</span>		case &lt;-req.Cancel:
<span id="L6177" class="ln">  6177	</span>			cc.forgetStreamID(cs.ID)
<span id="L6178" class="ln">  6178	</span>			if !hasBody || bodyWritten {
<span id="L6179" class="ln">  6179	</span>				cc.writeStreamReset(cs.ID, http2ErrCodeCancel, nil)
<span id="L6180" class="ln">  6180	</span>			} else {
<span id="L6181" class="ln">  6181	</span>				bodyWriter.cancel()
<span id="L6182" class="ln">  6182	</span>				cs.abortRequestBodyWrite(http2errStopReqBodyWriteAndCancel)
<span id="L6183" class="ln">  6183	</span>			}
<span id="L6184" class="ln">  6184	</span>			return nil, http2errRequestCanceled
<span id="L6185" class="ln">  6185	</span>		case &lt;-cs.peerReset:
<span id="L6186" class="ln">  6186	</span>
<span id="L6187" class="ln">  6187	</span>			return nil, cs.resetErr
<span id="L6188" class="ln">  6188	</span>		case err := &lt;-bodyWriter.resc:
<span id="L6189" class="ln">  6189	</span>
<span id="L6190" class="ln">  6190	</span>			select {
<span id="L6191" class="ln">  6191	</span>			case re := &lt;-readLoopResCh:
<span id="L6192" class="ln">  6192	</span>				return handleReadLoopResponse(re)
<span id="L6193" class="ln">  6193	</span>			default:
<span id="L6194" class="ln">  6194	</span>			}
<span id="L6195" class="ln">  6195	</span>			if err != nil {
<span id="L6196" class="ln">  6196	</span>				return nil, err
<span id="L6197" class="ln">  6197	</span>			}
<span id="L6198" class="ln">  6198	</span>			bodyWritten = true
<span id="L6199" class="ln">  6199	</span>			if d := cc.responseHeaderTimeout(); d != 0 {
<span id="L6200" class="ln">  6200	</span>				timer := time.NewTimer(d)
<span id="L6201" class="ln">  6201	</span>				defer timer.Stop()
<span id="L6202" class="ln">  6202	</span>				respHeaderTimer = timer.C
<span id="L6203" class="ln">  6203	</span>			}
<span id="L6204" class="ln">  6204	</span>		}
<span id="L6205" class="ln">  6205	</span>	}
<span id="L6206" class="ln">  6206	</span>}
<span id="L6207" class="ln">  6207	</span>
<span id="L6208" class="ln">  6208	</span><span class="comment">// requires cc.wmu be held</span>
<span id="L6209" class="ln">  6209	</span>func (cc *http2ClientConn) writeHeaders(streamID uint32, endStream bool, hdrs []byte) error {
<span id="L6210" class="ln">  6210	</span>	first := true
<span id="L6211" class="ln">  6211	</span>	frameSize := int(cc.maxFrameSize)
<span id="L6212" class="ln">  6212	</span>	for len(hdrs) &gt; 0 &amp;&amp; cc.werr == nil {
<span id="L6213" class="ln">  6213	</span>		chunk := hdrs
<span id="L6214" class="ln">  6214	</span>		if len(chunk) &gt; frameSize {
<span id="L6215" class="ln">  6215	</span>			chunk = chunk[:frameSize]
<span id="L6216" class="ln">  6216	</span>		}
<span id="L6217" class="ln">  6217	</span>		hdrs = hdrs[len(chunk):]
<span id="L6218" class="ln">  6218	</span>		endHeaders := len(hdrs) == 0
<span id="L6219" class="ln">  6219	</span>		if first {
<span id="L6220" class="ln">  6220	</span>			cc.fr.WriteHeaders(http2HeadersFrameParam{
<span id="L6221" class="ln">  6221	</span>				StreamID:      streamID,
<span id="L6222" class="ln">  6222	</span>				BlockFragment: chunk,
<span id="L6223" class="ln">  6223	</span>				EndStream:     endStream,
<span id="L6224" class="ln">  6224	</span>				EndHeaders:    endHeaders,
<span id="L6225" class="ln">  6225	</span>			})
<span id="L6226" class="ln">  6226	</span>			first = false
<span id="L6227" class="ln">  6227	</span>		} else {
<span id="L6228" class="ln">  6228	</span>			cc.fr.WriteContinuation(streamID, endHeaders, chunk)
<span id="L6229" class="ln">  6229	</span>		}
<span id="L6230" class="ln">  6230	</span>	}
<span id="L6231" class="ln">  6231	</span>
<span id="L6232" class="ln">  6232	</span>	cc.bw.Flush()
<span id="L6233" class="ln">  6233	</span>	return cc.werr
<span id="L6234" class="ln">  6234	</span>}
<span id="L6235" class="ln">  6235	</span>
<span id="L6236" class="ln">  6236	</span><span class="comment">// internal error values; they don&#39;t escape to callers</span>
<span id="L6237" class="ln">  6237	</span>var (
<span id="L6238" class="ln">  6238	</span>	<span class="comment">// abort request body write; don&#39;t send cancel</span>
<span id="L6239" class="ln">  6239	</span>	http2errStopReqBodyWrite = errors.New(&#34;http2: aborting request body write&#34;)
<span id="L6240" class="ln">  6240	</span>
<span id="L6241" class="ln">  6241	</span>	<span class="comment">// abort request body write, but send stream reset of cancel.</span>
<span id="L6242" class="ln">  6242	</span>	http2errStopReqBodyWriteAndCancel = errors.New(&#34;http2: canceling request&#34;)
<span id="L6243" class="ln">  6243	</span>)
<span id="L6244" class="ln">  6244	</span>
<span id="L6245" class="ln">  6245	</span>func (cs *http2clientStream) writeRequestBody(body io.Reader, bodyCloser io.Closer) (err error) {
<span id="L6246" class="ln">  6246	</span>	cc := cs.cc
<span id="L6247" class="ln">  6247	</span>	sentEnd := false
<span id="L6248" class="ln">  6248	</span>	buf := cc.frameScratchBuffer()
<span id="L6249" class="ln">  6249	</span>	defer cc.putFrameScratchBuffer(buf)
<span id="L6250" class="ln">  6250	</span>
<span id="L6251" class="ln">  6251	</span>	defer func() {
<span id="L6252" class="ln">  6252	</span>		http2traceWroteRequest(cs.trace, err)
<span id="L6253" class="ln">  6253	</span>
<span id="L6254" class="ln">  6254	</span>		cerr := bodyCloser.Close()
<span id="L6255" class="ln">  6255	</span>		if err == nil {
<span id="L6256" class="ln">  6256	</span>			err = cerr
<span id="L6257" class="ln">  6257	</span>		}
<span id="L6258" class="ln">  6258	</span>	}()
<span id="L6259" class="ln">  6259	</span>
<span id="L6260" class="ln">  6260	</span>	req := cs.req
<span id="L6261" class="ln">  6261	</span>	hasTrailers := req.Trailer != nil
<span id="L6262" class="ln">  6262	</span>
<span id="L6263" class="ln">  6263	</span>	var sawEOF bool
<span id="L6264" class="ln">  6264	</span>	for !sawEOF {
<span id="L6265" class="ln">  6265	</span>		n, err := body.Read(buf)
<span id="L6266" class="ln">  6266	</span>		if err == io.EOF {
<span id="L6267" class="ln">  6267	</span>			sawEOF = true
<span id="L6268" class="ln">  6268	</span>			err = nil
<span id="L6269" class="ln">  6269	</span>		} else if err != nil {
<span id="L6270" class="ln">  6270	</span>			return err
<span id="L6271" class="ln">  6271	</span>		}
<span id="L6272" class="ln">  6272	</span>
<span id="L6273" class="ln">  6273	</span>		remain := buf[:n]
<span id="L6274" class="ln">  6274	</span>		for len(remain) &gt; 0 &amp;&amp; err == nil {
<span id="L6275" class="ln">  6275	</span>			var allowed int32
<span id="L6276" class="ln">  6276	</span>			allowed, err = cs.awaitFlowControl(len(remain))
<span id="L6277" class="ln">  6277	</span>			switch {
<span id="L6278" class="ln">  6278	</span>			case err == http2errStopReqBodyWrite:
<span id="L6279" class="ln">  6279	</span>				return err
<span id="L6280" class="ln">  6280	</span>			case err == http2errStopReqBodyWriteAndCancel:
<span id="L6281" class="ln">  6281	</span>				cc.writeStreamReset(cs.ID, http2ErrCodeCancel, nil)
<span id="L6282" class="ln">  6282	</span>				return err
<span id="L6283" class="ln">  6283	</span>			case err != nil:
<span id="L6284" class="ln">  6284	</span>				return err
<span id="L6285" class="ln">  6285	</span>			}
<span id="L6286" class="ln">  6286	</span>			cc.wmu.Lock()
<span id="L6287" class="ln">  6287	</span>			data := remain[:allowed]
<span id="L6288" class="ln">  6288	</span>			remain = remain[allowed:]
<span id="L6289" class="ln">  6289	</span>			sentEnd = sawEOF &amp;&amp; len(remain) == 0 &amp;&amp; !hasTrailers
<span id="L6290" class="ln">  6290	</span>			err = cc.fr.WriteData(cs.ID, sentEnd, data)
<span id="L6291" class="ln">  6291	</span>			if err == nil {
<span id="L6292" class="ln">  6292	</span>
<span id="L6293" class="ln">  6293	</span>				err = cc.bw.Flush()
<span id="L6294" class="ln">  6294	</span>			}
<span id="L6295" class="ln">  6295	</span>			cc.wmu.Unlock()
<span id="L6296" class="ln">  6296	</span>		}
<span id="L6297" class="ln">  6297	</span>		if err != nil {
<span id="L6298" class="ln">  6298	</span>			return err
<span id="L6299" class="ln">  6299	</span>		}
<span id="L6300" class="ln">  6300	</span>	}
<span id="L6301" class="ln">  6301	</span>
<span id="L6302" class="ln">  6302	</span>	if sentEnd {
<span id="L6303" class="ln">  6303	</span>
<span id="L6304" class="ln">  6304	</span>		return nil
<span id="L6305" class="ln">  6305	</span>	}
<span id="L6306" class="ln">  6306	</span>
<span id="L6307" class="ln">  6307	</span>	var trls []byte
<span id="L6308" class="ln">  6308	</span>	if hasTrailers {
<span id="L6309" class="ln">  6309	</span>		cc.mu.Lock()
<span id="L6310" class="ln">  6310	</span>		defer cc.mu.Unlock()
<span id="L6311" class="ln">  6311	</span>		trls = cc.encodeTrailers(req)
<span id="L6312" class="ln">  6312	</span>	}
<span id="L6313" class="ln">  6313	</span>
<span id="L6314" class="ln">  6314	</span>	cc.wmu.Lock()
<span id="L6315" class="ln">  6315	</span>	defer cc.wmu.Unlock()
<span id="L6316" class="ln">  6316	</span>
<span id="L6317" class="ln">  6317	</span>	if len(trls) &gt; 0 {
<span id="L6318" class="ln">  6318	</span>		err = cc.writeHeaders(cs.ID, true, trls)
<span id="L6319" class="ln">  6319	</span>	} else {
<span id="L6320" class="ln">  6320	</span>		err = cc.fr.WriteData(cs.ID, true, nil)
<span id="L6321" class="ln">  6321	</span>	}
<span id="L6322" class="ln">  6322	</span>	if ferr := cc.bw.Flush(); ferr != nil &amp;&amp; err == nil {
<span id="L6323" class="ln">  6323	</span>		err = ferr
<span id="L6324" class="ln">  6324	</span>	}
<span id="L6325" class="ln">  6325	</span>	return err
<span id="L6326" class="ln">  6326	</span>}
<span id="L6327" class="ln">  6327	</span>
<span id="L6328" class="ln">  6328	</span><span class="comment">// awaitFlowControl waits for [1, min(maxBytes, cc.cs.maxFrameSize)] flow</span>
<span id="L6329" class="ln">  6329	</span><span class="comment">// control tokens from the server.</span>
<span id="L6330" class="ln">  6330	</span><span class="comment">// It returns either the non-zero number of tokens taken or an error</span>
<span id="L6331" class="ln">  6331	</span><span class="comment">// if the stream is dead.</span>
<span id="L6332" class="ln">  6332	</span>func (cs *http2clientStream) awaitFlowControl(maxBytes int) (taken int32, err error) {
<span id="L6333" class="ln">  6333	</span>	cc := cs.cc
<span id="L6334" class="ln">  6334	</span>	cc.mu.Lock()
<span id="L6335" class="ln">  6335	</span>	defer cc.mu.Unlock()
<span id="L6336" class="ln">  6336	</span>	for {
<span id="L6337" class="ln">  6337	</span>		if cc.closed {
<span id="L6338" class="ln">  6338	</span>			return 0, http2errClientConnClosed
<span id="L6339" class="ln">  6339	</span>		}
<span id="L6340" class="ln">  6340	</span>		if cs.stopReqBody != nil {
<span id="L6341" class="ln">  6341	</span>			return 0, cs.stopReqBody
<span id="L6342" class="ln">  6342	</span>		}
<span id="L6343" class="ln">  6343	</span>		if err := cs.checkResetOrDone(); err != nil {
<span id="L6344" class="ln">  6344	</span>			return 0, err
<span id="L6345" class="ln">  6345	</span>		}
<span id="L6346" class="ln">  6346	</span>		if a := cs.flow.available(); a &gt; 0 {
<span id="L6347" class="ln">  6347	</span>			take := a
<span id="L6348" class="ln">  6348	</span>			if int(take) &gt; maxBytes {
<span id="L6349" class="ln">  6349	</span>
<span id="L6350" class="ln">  6350	</span>				take = int32(maxBytes)
<span id="L6351" class="ln">  6351	</span>			}
<span id="L6352" class="ln">  6352	</span>			if take &gt; int32(cc.maxFrameSize) {
<span id="L6353" class="ln">  6353	</span>				take = int32(cc.maxFrameSize)
<span id="L6354" class="ln">  6354	</span>			}
<span id="L6355" class="ln">  6355	</span>			cs.flow.take(take)
<span id="L6356" class="ln">  6356	</span>			return take, nil
<span id="L6357" class="ln">  6357	</span>		}
<span id="L6358" class="ln">  6358	</span>		cc.cond.Wait()
<span id="L6359" class="ln">  6359	</span>	}
<span id="L6360" class="ln">  6360	</span>}
<span id="L6361" class="ln">  6361	</span>
<span id="L6362" class="ln">  6362	</span>type http2badStringError struct {
<span id="L6363" class="ln">  6363	</span>	what string
<span id="L6364" class="ln">  6364	</span>	str  string
<span id="L6365" class="ln">  6365	</span>}
<span id="L6366" class="ln">  6366	</span>
<span id="L6367" class="ln">  6367	</span>func (e *http2badStringError) Error() string { return fmt.Sprintf(&#34;%s %q&#34;, e.what, e.str) }
<span id="L6368" class="ln">  6368	</span>
<span id="L6369" class="ln">  6369	</span><span class="comment">// requires cc.mu be held.</span>
<span id="L6370" class="ln">  6370	</span>func (cc *http2ClientConn) encodeHeaders(req *Request, addGzipHeader bool, trailers string, contentLength int64) ([]byte, error) {
<span id="L6371" class="ln">  6371	</span>	cc.hbuf.Reset()
<span id="L6372" class="ln">  6372	</span>
<span id="L6373" class="ln">  6373	</span>	host := req.Host
<span id="L6374" class="ln">  6374	</span>	if host == &#34;&#34; {
<span id="L6375" class="ln">  6375	</span>		host = req.URL.Host
<span id="L6376" class="ln">  6376	</span>	}
<span id="L6377" class="ln">  6377	</span>	host, err := httplex.PunycodeHostPort(host)
<span id="L6378" class="ln">  6378	</span>	if err != nil {
<span id="L6379" class="ln">  6379	</span>		return nil, err
<span id="L6380" class="ln">  6380	</span>	}
<span id="L6381" class="ln">  6381	</span>
<span id="L6382" class="ln">  6382	</span>	var path string
<span id="L6383" class="ln">  6383	</span>	if req.Method != &#34;CONNECT&#34; {
<span id="L6384" class="ln">  6384	</span>		path = req.URL.RequestURI()
<span id="L6385" class="ln">  6385	</span>		if !http2validPseudoPath(path) {
<span id="L6386" class="ln">  6386	</span>			orig := path
<span id="L6387" class="ln">  6387	</span>			path = strings.TrimPrefix(path, req.URL.Scheme+&#34;://&#34;+host)
<span id="L6388" class="ln">  6388	</span>			if !http2validPseudoPath(path) {
<span id="L6389" class="ln">  6389	</span>				if req.URL.Opaque != &#34;&#34; {
<span id="L6390" class="ln">  6390	</span>					return nil, fmt.Errorf(&#34;invalid request :path %q from URL.Opaque = %q&#34;, orig, req.URL.Opaque)
<span id="L6391" class="ln">  6391	</span>				} else {
<span id="L6392" class="ln">  6392	</span>					return nil, fmt.Errorf(&#34;invalid request :path %q&#34;, orig)
<span id="L6393" class="ln">  6393	</span>				}
<span id="L6394" class="ln">  6394	</span>			}
<span id="L6395" class="ln">  6395	</span>		}
<span id="L6396" class="ln">  6396	</span>	}
<span id="L6397" class="ln">  6397	</span>
<span id="L6398" class="ln">  6398	</span>	for k, vv := range req.Header {
<span id="L6399" class="ln">  6399	</span>		if !httplex.ValidHeaderFieldName(k) {
<span id="L6400" class="ln">  6400	</span>			return nil, fmt.Errorf(&#34;invalid HTTP header name %q&#34;, k)
<span id="L6401" class="ln">  6401	</span>		}
<span id="L6402" class="ln">  6402	</span>		for _, v := range vv {
<span id="L6403" class="ln">  6403	</span>			if !httplex.ValidHeaderFieldValue(v) {
<span id="L6404" class="ln">  6404	</span>				return nil, fmt.Errorf(&#34;invalid HTTP header value %q for header %q&#34;, v, k)
<span id="L6405" class="ln">  6405	</span>			}
<span id="L6406" class="ln">  6406	</span>		}
<span id="L6407" class="ln">  6407	</span>	}
<span id="L6408" class="ln">  6408	</span>
<span id="L6409" class="ln">  6409	</span>	cc.writeHeader(&#34;:authority&#34;, host)
<span id="L6410" class="ln">  6410	</span>	cc.writeHeader(&#34;:method&#34;, req.Method)
<span id="L6411" class="ln">  6411	</span>	if req.Method != &#34;CONNECT&#34; {
<span id="L6412" class="ln">  6412	</span>		cc.writeHeader(&#34;:path&#34;, path)
<span id="L6413" class="ln">  6413	</span>		cc.writeHeader(&#34;:scheme&#34;, req.URL.Scheme)
<span id="L6414" class="ln">  6414	</span>	}
<span id="L6415" class="ln">  6415	</span>	if trailers != &#34;&#34; {
<span id="L6416" class="ln">  6416	</span>		cc.writeHeader(&#34;trailer&#34;, trailers)
<span id="L6417" class="ln">  6417	</span>	}
<span id="L6418" class="ln">  6418	</span>
<span id="L6419" class="ln">  6419	</span>	var didUA bool
<span id="L6420" class="ln">  6420	</span>	for k, vv := range req.Header {
<span id="L6421" class="ln">  6421	</span>		lowKey := strings.ToLower(k)
<span id="L6422" class="ln">  6422	</span>		switch lowKey {
<span id="L6423" class="ln">  6423	</span>		case &#34;host&#34;, &#34;content-length&#34;:
<span id="L6424" class="ln">  6424	</span>
<span id="L6425" class="ln">  6425	</span>			continue
<span id="L6426" class="ln">  6426	</span>		case &#34;connection&#34;, &#34;proxy-connection&#34;, &#34;transfer-encoding&#34;, &#34;upgrade&#34;, &#34;keep-alive&#34;:
<span id="L6427" class="ln">  6427	</span>
<span id="L6428" class="ln">  6428	</span>			continue
<span id="L6429" class="ln">  6429	</span>		case &#34;user-agent&#34;:
<span id="L6430" class="ln">  6430	</span>
<span id="L6431" class="ln">  6431	</span>			didUA = true
<span id="L6432" class="ln">  6432	</span>			if len(vv) &lt; 1 {
<span id="L6433" class="ln">  6433	</span>				continue
<span id="L6434" class="ln">  6434	</span>			}
<span id="L6435" class="ln">  6435	</span>			vv = vv[:1]
<span id="L6436" class="ln">  6436	</span>			if vv[0] == &#34;&#34; {
<span id="L6437" class="ln">  6437	</span>				continue
<span id="L6438" class="ln">  6438	</span>			}
<span id="L6439" class="ln">  6439	</span>		}
<span id="L6440" class="ln">  6440	</span>		for _, v := range vv {
<span id="L6441" class="ln">  6441	</span>			cc.writeHeader(lowKey, v)
<span id="L6442" class="ln">  6442	</span>		}
<span id="L6443" class="ln">  6443	</span>	}
<span id="L6444" class="ln">  6444	</span>	if http2shouldSendReqContentLength(req.Method, contentLength) {
<span id="L6445" class="ln">  6445	</span>		cc.writeHeader(&#34;content-length&#34;, strconv.FormatInt(contentLength, 10))
<span id="L6446" class="ln">  6446	</span>	}
<span id="L6447" class="ln">  6447	</span>	if addGzipHeader {
<span id="L6448" class="ln">  6448	</span>		cc.writeHeader(&#34;accept-encoding&#34;, &#34;gzip&#34;)
<span id="L6449" class="ln">  6449	</span>	}
<span id="L6450" class="ln">  6450	</span>	if !didUA {
<span id="L6451" class="ln">  6451	</span>		cc.writeHeader(&#34;user-agent&#34;, http2defaultUserAgent)
<span id="L6452" class="ln">  6452	</span>	}
<span id="L6453" class="ln">  6453	</span>	return cc.hbuf.Bytes(), nil
<span id="L6454" class="ln">  6454	</span>}
<span id="L6455" class="ln">  6455	</span>
<span id="L6456" class="ln">  6456	</span><span class="comment">// shouldSendReqContentLength reports whether the http2.Transport should send</span>
<span id="L6457" class="ln">  6457	</span><span class="comment">// a &#34;content-length&#34; request header. This logic is basically a copy of the net/http</span>
<span id="L6458" class="ln">  6458	</span><span class="comment">// transferWriter.shouldSendContentLength.</span>
<span id="L6459" class="ln">  6459	</span><span class="comment">// The contentLength is the corrected contentLength (so 0 means actually 0, not unknown).</span>
<span id="L6460" class="ln">  6460	</span><span class="comment">// -1 means unknown.</span>
<span id="L6461" class="ln">  6461	</span>func http2shouldSendReqContentLength(method string, contentLength int64) bool {
<span id="L6462" class="ln">  6462	</span>	if contentLength &gt; 0 {
<span id="L6463" class="ln">  6463	</span>		return true
<span id="L6464" class="ln">  6464	</span>	}
<span id="L6465" class="ln">  6465	</span>	if contentLength &lt; 0 {
<span id="L6466" class="ln">  6466	</span>		return false
<span id="L6467" class="ln">  6467	</span>	}
<span id="L6468" class="ln">  6468	</span>
<span id="L6469" class="ln">  6469	</span>	switch method {
<span id="L6470" class="ln">  6470	</span>	case &#34;POST&#34;, &#34;PUT&#34;, &#34;PATCH&#34;:
<span id="L6471" class="ln">  6471	</span>		return true
<span id="L6472" class="ln">  6472	</span>	default:
<span id="L6473" class="ln">  6473	</span>		return false
<span id="L6474" class="ln">  6474	</span>	}
<span id="L6475" class="ln">  6475	</span>}
<span id="L6476" class="ln">  6476	</span>
<span id="L6477" class="ln">  6477	</span><span class="comment">// requires cc.mu be held.</span>
<span id="L6478" class="ln">  6478	</span>func (cc *http2ClientConn) encodeTrailers(req *Request) []byte {
<span id="L6479" class="ln">  6479	</span>	cc.hbuf.Reset()
<span id="L6480" class="ln">  6480	</span>	for k, vv := range req.Trailer {
<span id="L6481" class="ln">  6481	</span>
<span id="L6482" class="ln">  6482	</span>		lowKey := strings.ToLower(k)
<span id="L6483" class="ln">  6483	</span>		for _, v := range vv {
<span id="L6484" class="ln">  6484	</span>			cc.writeHeader(lowKey, v)
<span id="L6485" class="ln">  6485	</span>		}
<span id="L6486" class="ln">  6486	</span>	}
<span id="L6487" class="ln">  6487	</span>	return cc.hbuf.Bytes()
<span id="L6488" class="ln">  6488	</span>}
<span id="L6489" class="ln">  6489	</span>
<span id="L6490" class="ln">  6490	</span>func (cc *http2ClientConn) writeHeader(name, value string) {
<span id="L6491" class="ln">  6491	</span>	if http2VerboseLogs {
<span id="L6492" class="ln">  6492	</span>		log.Printf(&#34;http2: Transport encoding header %q = %q&#34;, name, value)
<span id="L6493" class="ln">  6493	</span>	}
<span id="L6494" class="ln">  6494	</span>	cc.henc.WriteField(hpack.HeaderField{Name: name, Value: value})
<span id="L6495" class="ln">  6495	</span>}
<span id="L6496" class="ln">  6496	</span>
<span id="L6497" class="ln">  6497	</span>type http2resAndError struct {
<span id="L6498" class="ln">  6498	</span>	res *Response
<span id="L6499" class="ln">  6499	</span>	err error
<span id="L6500" class="ln">  6500	</span>}
<span id="L6501" class="ln">  6501	</span>
<span id="L6502" class="ln">  6502	</span><span class="comment">// requires cc.mu be held.</span>
<span id="L6503" class="ln">  6503	</span>func (cc *http2ClientConn) newStream() *http2clientStream {
<span id="L6504" class="ln">  6504	</span>	cs := &amp;http2clientStream{
<span id="L6505" class="ln">  6505	</span>		cc:        cc,
<span id="L6506" class="ln">  6506	</span>		ID:        cc.nextStreamID,
<span id="L6507" class="ln">  6507	</span>		resc:      make(chan http2resAndError, 1),
<span id="L6508" class="ln">  6508	</span>		peerReset: make(chan struct{}),
<span id="L6509" class="ln">  6509	</span>		done:      make(chan struct{}),
<span id="L6510" class="ln">  6510	</span>	}
<span id="L6511" class="ln">  6511	</span>	cs.flow.add(int32(cc.initialWindowSize))
<span id="L6512" class="ln">  6512	</span>	cs.flow.setConnFlow(&amp;cc.flow)
<span id="L6513" class="ln">  6513	</span>	cs.inflow.add(http2transportDefaultStreamFlow)
<span id="L6514" class="ln">  6514	</span>	cs.inflow.setConnFlow(&amp;cc.inflow)
<span id="L6515" class="ln">  6515	</span>	cc.nextStreamID += 2
<span id="L6516" class="ln">  6516	</span>	cc.streams[cs.ID] = cs
<span id="L6517" class="ln">  6517	</span>	return cs
<span id="L6518" class="ln">  6518	</span>}
<span id="L6519" class="ln">  6519	</span>
<span id="L6520" class="ln">  6520	</span>func (cc *http2ClientConn) forgetStreamID(id uint32) {
<span id="L6521" class="ln">  6521	</span>	cc.streamByID(id, true)
<span id="L6522" class="ln">  6522	</span>}
<span id="L6523" class="ln">  6523	</span>
<span id="L6524" class="ln">  6524	</span>func (cc *http2ClientConn) streamByID(id uint32, andRemove bool) *http2clientStream {
<span id="L6525" class="ln">  6525	</span>	cc.mu.Lock()
<span id="L6526" class="ln">  6526	</span>	defer cc.mu.Unlock()
<span id="L6527" class="ln">  6527	</span>	cs := cc.streams[id]
<span id="L6528" class="ln">  6528	</span>	if andRemove &amp;&amp; cs != nil &amp;&amp; !cc.closed {
<span id="L6529" class="ln">  6529	</span>		cc.lastActive = time.Now()
<span id="L6530" class="ln">  6530	</span>		delete(cc.streams, id)
<span id="L6531" class="ln">  6531	</span>		if len(cc.streams) == 0 &amp;&amp; cc.idleTimer != nil {
<span id="L6532" class="ln">  6532	</span>			cc.idleTimer.Reset(cc.idleTimeout)
<span id="L6533" class="ln">  6533	</span>		}
<span id="L6534" class="ln">  6534	</span>		close(cs.done)
<span id="L6535" class="ln">  6535	</span>		cc.cond.Broadcast()
<span id="L6536" class="ln">  6536	</span>	}
<span id="L6537" class="ln">  6537	</span>	return cs
<span id="L6538" class="ln">  6538	</span>}
<span id="L6539" class="ln">  6539	</span>
<span id="L6540" class="ln">  6540	</span><span class="comment">// clientConnReadLoop is the state owned by the clientConn&#39;s frame-reading readLoop.</span>
<span id="L6541" class="ln">  6541	</span>type http2clientConnReadLoop struct {
<span id="L6542" class="ln">  6542	</span>	cc            *http2ClientConn
<span id="L6543" class="ln">  6543	</span>	activeRes     map[uint32]*http2clientStream <span class="comment">// keyed by streamID</span>
<span id="L6544" class="ln">  6544	</span>	closeWhenIdle bool
<span id="L6545" class="ln">  6545	</span>}
<span id="L6546" class="ln">  6546	</span>
<span id="L6547" class="ln">  6547	</span><span class="comment">// readLoop runs in its own goroutine and reads and dispatches frames.</span>
<span id="L6548" class="ln">  6548	</span>func (cc *http2ClientConn) readLoop() {
<span id="L6549" class="ln">  6549	</span>	rl := &amp;http2clientConnReadLoop{
<span id="L6550" class="ln">  6550	</span>		cc:        cc,
<span id="L6551" class="ln">  6551	</span>		activeRes: make(map[uint32]*http2clientStream),
<span id="L6552" class="ln">  6552	</span>	}
<span id="L6553" class="ln">  6553	</span>
<span id="L6554" class="ln">  6554	</span>	defer rl.cleanup()
<span id="L6555" class="ln">  6555	</span>	cc.readerErr = rl.run()
<span id="L6556" class="ln">  6556	</span>	if ce, ok := cc.readerErr.(http2ConnectionError); ok {
<span id="L6557" class="ln">  6557	</span>		cc.wmu.Lock()
<span id="L6558" class="ln">  6558	</span>		cc.fr.WriteGoAway(0, http2ErrCode(ce), nil)
<span id="L6559" class="ln">  6559	</span>		cc.wmu.Unlock()
<span id="L6560" class="ln">  6560	</span>	}
<span id="L6561" class="ln">  6561	</span>}
<span id="L6562" class="ln">  6562	</span>
<span id="L6563" class="ln">  6563	</span><span class="comment">// GoAwayError is returned by the Transport when the server closes the</span>
<span id="L6564" class="ln">  6564	</span><span class="comment">// TCP connection after sending a GOAWAY frame.</span>
<span id="L6565" class="ln">  6565	</span>type http2GoAwayError struct {
<span id="L6566" class="ln">  6566	</span>	LastStreamID uint32
<span id="L6567" class="ln">  6567	</span>	ErrCode      http2ErrCode
<span id="L6568" class="ln">  6568	</span>	DebugData    string
<span id="L6569" class="ln">  6569	</span>}
<span id="L6570" class="ln">  6570	</span>
<span id="L6571" class="ln">  6571	</span>func (e http2GoAwayError) Error() string {
<span id="L6572" class="ln">  6572	</span>	return fmt.Sprintf(&#34;http2: server sent GOAWAY and closed the connection; LastStreamID=%v, ErrCode=%v, debug=%q&#34;,
<span id="L6573" class="ln">  6573	</span>		e.LastStreamID, e.ErrCode, e.DebugData)
<span id="L6574" class="ln">  6574	</span>}
<span id="L6575" class="ln">  6575	</span>
<span id="L6576" class="ln">  6576	</span>func http2isEOFOrNetReadError(err error) bool {
<span id="L6577" class="ln">  6577	</span>	if err == io.EOF {
<span id="L6578" class="ln">  6578	</span>		return true
<span id="L6579" class="ln">  6579	</span>	}
<span id="L6580" class="ln">  6580	</span>	ne, ok := err.(*net.OpError)
<span id="L6581" class="ln">  6581	</span>	return ok &amp;&amp; ne.Op == &#34;read&#34;
<span id="L6582" class="ln">  6582	</span>}
<span id="L6583" class="ln">  6583	</span>
<span id="L6584" class="ln">  6584	</span>func (rl *http2clientConnReadLoop) cleanup() {
<span id="L6585" class="ln">  6585	</span>	cc := rl.cc
<span id="L6586" class="ln">  6586	</span>	defer cc.tconn.Close()
<span id="L6587" class="ln">  6587	</span>	defer cc.t.connPool().MarkDead(cc)
<span id="L6588" class="ln">  6588	</span>	defer close(cc.readerDone)
<span id="L6589" class="ln">  6589	</span>
<span id="L6590" class="ln">  6590	</span>	if cc.idleTimer != nil {
<span id="L6591" class="ln">  6591	</span>		cc.idleTimer.Stop()
<span id="L6592" class="ln">  6592	</span>	}
<span id="L6593" class="ln">  6593	</span>
<span id="L6594" class="ln">  6594	</span>	err := cc.readerErr
<span id="L6595" class="ln">  6595	</span>	cc.mu.Lock()
<span id="L6596" class="ln">  6596	</span>	if cc.goAway != nil &amp;&amp; http2isEOFOrNetReadError(err) {
<span id="L6597" class="ln">  6597	</span>		err = http2GoAwayError{
<span id="L6598" class="ln">  6598	</span>			LastStreamID: cc.goAway.LastStreamID,
<span id="L6599" class="ln">  6599	</span>			ErrCode:      cc.goAway.ErrCode,
<span id="L6600" class="ln">  6600	</span>			DebugData:    cc.goAwayDebug,
<span id="L6601" class="ln">  6601	</span>		}
<span id="L6602" class="ln">  6602	</span>	} else if err == io.EOF {
<span id="L6603" class="ln">  6603	</span>		err = io.ErrUnexpectedEOF
<span id="L6604" class="ln">  6604	</span>	}
<span id="L6605" class="ln">  6605	</span>	for _, cs := range rl.activeRes {
<span id="L6606" class="ln">  6606	</span>		cs.bufPipe.CloseWithError(err)
<span id="L6607" class="ln">  6607	</span>	}
<span id="L6608" class="ln">  6608	</span>	for _, cs := range cc.streams {
<span id="L6609" class="ln">  6609	</span>		select {
<span id="L6610" class="ln">  6610	</span>		case cs.resc &lt;- http2resAndError{err: err}:
<span id="L6611" class="ln">  6611	</span>		default:
<span id="L6612" class="ln">  6612	</span>		}
<span id="L6613" class="ln">  6613	</span>		close(cs.done)
<span id="L6614" class="ln">  6614	</span>	}
<span id="L6615" class="ln">  6615	</span>	cc.closed = true
<span id="L6616" class="ln">  6616	</span>	cc.cond.Broadcast()
<span id="L6617" class="ln">  6617	</span>	cc.mu.Unlock()
<span id="L6618" class="ln">  6618	</span>}
<span id="L6619" class="ln">  6619	</span>
<span id="L6620" class="ln">  6620	</span>func (rl *http2clientConnReadLoop) run() error {
<span id="L6621" class="ln">  6621	</span>	cc := rl.cc
<span id="L6622" class="ln">  6622	</span>	rl.closeWhenIdle = cc.t.disableKeepAlives() || cc.singleUse
<span id="L6623" class="ln">  6623	</span>	gotReply := false
<span id="L6624" class="ln">  6624	</span>	gotSettings := false
<span id="L6625" class="ln">  6625	</span>	for {
<span id="L6626" class="ln">  6626	</span>		f, err := cc.fr.ReadFrame()
<span id="L6627" class="ln">  6627	</span>		if err != nil {
<span id="L6628" class="ln">  6628	</span>			cc.vlogf(&#34;http2: Transport readFrame error on conn %p: (%T) %v&#34;, cc, err, err)
<span id="L6629" class="ln">  6629	</span>		}
<span id="L6630" class="ln">  6630	</span>		if se, ok := err.(http2StreamError); ok {
<span id="L6631" class="ln">  6631	</span>			if cs := cc.streamByID(se.StreamID, true); cs != nil {
<span id="L6632" class="ln">  6632	</span>				cs.cc.writeStreamReset(cs.ID, se.Code, err)
<span id="L6633" class="ln">  6633	</span>				if se.Cause == nil {
<span id="L6634" class="ln">  6634	</span>					se.Cause = cc.fr.errDetail
<span id="L6635" class="ln">  6635	</span>				}
<span id="L6636" class="ln">  6636	</span>				rl.endStreamError(cs, se)
<span id="L6637" class="ln">  6637	</span>			}
<span id="L6638" class="ln">  6638	</span>			continue
<span id="L6639" class="ln">  6639	</span>		} else if err != nil {
<span id="L6640" class="ln">  6640	</span>			return err
<span id="L6641" class="ln">  6641	</span>		}
<span id="L6642" class="ln">  6642	</span>		if http2VerboseLogs {
<span id="L6643" class="ln">  6643	</span>			cc.vlogf(&#34;http2: Transport received %s&#34;, http2summarizeFrame(f))
<span id="L6644" class="ln">  6644	</span>		}
<span id="L6645" class="ln">  6645	</span>		if !gotSettings {
<span id="L6646" class="ln">  6646	</span>			if _, ok := f.(*http2SettingsFrame); !ok {
<span id="L6647" class="ln">  6647	</span>				cc.logf(&#34;protocol error: received %T before a SETTINGS frame&#34;, f)
<span id="L6648" class="ln">  6648	</span>				return http2ConnectionError(http2ErrCodeProtocol)
<span id="L6649" class="ln">  6649	</span>			}
<span id="L6650" class="ln">  6650	</span>			gotSettings = true
<span id="L6651" class="ln">  6651	</span>		}
<span id="L6652" class="ln">  6652	</span>		maybeIdle := false
<span id="L6653" class="ln">  6653	</span>
<span id="L6654" class="ln">  6654	</span>		switch f := f.(type) {
<span id="L6655" class="ln">  6655	</span>		case *http2MetaHeadersFrame:
<span id="L6656" class="ln">  6656	</span>			err = rl.processHeaders(f)
<span id="L6657" class="ln">  6657	</span>			maybeIdle = true
<span id="L6658" class="ln">  6658	</span>			gotReply = true
<span id="L6659" class="ln">  6659	</span>		case *http2DataFrame:
<span id="L6660" class="ln">  6660	</span>			err = rl.processData(f)
<span id="L6661" class="ln">  6661	</span>			maybeIdle = true
<span id="L6662" class="ln">  6662	</span>		case *http2GoAwayFrame:
<span id="L6663" class="ln">  6663	</span>			err = rl.processGoAway(f)
<span id="L6664" class="ln">  6664	</span>			maybeIdle = true
<span id="L6665" class="ln">  6665	</span>		case *http2RSTStreamFrame:
<span id="L6666" class="ln">  6666	</span>			err = rl.processResetStream(f)
<span id="L6667" class="ln">  6667	</span>			maybeIdle = true
<span id="L6668" class="ln">  6668	</span>		case *http2SettingsFrame:
<span id="L6669" class="ln">  6669	</span>			err = rl.processSettings(f)
<span id="L6670" class="ln">  6670	</span>		case *http2PushPromiseFrame:
<span id="L6671" class="ln">  6671	</span>			err = rl.processPushPromise(f)
<span id="L6672" class="ln">  6672	</span>		case *http2WindowUpdateFrame:
<span id="L6673" class="ln">  6673	</span>			err = rl.processWindowUpdate(f)
<span id="L6674" class="ln">  6674	</span>		case *http2PingFrame:
<span id="L6675" class="ln">  6675	</span>			err = rl.processPing(f)
<span id="L6676" class="ln">  6676	</span>		default:
<span id="L6677" class="ln">  6677	</span>			cc.logf(&#34;Transport: unhandled response frame type %T&#34;, f)
<span id="L6678" class="ln">  6678	</span>		}
<span id="L6679" class="ln">  6679	</span>		if err != nil {
<span id="L6680" class="ln">  6680	</span>			if http2VerboseLogs {
<span id="L6681" class="ln">  6681	</span>				cc.vlogf(&#34;http2: Transport conn %p received error from processing frame %v: %v&#34;, cc, http2summarizeFrame(f), err)
<span id="L6682" class="ln">  6682	</span>			}
<span id="L6683" class="ln">  6683	</span>			return err
<span id="L6684" class="ln">  6684	</span>		}
<span id="L6685" class="ln">  6685	</span>		if rl.closeWhenIdle &amp;&amp; gotReply &amp;&amp; maybeIdle &amp;&amp; len(rl.activeRes) == 0 {
<span id="L6686" class="ln">  6686	</span>			cc.closeIfIdle()
<span id="L6687" class="ln">  6687	</span>		}
<span id="L6688" class="ln">  6688	</span>	}
<span id="L6689" class="ln">  6689	</span>}
<span id="L6690" class="ln">  6690	</span>
<span id="L6691" class="ln">  6691	</span>func (rl *http2clientConnReadLoop) processHeaders(f *http2MetaHeadersFrame) error {
<span id="L6692" class="ln">  6692	</span>	cc := rl.cc
<span id="L6693" class="ln">  6693	</span>	cs := cc.streamByID(f.StreamID, f.StreamEnded())
<span id="L6694" class="ln">  6694	</span>	if cs == nil {
<span id="L6695" class="ln">  6695	</span>
<span id="L6696" class="ln">  6696	</span>		return nil
<span id="L6697" class="ln">  6697	</span>	}
<span id="L6698" class="ln">  6698	</span>	if !cs.firstByte {
<span id="L6699" class="ln">  6699	</span>		if cs.trace != nil {
<span id="L6700" class="ln">  6700	</span>
<span id="L6701" class="ln">  6701	</span>			http2traceFirstResponseByte(cs.trace)
<span id="L6702" class="ln">  6702	</span>		}
<span id="L6703" class="ln">  6703	</span>		cs.firstByte = true
<span id="L6704" class="ln">  6704	</span>	}
<span id="L6705" class="ln">  6705	</span>	if !cs.pastHeaders {
<span id="L6706" class="ln">  6706	</span>		cs.pastHeaders = true
<span id="L6707" class="ln">  6707	</span>	} else {
<span id="L6708" class="ln">  6708	</span>		return rl.processTrailers(cs, f)
<span id="L6709" class="ln">  6709	</span>	}
<span id="L6710" class="ln">  6710	</span>
<span id="L6711" class="ln">  6711	</span>	res, err := rl.handleResponse(cs, f)
<span id="L6712" class="ln">  6712	</span>	if err != nil {
<span id="L6713" class="ln">  6713	</span>		if _, ok := err.(http2ConnectionError); ok {
<span id="L6714" class="ln">  6714	</span>			return err
<span id="L6715" class="ln">  6715	</span>		}
<span id="L6716" class="ln">  6716	</span>
<span id="L6717" class="ln">  6717	</span>		cs.cc.writeStreamReset(f.StreamID, http2ErrCodeProtocol, err)
<span id="L6718" class="ln">  6718	</span>		cs.resc &lt;- http2resAndError{err: err}
<span id="L6719" class="ln">  6719	</span>		return nil
<span id="L6720" class="ln">  6720	</span>	}
<span id="L6721" class="ln">  6721	</span>	if res == nil {
<span id="L6722" class="ln">  6722	</span>
<span id="L6723" class="ln">  6723	</span>		return nil
<span id="L6724" class="ln">  6724	</span>	}
<span id="L6725" class="ln">  6725	</span>	if res.Body != http2noBody {
<span id="L6726" class="ln">  6726	</span>		rl.activeRes[cs.ID] = cs
<span id="L6727" class="ln">  6727	</span>	}
<span id="L6728" class="ln">  6728	</span>	cs.resTrailer = &amp;res.Trailer
<span id="L6729" class="ln">  6729	</span>	cs.resc &lt;- http2resAndError{res: res}
<span id="L6730" class="ln">  6730	</span>	return nil
<span id="L6731" class="ln">  6731	</span>}
<span id="L6732" class="ln">  6732	</span>
<span id="L6733" class="ln">  6733	</span><span class="comment">// may return error types nil, or ConnectionError. Any other error value</span>
<span id="L6734" class="ln">  6734	</span><span class="comment">// is a StreamError of type ErrCodeProtocol. The returned error in that case</span>
<span id="L6735" class="ln">  6735	</span><span class="comment">// is the detail.</span>
<span id="L6736" class="ln">  6736	</span><span class="comment">//</span>
<span id="L6737" class="ln">  6737	</span><span class="comment">// As a special case, handleResponse may return (nil, nil) to skip the</span>
<span id="L6738" class="ln">  6738	</span><span class="comment">// frame (currently only used for 100 expect continue). This special</span>
<span id="L6739" class="ln">  6739	</span><span class="comment">// case is going away after Issue 13851 is fixed.</span>
<span id="L6740" class="ln">  6740	</span>func (rl *http2clientConnReadLoop) handleResponse(cs *http2clientStream, f *http2MetaHeadersFrame) (*Response, error) {
<span id="L6741" class="ln">  6741	</span>	if f.Truncated {
<span id="L6742" class="ln">  6742	</span>		return nil, http2errResponseHeaderListSize
<span id="L6743" class="ln">  6743	</span>	}
<span id="L6744" class="ln">  6744	</span>
<span id="L6745" class="ln">  6745	</span>	status := f.PseudoValue(&#34;status&#34;)
<span id="L6746" class="ln">  6746	</span>	if status == &#34;&#34; {
<span id="L6747" class="ln">  6747	</span>		return nil, errors.New(&#34;missing status pseudo header&#34;)
<span id="L6748" class="ln">  6748	</span>	}
<span id="L6749" class="ln">  6749	</span>	statusCode, err := strconv.Atoi(status)
<span id="L6750" class="ln">  6750	</span>	if err != nil {
<span id="L6751" class="ln">  6751	</span>		return nil, errors.New(&#34;malformed non-numeric status pseudo header&#34;)
<span id="L6752" class="ln">  6752	</span>	}
<span id="L6753" class="ln">  6753	</span>
<span id="L6754" class="ln">  6754	</span>	if statusCode == 100 {
<span id="L6755" class="ln">  6755	</span>		http2traceGot100Continue(cs.trace)
<span id="L6756" class="ln">  6756	</span>		if cs.on100 != nil {
<span id="L6757" class="ln">  6757	</span>			cs.on100()
<span id="L6758" class="ln">  6758	</span>		}
<span id="L6759" class="ln">  6759	</span>		cs.pastHeaders = false
<span id="L6760" class="ln">  6760	</span>		return nil, nil
<span id="L6761" class="ln">  6761	</span>	}
<span id="L6762" class="ln">  6762	</span>
<span id="L6763" class="ln">  6763	</span>	header := make(Header)
<span id="L6764" class="ln">  6764	</span>	res := &amp;Response{
<span id="L6765" class="ln">  6765	</span>		Proto:      &#34;HTTP/2.0&#34;,
<span id="L6766" class="ln">  6766	</span>		ProtoMajor: 2,
<span id="L6767" class="ln">  6767	</span>		Header:     header,
<span id="L6768" class="ln">  6768	</span>		StatusCode: statusCode,
<span id="L6769" class="ln">  6769	</span>		Status:     status + &#34; &#34; + StatusText(statusCode),
<span id="L6770" class="ln">  6770	</span>	}
<span id="L6771" class="ln">  6771	</span>	for _, hf := range f.RegularFields() {
<span id="L6772" class="ln">  6772	</span>		key := CanonicalHeaderKey(hf.Name)
<span id="L6773" class="ln">  6773	</span>		if key == &#34;Trailer&#34; {
<span id="L6774" class="ln">  6774	</span>			t := res.Trailer
<span id="L6775" class="ln">  6775	</span>			if t == nil {
<span id="L6776" class="ln">  6776	</span>				t = make(Header)
<span id="L6777" class="ln">  6777	</span>				res.Trailer = t
<span id="L6778" class="ln">  6778	</span>			}
<span id="L6779" class="ln">  6779	</span>			http2foreachHeaderElement(hf.Value, func(v string) {
<span id="L6780" class="ln">  6780	</span>				t[CanonicalHeaderKey(v)] = nil
<span id="L6781" class="ln">  6781	</span>			})
<span id="L6782" class="ln">  6782	</span>		} else {
<span id="L6783" class="ln">  6783	</span>			header[key] = append(header[key], hf.Value)
<span id="L6784" class="ln">  6784	</span>		}
<span id="L6785" class="ln">  6785	</span>	}
<span id="L6786" class="ln">  6786	</span>
<span id="L6787" class="ln">  6787	</span>	streamEnded := f.StreamEnded()
<span id="L6788" class="ln">  6788	</span>	isHead := cs.req.Method == &#34;HEAD&#34;
<span id="L6789" class="ln">  6789	</span>	if !streamEnded || isHead {
<span id="L6790" class="ln">  6790	</span>		res.ContentLength = -1
<span id="L6791" class="ln">  6791	</span>		if clens := res.Header[&#34;Content-Length&#34;]; len(clens) == 1 {
<span id="L6792" class="ln">  6792	</span>			if clen64, err := strconv.ParseInt(clens[0], 10, 64); err == nil {
<span id="L6793" class="ln">  6793	</span>				res.ContentLength = clen64
<span id="L6794" class="ln">  6794	</span>			} else {
<span id="L6795" class="ln">  6795	</span>
<span id="L6796" class="ln">  6796	</span>			}
<span id="L6797" class="ln">  6797	</span>		} else if len(clens) &gt; 1 {
<span id="L6798" class="ln">  6798	</span>
<span id="L6799" class="ln">  6799	</span>		}
<span id="L6800" class="ln">  6800	</span>	}
<span id="L6801" class="ln">  6801	</span>
<span id="L6802" class="ln">  6802	</span>	if streamEnded || isHead {
<span id="L6803" class="ln">  6803	</span>		res.Body = http2noBody
<span id="L6804" class="ln">  6804	</span>		return res, nil
<span id="L6805" class="ln">  6805	</span>	}
<span id="L6806" class="ln">  6806	</span>
<span id="L6807" class="ln">  6807	</span>	buf := new(bytes.Buffer)
<span id="L6808" class="ln">  6808	</span>	cs.bufPipe = http2pipe{b: buf}
<span id="L6809" class="ln">  6809	</span>	cs.bytesRemain = res.ContentLength
<span id="L6810" class="ln">  6810	</span>	res.Body = http2transportResponseBody{cs}
<span id="L6811" class="ln">  6811	</span>	go cs.awaitRequestCancel(cs.req)
<span id="L6812" class="ln">  6812	</span>
<span id="L6813" class="ln">  6813	</span>	if cs.requestedGzip &amp;&amp; res.Header.Get(&#34;Content-Encoding&#34;) == &#34;gzip&#34; {
<span id="L6814" class="ln">  6814	</span>		res.Header.Del(&#34;Content-Encoding&#34;)
<span id="L6815" class="ln">  6815	</span>		res.Header.Del(&#34;Content-Length&#34;)
<span id="L6816" class="ln">  6816	</span>		res.ContentLength = -1
<span id="L6817" class="ln">  6817	</span>		res.Body = &amp;http2gzipReader{body: res.Body}
<span id="L6818" class="ln">  6818	</span>		http2setResponseUncompressed(res)
<span id="L6819" class="ln">  6819	</span>	}
<span id="L6820" class="ln">  6820	</span>	return res, nil
<span id="L6821" class="ln">  6821	</span>}
<span id="L6822" class="ln">  6822	</span>
<span id="L6823" class="ln">  6823	</span>func (rl *http2clientConnReadLoop) processTrailers(cs *http2clientStream, f *http2MetaHeadersFrame) error {
<span id="L6824" class="ln">  6824	</span>	if cs.pastTrailers {
<span id="L6825" class="ln">  6825	</span>
<span id="L6826" class="ln">  6826	</span>		return http2ConnectionError(http2ErrCodeProtocol)
<span id="L6827" class="ln">  6827	</span>	}
<span id="L6828" class="ln">  6828	</span>	cs.pastTrailers = true
<span id="L6829" class="ln">  6829	</span>	if !f.StreamEnded() {
<span id="L6830" class="ln">  6830	</span>
<span id="L6831" class="ln">  6831	</span>		return http2ConnectionError(http2ErrCodeProtocol)
<span id="L6832" class="ln">  6832	</span>	}
<span id="L6833" class="ln">  6833	</span>	if len(f.PseudoFields()) &gt; 0 {
<span id="L6834" class="ln">  6834	</span>
<span id="L6835" class="ln">  6835	</span>		return http2ConnectionError(http2ErrCodeProtocol)
<span id="L6836" class="ln">  6836	</span>	}
<span id="L6837" class="ln">  6837	</span>
<span id="L6838" class="ln">  6838	</span>	trailer := make(Header)
<span id="L6839" class="ln">  6839	</span>	for _, hf := range f.RegularFields() {
<span id="L6840" class="ln">  6840	</span>		key := CanonicalHeaderKey(hf.Name)
<span id="L6841" class="ln">  6841	</span>		trailer[key] = append(trailer[key], hf.Value)
<span id="L6842" class="ln">  6842	</span>	}
<span id="L6843" class="ln">  6843	</span>	cs.trailer = trailer
<span id="L6844" class="ln">  6844	</span>
<span id="L6845" class="ln">  6845	</span>	rl.endStream(cs)
<span id="L6846" class="ln">  6846	</span>	return nil
<span id="L6847" class="ln">  6847	</span>}
<span id="L6848" class="ln">  6848	</span>
<span id="L6849" class="ln">  6849	</span><span class="comment">// transportResponseBody is the concrete type of Transport.RoundTrip&#39;s</span>
<span id="L6850" class="ln">  6850	</span><span class="comment">// Response.Body. It is an io.ReadCloser. On Read, it reads from cs.body.</span>
<span id="L6851" class="ln">  6851	</span><span class="comment">// On Close it sends RST_STREAM if EOF wasn&#39;t already seen.</span>
<span id="L6852" class="ln">  6852	</span>type http2transportResponseBody struct {
<span id="L6853" class="ln">  6853	</span>	cs *http2clientStream
<span id="L6854" class="ln">  6854	</span>}
<span id="L6855" class="ln">  6855	</span>
<span id="L6856" class="ln">  6856	</span>func (b http2transportResponseBody) Read(p []byte) (n int, err error) {
<span id="L6857" class="ln">  6857	</span>	cs := b.cs
<span id="L6858" class="ln">  6858	</span>	cc := cs.cc
<span id="L6859" class="ln">  6859	</span>
<span id="L6860" class="ln">  6860	</span>	if cs.readErr != nil {
<span id="L6861" class="ln">  6861	</span>		return 0, cs.readErr
<span id="L6862" class="ln">  6862	</span>	}
<span id="L6863" class="ln">  6863	</span>	n, err = b.cs.bufPipe.Read(p)
<span id="L6864" class="ln">  6864	</span>	if cs.bytesRemain != -1 {
<span id="L6865" class="ln">  6865	</span>		if int64(n) &gt; cs.bytesRemain {
<span id="L6866" class="ln">  6866	</span>			n = int(cs.bytesRemain)
<span id="L6867" class="ln">  6867	</span>			if err == nil {
<span id="L6868" class="ln">  6868	</span>				err = errors.New(&#34;net/http: server replied with more than declared Content-Length; truncated&#34;)
<span id="L6869" class="ln">  6869	</span>				cc.writeStreamReset(cs.ID, http2ErrCodeProtocol, err)
<span id="L6870" class="ln">  6870	</span>			}
<span id="L6871" class="ln">  6871	</span>			cs.readErr = err
<span id="L6872" class="ln">  6872	</span>			return int(cs.bytesRemain), err
<span id="L6873" class="ln">  6873	</span>		}
<span id="L6874" class="ln">  6874	</span>		cs.bytesRemain -= int64(n)
<span id="L6875" class="ln">  6875	</span>		if err == io.EOF &amp;&amp; cs.bytesRemain &gt; 0 {
<span id="L6876" class="ln">  6876	</span>			err = io.ErrUnexpectedEOF
<span id="L6877" class="ln">  6877	</span>			cs.readErr = err
<span id="L6878" class="ln">  6878	</span>			return n, err
<span id="L6879" class="ln">  6879	</span>		}
<span id="L6880" class="ln">  6880	</span>	}
<span id="L6881" class="ln">  6881	</span>	if n == 0 {
<span id="L6882" class="ln">  6882	</span>
<span id="L6883" class="ln">  6883	</span>		return
<span id="L6884" class="ln">  6884	</span>	}
<span id="L6885" class="ln">  6885	</span>
<span id="L6886" class="ln">  6886	</span>	cc.mu.Lock()
<span id="L6887" class="ln">  6887	</span>	defer cc.mu.Unlock()
<span id="L6888" class="ln">  6888	</span>
<span id="L6889" class="ln">  6889	</span>	var connAdd, streamAdd int32
<span id="L6890" class="ln">  6890	</span>
<span id="L6891" class="ln">  6891	</span>	if v := cc.inflow.available(); v &lt; http2transportDefaultConnFlow/2 {
<span id="L6892" class="ln">  6892	</span>		connAdd = http2transportDefaultConnFlow - v
<span id="L6893" class="ln">  6893	</span>		cc.inflow.add(connAdd)
<span id="L6894" class="ln">  6894	</span>	}
<span id="L6895" class="ln">  6895	</span>	if err == nil {
<span id="L6896" class="ln">  6896	</span>
<span id="L6897" class="ln">  6897	</span>		v := int(cs.inflow.available()) + cs.bufPipe.Len()
<span id="L6898" class="ln">  6898	</span>		if v &lt; http2transportDefaultStreamFlow-http2transportDefaultStreamMinRefresh {
<span id="L6899" class="ln">  6899	</span>			streamAdd = int32(http2transportDefaultStreamFlow - v)
<span id="L6900" class="ln">  6900	</span>			cs.inflow.add(streamAdd)
<span id="L6901" class="ln">  6901	</span>		}
<span id="L6902" class="ln">  6902	</span>	}
<span id="L6903" class="ln">  6903	</span>	if connAdd != 0 || streamAdd != 0 {
<span id="L6904" class="ln">  6904	</span>		cc.wmu.Lock()
<span id="L6905" class="ln">  6905	</span>		defer cc.wmu.Unlock()
<span id="L6906" class="ln">  6906	</span>		if connAdd != 0 {
<span id="L6907" class="ln">  6907	</span>			cc.fr.WriteWindowUpdate(0, http2mustUint31(connAdd))
<span id="L6908" class="ln">  6908	</span>		}
<span id="L6909" class="ln">  6909	</span>		if streamAdd != 0 {
<span id="L6910" class="ln">  6910	</span>			cc.fr.WriteWindowUpdate(cs.ID, http2mustUint31(streamAdd))
<span id="L6911" class="ln">  6911	</span>		}
<span id="L6912" class="ln">  6912	</span>		cc.bw.Flush()
<span id="L6913" class="ln">  6913	</span>	}
<span id="L6914" class="ln">  6914	</span>	return
<span id="L6915" class="ln">  6915	</span>}
<span id="L6916" class="ln">  6916	</span>
<span id="L6917" class="ln">  6917	</span>var http2errClosedResponseBody = errors.New(&#34;http2: response body closed&#34;)
<span id="L6918" class="ln">  6918	</span>
<span id="L6919" class="ln">  6919	</span>func (b http2transportResponseBody) Close() error {
<span id="L6920" class="ln">  6920	</span>	cs := b.cs
<span id="L6921" class="ln">  6921	</span>	cc := cs.cc
<span id="L6922" class="ln">  6922	</span>
<span id="L6923" class="ln">  6923	</span>	serverSentStreamEnd := cs.bufPipe.Err() == io.EOF
<span id="L6924" class="ln">  6924	</span>	unread := cs.bufPipe.Len()
<span id="L6925" class="ln">  6925	</span>
<span id="L6926" class="ln">  6926	</span>	if unread &gt; 0 || !serverSentStreamEnd {
<span id="L6927" class="ln">  6927	</span>		cc.mu.Lock()
<span id="L6928" class="ln">  6928	</span>		cc.wmu.Lock()
<span id="L6929" class="ln">  6929	</span>		if !serverSentStreamEnd {
<span id="L6930" class="ln">  6930	</span>			cc.fr.WriteRSTStream(cs.ID, http2ErrCodeCancel)
<span id="L6931" class="ln">  6931	</span>		}
<span id="L6932" class="ln">  6932	</span>
<span id="L6933" class="ln">  6933	</span>		if unread &gt; 0 {
<span id="L6934" class="ln">  6934	</span>			cc.inflow.add(int32(unread))
<span id="L6935" class="ln">  6935	</span>			cc.fr.WriteWindowUpdate(0, uint32(unread))
<span id="L6936" class="ln">  6936	</span>		}
<span id="L6937" class="ln">  6937	</span>		cc.bw.Flush()
<span id="L6938" class="ln">  6938	</span>		cc.wmu.Unlock()
<span id="L6939" class="ln">  6939	</span>		cc.mu.Unlock()
<span id="L6940" class="ln">  6940	</span>	}
<span id="L6941" class="ln">  6941	</span>
<span id="L6942" class="ln">  6942	</span>	cs.bufPipe.BreakWithError(http2errClosedResponseBody)
<span id="L6943" class="ln">  6943	</span>	return nil
<span id="L6944" class="ln">  6944	</span>}
<span id="L6945" class="ln">  6945	</span>
<span id="L6946" class="ln">  6946	</span>func (rl *http2clientConnReadLoop) processData(f *http2DataFrame) error {
<span id="L6947" class="ln">  6947	</span>	cc := rl.cc
<span id="L6948" class="ln">  6948	</span>	cs := cc.streamByID(f.StreamID, f.StreamEnded())
<span id="L6949" class="ln">  6949	</span>	data := f.Data()
<span id="L6950" class="ln">  6950	</span>	if cs == nil {
<span id="L6951" class="ln">  6951	</span>		cc.mu.Lock()
<span id="L6952" class="ln">  6952	</span>		neverSent := cc.nextStreamID
<span id="L6953" class="ln">  6953	</span>		cc.mu.Unlock()
<span id="L6954" class="ln">  6954	</span>		if f.StreamID &gt;= neverSent {
<span id="L6955" class="ln">  6955	</span>
<span id="L6956" class="ln">  6956	</span>			cc.logf(&#34;http2: Transport received unsolicited DATA frame; closing connection&#34;)
<span id="L6957" class="ln">  6957	</span>			return http2ConnectionError(http2ErrCodeProtocol)
<span id="L6958" class="ln">  6958	</span>		}
<span id="L6959" class="ln">  6959	</span>
<span id="L6960" class="ln">  6960	</span>		if f.Length &gt; 0 {
<span id="L6961" class="ln">  6961	</span>			cc.mu.Lock()
<span id="L6962" class="ln">  6962	</span>			cc.inflow.add(int32(f.Length))
<span id="L6963" class="ln">  6963	</span>			cc.mu.Unlock()
<span id="L6964" class="ln">  6964	</span>
<span id="L6965" class="ln">  6965	</span>			cc.wmu.Lock()
<span id="L6966" class="ln">  6966	</span>			cc.fr.WriteWindowUpdate(0, uint32(f.Length))
<span id="L6967" class="ln">  6967	</span>			cc.bw.Flush()
<span id="L6968" class="ln">  6968	</span>			cc.wmu.Unlock()
<span id="L6969" class="ln">  6969	</span>		}
<span id="L6970" class="ln">  6970	</span>		return nil
<span id="L6971" class="ln">  6971	</span>	}
<span id="L6972" class="ln">  6972	</span>	if f.Length &gt; 0 {
<span id="L6973" class="ln">  6973	</span>		if len(data) &gt; 0 &amp;&amp; cs.bufPipe.b == nil {
<span id="L6974" class="ln">  6974	</span>
<span id="L6975" class="ln">  6975	</span>			cc.logf(&#34;http2: Transport received DATA frame for closed stream; closing connection&#34;)
<span id="L6976" class="ln">  6976	</span>			return http2ConnectionError(http2ErrCodeProtocol)
<span id="L6977" class="ln">  6977	</span>		}
<span id="L6978" class="ln">  6978	</span>
<span id="L6979" class="ln">  6979	</span>		cc.mu.Lock()
<span id="L6980" class="ln">  6980	</span>		if cs.inflow.available() &gt;= int32(f.Length) {
<span id="L6981" class="ln">  6981	</span>			cs.inflow.take(int32(f.Length))
<span id="L6982" class="ln">  6982	</span>		} else {
<span id="L6983" class="ln">  6983	</span>			cc.mu.Unlock()
<span id="L6984" class="ln">  6984	</span>			return http2ConnectionError(http2ErrCodeFlowControl)
<span id="L6985" class="ln">  6985	</span>		}
<span id="L6986" class="ln">  6986	</span>
<span id="L6987" class="ln">  6987	</span>		if pad := int32(f.Length) - int32(len(data)); pad &gt; 0 {
<span id="L6988" class="ln">  6988	</span>			cs.inflow.add(pad)
<span id="L6989" class="ln">  6989	</span>			cc.inflow.add(pad)
<span id="L6990" class="ln">  6990	</span>			cc.wmu.Lock()
<span id="L6991" class="ln">  6991	</span>			cc.fr.WriteWindowUpdate(0, uint32(pad))
<span id="L6992" class="ln">  6992	</span>			cc.fr.WriteWindowUpdate(cs.ID, uint32(pad))
<span id="L6993" class="ln">  6993	</span>			cc.bw.Flush()
<span id="L6994" class="ln">  6994	</span>			cc.wmu.Unlock()
<span id="L6995" class="ln">  6995	</span>		}
<span id="L6996" class="ln">  6996	</span>		didReset := cs.didReset
<span id="L6997" class="ln">  6997	</span>		cc.mu.Unlock()
<span id="L6998" class="ln">  6998	</span>
<span id="L6999" class="ln">  6999	</span>		if len(data) &gt; 0 &amp;&amp; !didReset {
<span id="L7000" class="ln">  7000	</span>			if _, err := cs.bufPipe.Write(data); err != nil {
<span id="L7001" class="ln">  7001	</span>				rl.endStreamError(cs, err)
<span id="L7002" class="ln">  7002	</span>				return err
<span id="L7003" class="ln">  7003	</span>			}
<span id="L7004" class="ln">  7004	</span>		}
<span id="L7005" class="ln">  7005	</span>	}
<span id="L7006" class="ln">  7006	</span>
<span id="L7007" class="ln">  7007	</span>	if f.StreamEnded() {
<span id="L7008" class="ln">  7008	</span>		rl.endStream(cs)
<span id="L7009" class="ln">  7009	</span>	}
<span id="L7010" class="ln">  7010	</span>	return nil
<span id="L7011" class="ln">  7011	</span>}
<span id="L7012" class="ln">  7012	</span>
<span id="L7013" class="ln">  7013	</span>var http2errInvalidTrailers = errors.New(&#34;http2: invalid trailers&#34;)
<span id="L7014" class="ln">  7014	</span>
<span id="L7015" class="ln">  7015	</span>func (rl *http2clientConnReadLoop) endStream(cs *http2clientStream) {
<span id="L7016" class="ln">  7016	</span>
<span id="L7017" class="ln">  7017	</span>	rl.endStreamError(cs, nil)
<span id="L7018" class="ln">  7018	</span>}
<span id="L7019" class="ln">  7019	</span>
<span id="L7020" class="ln">  7020	</span>func (rl *http2clientConnReadLoop) endStreamError(cs *http2clientStream, err error) {
<span id="L7021" class="ln">  7021	</span>	var code func()
<span id="L7022" class="ln">  7022	</span>	if err == nil {
<span id="L7023" class="ln">  7023	</span>		err = io.EOF
<span id="L7024" class="ln">  7024	</span>		code = cs.copyTrailers
<span id="L7025" class="ln">  7025	</span>	}
<span id="L7026" class="ln">  7026	</span>	cs.bufPipe.closeWithErrorAndCode(err, code)
<span id="L7027" class="ln">  7027	</span>	delete(rl.activeRes, cs.ID)
<span id="L7028" class="ln">  7028	</span>	if http2isConnectionCloseRequest(cs.req) {
<span id="L7029" class="ln">  7029	</span>		rl.closeWhenIdle = true
<span id="L7030" class="ln">  7030	</span>	}
<span id="L7031" class="ln">  7031	</span>
<span id="L7032" class="ln">  7032	</span>	select {
<span id="L7033" class="ln">  7033	</span>	case cs.resc &lt;- http2resAndError{err: err}:
<span id="L7034" class="ln">  7034	</span>	default:
<span id="L7035" class="ln">  7035	</span>	}
<span id="L7036" class="ln">  7036	</span>}
<span id="L7037" class="ln">  7037	</span>
<span id="L7038" class="ln">  7038	</span>func (cs *http2clientStream) copyTrailers() {
<span id="L7039" class="ln">  7039	</span>	for k, vv := range cs.trailer {
<span id="L7040" class="ln">  7040	</span>		t := cs.resTrailer
<span id="L7041" class="ln">  7041	</span>		if *t == nil {
<span id="L7042" class="ln">  7042	</span>			*t = make(Header)
<span id="L7043" class="ln">  7043	</span>		}
<span id="L7044" class="ln">  7044	</span>		(*t)[k] = vv
<span id="L7045" class="ln">  7045	</span>	}
<span id="L7046" class="ln">  7046	</span>}
<span id="L7047" class="ln">  7047	</span>
<span id="L7048" class="ln">  7048	</span>func (rl *http2clientConnReadLoop) processGoAway(f *http2GoAwayFrame) error {
<span id="L7049" class="ln">  7049	</span>	cc := rl.cc
<span id="L7050" class="ln">  7050	</span>	cc.t.connPool().MarkDead(cc)
<span id="L7051" class="ln">  7051	</span>	if f.ErrCode != 0 {
<span id="L7052" class="ln">  7052	</span>
<span id="L7053" class="ln">  7053	</span>		cc.vlogf(&#34;transport got GOAWAY with error code = %v&#34;, f.ErrCode)
<span id="L7054" class="ln">  7054	</span>	}
<span id="L7055" class="ln">  7055	</span>	cc.setGoAway(f)
<span id="L7056" class="ln">  7056	</span>	return nil
<span id="L7057" class="ln">  7057	</span>}
<span id="L7058" class="ln">  7058	</span>
<span id="L7059" class="ln">  7059	</span>func (rl *http2clientConnReadLoop) processSettings(f *http2SettingsFrame) error {
<span id="L7060" class="ln">  7060	</span>	cc := rl.cc
<span id="L7061" class="ln">  7061	</span>	cc.mu.Lock()
<span id="L7062" class="ln">  7062	</span>	defer cc.mu.Unlock()
<span id="L7063" class="ln">  7063	</span>
<span id="L7064" class="ln">  7064	</span>	if f.IsAck() {
<span id="L7065" class="ln">  7065	</span>		if cc.wantSettingsAck {
<span id="L7066" class="ln">  7066	</span>			cc.wantSettingsAck = false
<span id="L7067" class="ln">  7067	</span>			return nil
<span id="L7068" class="ln">  7068	</span>		}
<span id="L7069" class="ln">  7069	</span>		return http2ConnectionError(http2ErrCodeProtocol)
<span id="L7070" class="ln">  7070	</span>	}
<span id="L7071" class="ln">  7071	</span>
<span id="L7072" class="ln">  7072	</span>	err := f.ForeachSetting(func(s http2Setting) error {
<span id="L7073" class="ln">  7073	</span>		switch s.ID {
<span id="L7074" class="ln">  7074	</span>		case http2SettingMaxFrameSize:
<span id="L7075" class="ln">  7075	</span>			cc.maxFrameSize = s.Val
<span id="L7076" class="ln">  7076	</span>		case http2SettingMaxConcurrentStreams:
<span id="L7077" class="ln">  7077	</span>			cc.maxConcurrentStreams = s.Val
<span id="L7078" class="ln">  7078	</span>		case http2SettingInitialWindowSize:
<span id="L7079" class="ln">  7079	</span>
<span id="L7080" class="ln">  7080	</span>			if s.Val &gt; math.MaxInt32 {
<span id="L7081" class="ln">  7081	</span>				return http2ConnectionError(http2ErrCodeFlowControl)
<span id="L7082" class="ln">  7082	</span>			}
<span id="L7083" class="ln">  7083	</span>
<span id="L7084" class="ln">  7084	</span>			delta := int32(s.Val) - int32(cc.initialWindowSize)
<span id="L7085" class="ln">  7085	</span>			for _, cs := range cc.streams {
<span id="L7086" class="ln">  7086	</span>				cs.flow.add(delta)
<span id="L7087" class="ln">  7087	</span>			}
<span id="L7088" class="ln">  7088	</span>			cc.cond.Broadcast()
<span id="L7089" class="ln">  7089	</span>
<span id="L7090" class="ln">  7090	</span>			cc.initialWindowSize = s.Val
<span id="L7091" class="ln">  7091	</span>		default:
<span id="L7092" class="ln">  7092	</span>
<span id="L7093" class="ln">  7093	</span>			cc.vlogf(&#34;Unhandled Setting: %v&#34;, s)
<span id="L7094" class="ln">  7094	</span>		}
<span id="L7095" class="ln">  7095	</span>		return nil
<span id="L7096" class="ln">  7096	</span>	})
<span id="L7097" class="ln">  7097	</span>	if err != nil {
<span id="L7098" class="ln">  7098	</span>		return err
<span id="L7099" class="ln">  7099	</span>	}
<span id="L7100" class="ln">  7100	</span>
<span id="L7101" class="ln">  7101	</span>	cc.wmu.Lock()
<span id="L7102" class="ln">  7102	</span>	defer cc.wmu.Unlock()
<span id="L7103" class="ln">  7103	</span>
<span id="L7104" class="ln">  7104	</span>	cc.fr.WriteSettingsAck()
<span id="L7105" class="ln">  7105	</span>	cc.bw.Flush()
<span id="L7106" class="ln">  7106	</span>	return cc.werr
<span id="L7107" class="ln">  7107	</span>}
<span id="L7108" class="ln">  7108	</span>
<span id="L7109" class="ln">  7109	</span>func (rl *http2clientConnReadLoop) processWindowUpdate(f *http2WindowUpdateFrame) error {
<span id="L7110" class="ln">  7110	</span>	cc := rl.cc
<span id="L7111" class="ln">  7111	</span>	cs := cc.streamByID(f.StreamID, false)
<span id="L7112" class="ln">  7112	</span>	if f.StreamID != 0 &amp;&amp; cs == nil {
<span id="L7113" class="ln">  7113	</span>		return nil
<span id="L7114" class="ln">  7114	</span>	}
<span id="L7115" class="ln">  7115	</span>
<span id="L7116" class="ln">  7116	</span>	cc.mu.Lock()
<span id="L7117" class="ln">  7117	</span>	defer cc.mu.Unlock()
<span id="L7118" class="ln">  7118	</span>
<span id="L7119" class="ln">  7119	</span>	fl := &amp;cc.flow
<span id="L7120" class="ln">  7120	</span>	if cs != nil {
<span id="L7121" class="ln">  7121	</span>		fl = &amp;cs.flow
<span id="L7122" class="ln">  7122	</span>	}
<span id="L7123" class="ln">  7123	</span>	if !fl.add(int32(f.Increment)) {
<span id="L7124" class="ln">  7124	</span>		return http2ConnectionError(http2ErrCodeFlowControl)
<span id="L7125" class="ln">  7125	</span>	}
<span id="L7126" class="ln">  7126	</span>	cc.cond.Broadcast()
<span id="L7127" class="ln">  7127	</span>	return nil
<span id="L7128" class="ln">  7128	</span>}
<span id="L7129" class="ln">  7129	</span>
<span id="L7130" class="ln">  7130	</span>func (rl *http2clientConnReadLoop) processResetStream(f *http2RSTStreamFrame) error {
<span id="L7131" class="ln">  7131	</span>	cs := rl.cc.streamByID(f.StreamID, true)
<span id="L7132" class="ln">  7132	</span>	if cs == nil {
<span id="L7133" class="ln">  7133	</span>
<span id="L7134" class="ln">  7134	</span>		return nil
<span id="L7135" class="ln">  7135	</span>	}
<span id="L7136" class="ln">  7136	</span>	select {
<span id="L7137" class="ln">  7137	</span>	case &lt;-cs.peerReset:
<span id="L7138" class="ln">  7138	</span>
<span id="L7139" class="ln">  7139	</span>	default:
<span id="L7140" class="ln">  7140	</span>		err := http2streamError(cs.ID, f.ErrCode)
<span id="L7141" class="ln">  7141	</span>		cs.resetErr = err
<span id="L7142" class="ln">  7142	</span>		close(cs.peerReset)
<span id="L7143" class="ln">  7143	</span>		cs.bufPipe.CloseWithError(err)
<span id="L7144" class="ln">  7144	</span>		cs.cc.cond.Broadcast()
<span id="L7145" class="ln">  7145	</span>	}
<span id="L7146" class="ln">  7146	</span>	delete(rl.activeRes, cs.ID)
<span id="L7147" class="ln">  7147	</span>	return nil
<span id="L7148" class="ln">  7148	</span>}
<span id="L7149" class="ln">  7149	</span>
<span id="L7150" class="ln">  7150	</span><span class="comment">// Ping sends a PING frame to the server and waits for the ack.</span>
<span id="L7151" class="ln">  7151	</span><span class="comment">// Public implementation is in go17.go and not_go17.go</span>
<span id="L7152" class="ln">  7152	</span>func (cc *http2ClientConn) ping(ctx http2contextContext) error {
<span id="L7153" class="ln">  7153	</span>	c := make(chan struct{})
<span id="L7154" class="ln">  7154	</span>	<span class="comment">// Generate a random payload</span>
<span id="L7155" class="ln">  7155	</span>	var p [8]byte
<span id="L7156" class="ln">  7156	</span>	for {
<span id="L7157" class="ln">  7157	</span>		if _, err := rand.Read(p[:]); err != nil {
<span id="L7158" class="ln">  7158	</span>			return err
<span id="L7159" class="ln">  7159	</span>		}
<span id="L7160" class="ln">  7160	</span>		cc.mu.Lock()
<span id="L7161" class="ln">  7161	</span>
<span id="L7162" class="ln">  7162	</span>		if _, found := cc.pings[p]; !found {
<span id="L7163" class="ln">  7163	</span>			cc.pings[p] = c
<span id="L7164" class="ln">  7164	</span>			cc.mu.Unlock()
<span id="L7165" class="ln">  7165	</span>			break
<span id="L7166" class="ln">  7166	</span>		}
<span id="L7167" class="ln">  7167	</span>		cc.mu.Unlock()
<span id="L7168" class="ln">  7168	</span>	}
<span id="L7169" class="ln">  7169	</span>	cc.wmu.Lock()
<span id="L7170" class="ln">  7170	</span>	if err := cc.fr.WritePing(false, p); err != nil {
<span id="L7171" class="ln">  7171	</span>		cc.wmu.Unlock()
<span id="L7172" class="ln">  7172	</span>		return err
<span id="L7173" class="ln">  7173	</span>	}
<span id="L7174" class="ln">  7174	</span>	if err := cc.bw.Flush(); err != nil {
<span id="L7175" class="ln">  7175	</span>		cc.wmu.Unlock()
<span id="L7176" class="ln">  7176	</span>		return err
<span id="L7177" class="ln">  7177	</span>	}
<span id="L7178" class="ln">  7178	</span>	cc.wmu.Unlock()
<span id="L7179" class="ln">  7179	</span>	select {
<span id="L7180" class="ln">  7180	</span>	case &lt;-c:
<span id="L7181" class="ln">  7181	</span>		return nil
<span id="L7182" class="ln">  7182	</span>	case &lt;-ctx.Done():
<span id="L7183" class="ln">  7183	</span>		return ctx.Err()
<span id="L7184" class="ln">  7184	</span>	case &lt;-cc.readerDone:
<span id="L7185" class="ln">  7185	</span>
<span id="L7186" class="ln">  7186	</span>		return cc.readerErr
<span id="L7187" class="ln">  7187	</span>	}
<span id="L7188" class="ln">  7188	</span>}
<span id="L7189" class="ln">  7189	</span>
<span id="L7190" class="ln">  7190	</span>func (rl *http2clientConnReadLoop) processPing(f *http2PingFrame) error {
<span id="L7191" class="ln">  7191	</span>	if f.IsAck() {
<span id="L7192" class="ln">  7192	</span>		cc := rl.cc
<span id="L7193" class="ln">  7193	</span>		cc.mu.Lock()
<span id="L7194" class="ln">  7194	</span>		defer cc.mu.Unlock()
<span id="L7195" class="ln">  7195	</span>
<span id="L7196" class="ln">  7196	</span>		if c, ok := cc.pings[f.Data]; ok {
<span id="L7197" class="ln">  7197	</span>			close(c)
<span id="L7198" class="ln">  7198	</span>			delete(cc.pings, f.Data)
<span id="L7199" class="ln">  7199	</span>		}
<span id="L7200" class="ln">  7200	</span>		return nil
<span id="L7201" class="ln">  7201	</span>	}
<span id="L7202" class="ln">  7202	</span>	cc := rl.cc
<span id="L7203" class="ln">  7203	</span>	cc.wmu.Lock()
<span id="L7204" class="ln">  7204	</span>	defer cc.wmu.Unlock()
<span id="L7205" class="ln">  7205	</span>	if err := cc.fr.WritePing(true, f.Data); err != nil {
<span id="L7206" class="ln">  7206	</span>		return err
<span id="L7207" class="ln">  7207	</span>	}
<span id="L7208" class="ln">  7208	</span>	return cc.bw.Flush()
<span id="L7209" class="ln">  7209	</span>}
<span id="L7210" class="ln">  7210	</span>
<span id="L7211" class="ln">  7211	</span>func (rl *http2clientConnReadLoop) processPushPromise(f *http2PushPromiseFrame) error {
<span id="L7212" class="ln">  7212	</span>
<span id="L7213" class="ln">  7213	</span>	return http2ConnectionError(http2ErrCodeProtocol)
<span id="L7214" class="ln">  7214	</span>}
<span id="L7215" class="ln">  7215	</span>
<span id="L7216" class="ln">  7216	</span>func (cc *http2ClientConn) writeStreamReset(streamID uint32, code http2ErrCode, err error) {
<span id="L7217" class="ln">  7217	</span>
<span id="L7218" class="ln">  7218	</span>	cc.wmu.Lock()
<span id="L7219" class="ln">  7219	</span>	cc.fr.WriteRSTStream(streamID, code)
<span id="L7220" class="ln">  7220	</span>	cc.bw.Flush()
<span id="L7221" class="ln">  7221	</span>	cc.wmu.Unlock()
<span id="L7222" class="ln">  7222	</span>}
<span id="L7223" class="ln">  7223	</span>
<span id="L7224" class="ln">  7224	</span>var (
<span id="L7225" class="ln">  7225	</span>	http2errResponseHeaderListSize = errors.New(&#34;http2: response header list larger than advertised limit&#34;)
<span id="L7226" class="ln">  7226	</span>	http2errPseudoTrailers         = errors.New(&#34;http2: invalid pseudo header in trailers&#34;)
<span id="L7227" class="ln">  7227	</span>)
<span id="L7228" class="ln">  7228	</span>
<span id="L7229" class="ln">  7229	</span>func (cc *http2ClientConn) logf(format string, args ...interface{}) {
<span id="L7230" class="ln">  7230	</span>	cc.t.logf(format, args...)
<span id="L7231" class="ln">  7231	</span>}
<span id="L7232" class="ln">  7232	</span>
<span id="L7233" class="ln">  7233	</span>func (cc *http2ClientConn) vlogf(format string, args ...interface{}) {
<span id="L7234" class="ln">  7234	</span>	cc.t.vlogf(format, args...)
<span id="L7235" class="ln">  7235	</span>}
<span id="L7236" class="ln">  7236	</span>
<span id="L7237" class="ln">  7237	</span>func (t *http2Transport) vlogf(format string, args ...interface{}) {
<span id="L7238" class="ln">  7238	</span>	if http2VerboseLogs {
<span id="L7239" class="ln">  7239	</span>		t.logf(format, args...)
<span id="L7240" class="ln">  7240	</span>	}
<span id="L7241" class="ln">  7241	</span>}
<span id="L7242" class="ln">  7242	</span>
<span id="L7243" class="ln">  7243	</span>func (t *http2Transport) logf(format string, args ...interface{}) {
<span id="L7244" class="ln">  7244	</span>	log.Printf(format, args...)
<span id="L7245" class="ln">  7245	</span>}
<span id="L7246" class="ln">  7246	</span>
<span id="L7247" class="ln">  7247	</span>var http2noBody io.ReadCloser = ioutil.NopCloser(bytes.NewReader(nil))
<span id="L7248" class="ln">  7248	</span>
<span id="L7249" class="ln">  7249	</span>func http2strSliceContains(ss []string, s string) bool {
<span id="L7250" class="ln">  7250	</span>	for _, v := range ss {
<span id="L7251" class="ln">  7251	</span>		if v == s {
<span id="L7252" class="ln">  7252	</span>			return true
<span id="L7253" class="ln">  7253	</span>		}
<span id="L7254" class="ln">  7254	</span>	}
<span id="L7255" class="ln">  7255	</span>	return false
<span id="L7256" class="ln">  7256	</span>}
<span id="L7257" class="ln">  7257	</span>
<span id="L7258" class="ln">  7258	</span>type http2erringRoundTripper struct{ err error }
<span id="L7259" class="ln">  7259	</span>
<span id="L7260" class="ln">  7260	</span>func (rt http2erringRoundTripper) RoundTrip(*Request) (*Response, error) { return nil, rt.err }
<span id="L7261" class="ln">  7261	</span>
<span id="L7262" class="ln">  7262	</span><span class="comment">// gzipReader wraps a response body so it can lazily</span>
<span id="L7263" class="ln">  7263	</span><span class="comment">// call gzip.NewReader on the first call to Read</span>
<span id="L7264" class="ln">  7264	</span>type http2gzipReader struct {
<span id="L7265" class="ln">  7265	</span>	body io.ReadCloser <span class="comment">// underlying Response.Body</span>
<span id="L7266" class="ln">  7266	</span>	zr   *gzip.Reader  <span class="comment">// lazily-initialized gzip reader</span>
<span id="L7267" class="ln">  7267	</span>	zerr error         <span class="comment">// sticky error</span>
<span id="L7268" class="ln">  7268	</span>}
<span id="L7269" class="ln">  7269	</span>
<span id="L7270" class="ln">  7270	</span>func (gz *http2gzipReader) Read(p []byte) (n int, err error) {
<span id="L7271" class="ln">  7271	</span>	if gz.zerr != nil {
<span id="L7272" class="ln">  7272	</span>		return 0, gz.zerr
<span id="L7273" class="ln">  7273	</span>	}
<span id="L7274" class="ln">  7274	</span>	if gz.zr == nil {
<span id="L7275" class="ln">  7275	</span>		gz.zr, err = gzip.NewReader(gz.body)
<span id="L7276" class="ln">  7276	</span>		if err != nil {
<span id="L7277" class="ln">  7277	</span>			gz.zerr = err
<span id="L7278" class="ln">  7278	</span>			return 0, err
<span id="L7279" class="ln">  7279	</span>		}
<span id="L7280" class="ln">  7280	</span>	}
<span id="L7281" class="ln">  7281	</span>	return gz.zr.Read(p)
<span id="L7282" class="ln">  7282	</span>}
<span id="L7283" class="ln">  7283	</span>
<span id="L7284" class="ln">  7284	</span>func (gz *http2gzipReader) Close() error {
<span id="L7285" class="ln">  7285	</span>	return gz.body.Close()
<span id="L7286" class="ln">  7286	</span>}
<span id="L7287" class="ln">  7287	</span>
<span id="L7288" class="ln">  7288	</span>type http2errorReader struct{ err error }
<span id="L7289" class="ln">  7289	</span>
<span id="L7290" class="ln">  7290	</span>func (r http2errorReader) Read(p []byte) (int, error) { return 0, r.err }
<span id="L7291" class="ln">  7291	</span>
<span id="L7292" class="ln">  7292	</span><span class="comment">// bodyWriterState encapsulates various state around the Transport&#39;s writing</span>
<span id="L7293" class="ln">  7293	</span><span class="comment">// of the request body, particularly regarding doing delayed writes of the body</span>
<span id="L7294" class="ln">  7294	</span><span class="comment">// when the request contains &#34;Expect: 100-continue&#34;.</span>
<span id="L7295" class="ln">  7295	</span>type http2bodyWriterState struct {
<span id="L7296" class="ln">  7296	</span>	cs     *http2clientStream
<span id="L7297" class="ln">  7297	</span>	timer  *time.Timer   <span class="comment">// if non-nil, we&#39;re doing a delayed write</span>
<span id="L7298" class="ln">  7298	</span>	fnonce *sync.Once    <span class="comment">// to call fn with</span>
<span id="L7299" class="ln">  7299	</span>	fn     func()        <span class="comment">// the code to run in the goroutine, writing the body</span>
<span id="L7300" class="ln">  7300	</span>	resc   chan error    <span class="comment">// result of fn&#39;s execution</span>
<span id="L7301" class="ln">  7301	</span>	delay  time.Duration <span class="comment">// how long we should delay a delayed write for</span>
<span id="L7302" class="ln">  7302	</span>}
<span id="L7303" class="ln">  7303	</span>
<span id="L7304" class="ln">  7304	</span>func (t *http2Transport) getBodyWriterState(cs *http2clientStream, body io.Reader) (s http2bodyWriterState) {
<span id="L7305" class="ln">  7305	</span>	s.cs = cs
<span id="L7306" class="ln">  7306	</span>	if body == nil {
<span id="L7307" class="ln">  7307	</span>		return
<span id="L7308" class="ln">  7308	</span>	}
<span id="L7309" class="ln">  7309	</span>	resc := make(chan error, 1)
<span id="L7310" class="ln">  7310	</span>	s.resc = resc
<span id="L7311" class="ln">  7311	</span>	s.fn = func() {
<span id="L7312" class="ln">  7312	</span>		cs.cc.mu.Lock()
<span id="L7313" class="ln">  7313	</span>		cs.startedWrite = true
<span id="L7314" class="ln">  7314	</span>		cs.cc.mu.Unlock()
<span id="L7315" class="ln">  7315	</span>		resc &lt;- cs.writeRequestBody(body, cs.req.Body)
<span id="L7316" class="ln">  7316	</span>	}
<span id="L7317" class="ln">  7317	</span>	s.delay = t.expectContinueTimeout()
<span id="L7318" class="ln">  7318	</span>	if s.delay == 0 ||
<span id="L7319" class="ln">  7319	</span>		!httplex.HeaderValuesContainsToken(
<span id="L7320" class="ln">  7320	</span>			cs.req.Header[&#34;Expect&#34;],
<span id="L7321" class="ln">  7321	</span>			&#34;100-continue&#34;) {
<span id="L7322" class="ln">  7322	</span>		return
<span id="L7323" class="ln">  7323	</span>	}
<span id="L7324" class="ln">  7324	</span>	s.fnonce = new(sync.Once)
<span id="L7325" class="ln">  7325	</span>
<span id="L7326" class="ln">  7326	</span>	<span class="comment">// Arm the timer with a very large duration, which we&#39;ll</span>
<span id="L7327" class="ln">  7327	</span>	<span class="comment">// intentionally lower later. It has to be large now because</span>
<span id="L7328" class="ln">  7328	</span>	<span class="comment">// we need a handle to it before writing the headers, but the</span>
<span id="L7329" class="ln">  7329	</span>	<span class="comment">// s.delay value is defined to not start until after the</span>
<span id="L7330" class="ln">  7330	</span>	<span class="comment">// request headers were written.</span>
<span id="L7331" class="ln">  7331	</span>	const hugeDuration = 365 * 24 * time.Hour
<span id="L7332" class="ln">  7332	</span>	s.timer = time.AfterFunc(hugeDuration, func() {
<span id="L7333" class="ln">  7333	</span>		s.fnonce.Do(s.fn)
<span id="L7334" class="ln">  7334	</span>	})
<span id="L7335" class="ln">  7335	</span>	return
<span id="L7336" class="ln">  7336	</span>}
<span id="L7337" class="ln">  7337	</span>
<span id="L7338" class="ln">  7338	</span>func (s http2bodyWriterState) cancel() {
<span id="L7339" class="ln">  7339	</span>	if s.timer != nil {
<span id="L7340" class="ln">  7340	</span>		s.timer.Stop()
<span id="L7341" class="ln">  7341	</span>	}
<span id="L7342" class="ln">  7342	</span>}
<span id="L7343" class="ln">  7343	</span>
<span id="L7344" class="ln">  7344	</span>func (s http2bodyWriterState) on100() {
<span id="L7345" class="ln">  7345	</span>	if s.timer == nil {
<span id="L7346" class="ln">  7346	</span>
<span id="L7347" class="ln">  7347	</span>		return
<span id="L7348" class="ln">  7348	</span>	}
<span id="L7349" class="ln">  7349	</span>	s.timer.Stop()
<span id="L7350" class="ln">  7350	</span>	go func() { s.fnonce.Do(s.fn) }()
<span id="L7351" class="ln">  7351	</span>}
<span id="L7352" class="ln">  7352	</span>
<span id="L7353" class="ln">  7353	</span><span class="comment">// scheduleBodyWrite starts writing the body, either immediately (in</span>
<span id="L7354" class="ln">  7354	</span><span class="comment">// the common case) or after the delay timeout. It should not be</span>
<span id="L7355" class="ln">  7355	</span><span class="comment">// called until after the headers have been written.</span>
<span id="L7356" class="ln">  7356	</span>func (s http2bodyWriterState) scheduleBodyWrite() {
<span id="L7357" class="ln">  7357	</span>	if s.timer == nil {
<span id="L7358" class="ln">  7358	</span>
<span id="L7359" class="ln">  7359	</span>		go s.fn()
<span id="L7360" class="ln">  7360	</span>		return
<span id="L7361" class="ln">  7361	</span>	}
<span id="L7362" class="ln">  7362	</span>	http2traceWait100Continue(s.cs.trace)
<span id="L7363" class="ln">  7363	</span>	if s.timer.Stop() {
<span id="L7364" class="ln">  7364	</span>		s.timer.Reset(s.delay)
<span id="L7365" class="ln">  7365	</span>	}
<span id="L7366" class="ln">  7366	</span>}
<span id="L7367" class="ln">  7367	</span>
<span id="L7368" class="ln">  7368	</span><span class="comment">// isConnectionCloseRequest reports whether req should use its own</span>
<span id="L7369" class="ln">  7369	</span><span class="comment">// connection for a single request and then close the connection.</span>
<span id="L7370" class="ln">  7370	</span>func http2isConnectionCloseRequest(req *Request) bool {
<span id="L7371" class="ln">  7371	</span>	return req.Close || httplex.HeaderValuesContainsToken(req.Header[&#34;Connection&#34;], &#34;close&#34;)
<span id="L7372" class="ln">  7372	</span>}
<span id="L7373" class="ln">  7373	</span>
<span id="L7374" class="ln">  7374	</span><span class="comment">// writeFramer is implemented by any type that is used to write frames.</span>
<span id="L7375" class="ln">  7375	</span>type http2writeFramer interface {
<span id="L7376" class="ln">  7376	</span>	writeFrame(http2writeContext) error
<span id="L7377" class="ln">  7377	</span>
<span id="L7378" class="ln">  7378	</span>	<span class="comment">// staysWithinBuffer reports whether this writer promises that</span>
<span id="L7379" class="ln">  7379	</span>	<span class="comment">// it will only write less than or equal to size bytes, and it</span>
<span id="L7380" class="ln">  7380	</span>	<span class="comment">// won&#39;t Flush the write context.</span>
<span id="L7381" class="ln">  7381	</span>	staysWithinBuffer(size int) bool
<span id="L7382" class="ln">  7382	</span>}
<span id="L7383" class="ln">  7383	</span>
<span id="L7384" class="ln">  7384	</span><span class="comment">// writeContext is the interface needed by the various frame writer</span>
<span id="L7385" class="ln">  7385	</span><span class="comment">// types below. All the writeFrame methods below are scheduled via the</span>
<span id="L7386" class="ln">  7386	</span><span class="comment">// frame writing scheduler (see writeScheduler in writesched.go).</span>
<span id="L7387" class="ln">  7387	</span><span class="comment">//</span>
<span id="L7388" class="ln">  7388	</span><span class="comment">// This interface is implemented by *serverConn.</span>
<span id="L7389" class="ln">  7389	</span><span class="comment">//</span>
<span id="L7390" class="ln">  7390	</span><span class="comment">// TODO: decide whether to a) use this in the client code (which didn&#39;t</span>
<span id="L7391" class="ln">  7391	</span><span class="comment">// end up using this yet, because it has a simpler design, not</span>
<span id="L7392" class="ln">  7392	</span><span class="comment">// currently implementing priorities), or b) delete this and</span>
<span id="L7393" class="ln">  7393	</span><span class="comment">// make the server code a bit more concrete.</span>
<span id="L7394" class="ln">  7394	</span>type http2writeContext interface {
<span id="L7395" class="ln">  7395	</span>	Framer() *http2Framer
<span id="L7396" class="ln">  7396	</span>	Flush() error
<span id="L7397" class="ln">  7397	</span>	CloseConn() error
<span id="L7398" class="ln">  7398	</span>	<span class="comment">// HeaderEncoder returns an HPACK encoder that writes to the</span>
<span id="L7399" class="ln">  7399	</span>	<span class="comment">// returned buffer.</span>
<span id="L7400" class="ln">  7400	</span>	HeaderEncoder() (*hpack.Encoder, *bytes.Buffer)
<span id="L7401" class="ln">  7401	</span>}
<span id="L7402" class="ln">  7402	</span>
<span id="L7403" class="ln">  7403	</span><span class="comment">// writeEndsStream reports whether w writes a frame that will transition</span>
<span id="L7404" class="ln">  7404	</span><span class="comment">// the stream to a half-closed local state. This returns false for RST_STREAM,</span>
<span id="L7405" class="ln">  7405	</span><span class="comment">// which closes the entire stream (not just the local half).</span>
<span id="L7406" class="ln">  7406	</span>func http2writeEndsStream(w http2writeFramer) bool {
<span id="L7407" class="ln">  7407	</span>	switch v := w.(type) {
<span id="L7408" class="ln">  7408	</span>	case *http2writeData:
<span id="L7409" class="ln">  7409	</span>		return v.endStream
<span id="L7410" class="ln">  7410	</span>	case *http2writeResHeaders:
<span id="L7411" class="ln">  7411	</span>		return v.endStream
<span id="L7412" class="ln">  7412	</span>	case nil:
<span id="L7413" class="ln">  7413	</span>
<span id="L7414" class="ln">  7414	</span>		panic(&#34;writeEndsStream called on nil writeFramer&#34;)
<span id="L7415" class="ln">  7415	</span>	}
<span id="L7416" class="ln">  7416	</span>	return false
<span id="L7417" class="ln">  7417	</span>}
<span id="L7418" class="ln">  7418	</span>
<span id="L7419" class="ln">  7419	</span>type http2flushFrameWriter struct{}
<span id="L7420" class="ln">  7420	</span>
<span id="L7421" class="ln">  7421	</span>func (http2flushFrameWriter) writeFrame(ctx http2writeContext) error {
<span id="L7422" class="ln">  7422	</span>	return ctx.Flush()
<span id="L7423" class="ln">  7423	</span>}
<span id="L7424" class="ln">  7424	</span>
<span id="L7425" class="ln">  7425	</span>func (http2flushFrameWriter) staysWithinBuffer(max int) bool { return false }
<span id="L7426" class="ln">  7426	</span>
<span id="L7427" class="ln">  7427	</span>type http2writeSettings []http2Setting
<span id="L7428" class="ln">  7428	</span>
<span id="L7429" class="ln">  7429	</span>func (s http2writeSettings) staysWithinBuffer(max int) bool {
<span id="L7430" class="ln">  7430	</span>	const settingSize = 6 <span class="comment">// uint16 + uint32</span>
<span id="L7431" class="ln">  7431	</span>	return http2frameHeaderLen+settingSize*len(s) &lt;= max
<span id="L7432" class="ln">  7432	</span>
<span id="L7433" class="ln">  7433	</span>}
<span id="L7434" class="ln">  7434	</span>
<span id="L7435" class="ln">  7435	</span>func (s http2writeSettings) writeFrame(ctx http2writeContext) error {
<span id="L7436" class="ln">  7436	</span>	return ctx.Framer().WriteSettings([]http2Setting(s)...)
<span id="L7437" class="ln">  7437	</span>}
<span id="L7438" class="ln">  7438	</span>
<span id="L7439" class="ln">  7439	</span>type http2writeGoAway struct {
<span id="L7440" class="ln">  7440	</span>	maxStreamID uint32
<span id="L7441" class="ln">  7441	</span>	code        http2ErrCode
<span id="L7442" class="ln">  7442	</span>}
<span id="L7443" class="ln">  7443	</span>
<span id="L7444" class="ln">  7444	</span>func (p *http2writeGoAway) writeFrame(ctx http2writeContext) error {
<span id="L7445" class="ln">  7445	</span>	err := ctx.Framer().WriteGoAway(p.maxStreamID, p.code, nil)
<span id="L7446" class="ln">  7446	</span>	if p.code != 0 {
<span id="L7447" class="ln">  7447	</span>		ctx.Flush()
<span id="L7448" class="ln">  7448	</span>		time.Sleep(50 * time.Millisecond)
<span id="L7449" class="ln">  7449	</span>		ctx.CloseConn()
<span id="L7450" class="ln">  7450	</span>	}
<span id="L7451" class="ln">  7451	</span>	return err
<span id="L7452" class="ln">  7452	</span>}
<span id="L7453" class="ln">  7453	</span>
<span id="L7454" class="ln">  7454	</span>func (*http2writeGoAway) staysWithinBuffer(max int) bool { return false }
<span id="L7455" class="ln">  7455	</span>
<span id="L7456" class="ln">  7456	</span>type http2writeData struct {
<span id="L7457" class="ln">  7457	</span>	streamID  uint32
<span id="L7458" class="ln">  7458	</span>	p         []byte
<span id="L7459" class="ln">  7459	</span>	endStream bool
<span id="L7460" class="ln">  7460	</span>}
<span id="L7461" class="ln">  7461	</span>
<span id="L7462" class="ln">  7462	</span>func (w *http2writeData) String() string {
<span id="L7463" class="ln">  7463	</span>	return fmt.Sprintf(&#34;writeData(stream=%d, p=%d, endStream=%v)&#34;, w.streamID, len(w.p), w.endStream)
<span id="L7464" class="ln">  7464	</span>}
<span id="L7465" class="ln">  7465	</span>
<span id="L7466" class="ln">  7466	</span>func (w *http2writeData) writeFrame(ctx http2writeContext) error {
<span id="L7467" class="ln">  7467	</span>	return ctx.Framer().WriteData(w.streamID, w.endStream, w.p)
<span id="L7468" class="ln">  7468	</span>}
<span id="L7469" class="ln">  7469	</span>
<span id="L7470" class="ln">  7470	</span>func (w *http2writeData) staysWithinBuffer(max int) bool {
<span id="L7471" class="ln">  7471	</span>	return http2frameHeaderLen+len(w.p) &lt;= max
<span id="L7472" class="ln">  7472	</span>}
<span id="L7473" class="ln">  7473	</span>
<span id="L7474" class="ln">  7474	</span><span class="comment">// handlerPanicRST is the message sent from handler goroutines when</span>
<span id="L7475" class="ln">  7475	</span><span class="comment">// the handler panics.</span>
<span id="L7476" class="ln">  7476	</span>type http2handlerPanicRST struct {
<span id="L7477" class="ln">  7477	</span>	StreamID uint32
<span id="L7478" class="ln">  7478	</span>}
<span id="L7479" class="ln">  7479	</span>
<span id="L7480" class="ln">  7480	</span>func (hp http2handlerPanicRST) writeFrame(ctx http2writeContext) error {
<span id="L7481" class="ln">  7481	</span>	return ctx.Framer().WriteRSTStream(hp.StreamID, http2ErrCodeInternal)
<span id="L7482" class="ln">  7482	</span>}
<span id="L7483" class="ln">  7483	</span>
<span id="L7484" class="ln">  7484	</span>func (hp http2handlerPanicRST) staysWithinBuffer(max int) bool { return http2frameHeaderLen+4 &lt;= max }
<span id="L7485" class="ln">  7485	</span>
<span id="L7486" class="ln">  7486	</span>func (se http2StreamError) writeFrame(ctx http2writeContext) error {
<span id="L7487" class="ln">  7487	</span>	return ctx.Framer().WriteRSTStream(se.StreamID, se.Code)
<span id="L7488" class="ln">  7488	</span>}
<span id="L7489" class="ln">  7489	</span>
<span id="L7490" class="ln">  7490	</span>func (se http2StreamError) staysWithinBuffer(max int) bool { return http2frameHeaderLen+4 &lt;= max }
<span id="L7491" class="ln">  7491	</span>
<span id="L7492" class="ln">  7492	</span>type http2writePingAck struct{ pf *http2PingFrame }
<span id="L7493" class="ln">  7493	</span>
<span id="L7494" class="ln">  7494	</span>func (w http2writePingAck) writeFrame(ctx http2writeContext) error {
<span id="L7495" class="ln">  7495	</span>	return ctx.Framer().WritePing(true, w.pf.Data)
<span id="L7496" class="ln">  7496	</span>}
<span id="L7497" class="ln">  7497	</span>
<span id="L7498" class="ln">  7498	</span>func (w http2writePingAck) staysWithinBuffer(max int) bool {
<span id="L7499" class="ln">  7499	</span>	return http2frameHeaderLen+len(w.pf.Data) &lt;= max
<span id="L7500" class="ln">  7500	</span>}
<span id="L7501" class="ln">  7501	</span>
<span id="L7502" class="ln">  7502	</span>type http2writeSettingsAck struct{}
<span id="L7503" class="ln">  7503	</span>
<span id="L7504" class="ln">  7504	</span>func (http2writeSettingsAck) writeFrame(ctx http2writeContext) error {
<span id="L7505" class="ln">  7505	</span>	return ctx.Framer().WriteSettingsAck()
<span id="L7506" class="ln">  7506	</span>}
<span id="L7507" class="ln">  7507	</span>
<span id="L7508" class="ln">  7508	</span>func (http2writeSettingsAck) staysWithinBuffer(max int) bool { return http2frameHeaderLen &lt;= max }
<span id="L7509" class="ln">  7509	</span>
<span id="L7510" class="ln">  7510	</span><span class="comment">// splitHeaderBlock splits headerBlock into fragments so that each fragment fits</span>
<span id="L7511" class="ln">  7511	</span><span class="comment">// in a single frame, then calls fn for each fragment. firstFrag/lastFrag are true</span>
<span id="L7512" class="ln">  7512	</span><span class="comment">// for the first/last fragment, respectively.</span>
<span id="L7513" class="ln">  7513	</span>func http2splitHeaderBlock(ctx http2writeContext, headerBlock []byte, fn func(ctx http2writeContext, frag []byte, firstFrag, lastFrag bool) error) error {
<span id="L7514" class="ln">  7514	</span>	<span class="comment">// For now we&#39;re lazy and just pick the minimum MAX_FRAME_SIZE</span>
<span id="L7515" class="ln">  7515	</span>	<span class="comment">// that all peers must support (16KB). Later we could care</span>
<span id="L7516" class="ln">  7516	</span>	<span class="comment">// more and send larger frames if the peer advertised it, but</span>
<span id="L7517" class="ln">  7517	</span>	<span class="comment">// there&#39;s little point. Most headers are small anyway (so we</span>
<span id="L7518" class="ln">  7518	</span>	<span class="comment">// generally won&#39;t have CONTINUATION frames), and extra frames</span>
<span id="L7519" class="ln">  7519	</span>	<span class="comment">// only waste 9 bytes anyway.</span>
<span id="L7520" class="ln">  7520	</span>	const maxFrameSize = 16384
<span id="L7521" class="ln">  7521	</span>
<span id="L7522" class="ln">  7522	</span>	first := true
<span id="L7523" class="ln">  7523	</span>	for len(headerBlock) &gt; 0 {
<span id="L7524" class="ln">  7524	</span>		frag := headerBlock
<span id="L7525" class="ln">  7525	</span>		if len(frag) &gt; maxFrameSize {
<span id="L7526" class="ln">  7526	</span>			frag = frag[:maxFrameSize]
<span id="L7527" class="ln">  7527	</span>		}
<span id="L7528" class="ln">  7528	</span>		headerBlock = headerBlock[len(frag):]
<span id="L7529" class="ln">  7529	</span>		if err := fn(ctx, frag, first, len(headerBlock) == 0); err != nil {
<span id="L7530" class="ln">  7530	</span>			return err
<span id="L7531" class="ln">  7531	</span>		}
<span id="L7532" class="ln">  7532	</span>		first = false
<span id="L7533" class="ln">  7533	</span>	}
<span id="L7534" class="ln">  7534	</span>	return nil
<span id="L7535" class="ln">  7535	</span>}
<span id="L7536" class="ln">  7536	</span>
<span id="L7537" class="ln">  7537	</span><span class="comment">// writeResHeaders is a request to write a HEADERS and 0+ CONTINUATION frames</span>
<span id="L7538" class="ln">  7538	</span><span class="comment">// for HTTP response headers or trailers from a server handler.</span>
<span id="L7539" class="ln">  7539	</span>type http2writeResHeaders struct {
<span id="L7540" class="ln">  7540	</span>	streamID    uint32
<span id="L7541" class="ln">  7541	</span>	httpResCode int      <span class="comment">// 0 means no &#34;:status&#34; line</span>
<span id="L7542" class="ln">  7542	</span>	h           Header   <span class="comment">// may be nil</span>
<span id="L7543" class="ln">  7543	</span>	trailers    []string <span class="comment">// if non-nil, which keys of h to write. nil means all.</span>
<span id="L7544" class="ln">  7544	</span>	endStream   bool
<span id="L7545" class="ln">  7545	</span>
<span id="L7546" class="ln">  7546	</span>	date          string
<span id="L7547" class="ln">  7547	</span>	contentType   string
<span id="L7548" class="ln">  7548	</span>	contentLength string
<span id="L7549" class="ln">  7549	</span>}
<span id="L7550" class="ln">  7550	</span>
<span id="L7551" class="ln">  7551	</span>func http2encKV(enc *hpack.Encoder, k, v string) {
<span id="L7552" class="ln">  7552	</span>	if http2VerboseLogs {
<span id="L7553" class="ln">  7553	</span>		log.Printf(&#34;http2: server encoding header %q = %q&#34;, k, v)
<span id="L7554" class="ln">  7554	</span>	}
<span id="L7555" class="ln">  7555	</span>	enc.WriteField(hpack.HeaderField{Name: k, Value: v})
<span id="L7556" class="ln">  7556	</span>}
<span id="L7557" class="ln">  7557	</span>
<span id="L7558" class="ln">  7558	</span>func (w *http2writeResHeaders) staysWithinBuffer(max int) bool {
<span id="L7559" class="ln">  7559	</span>
<span id="L7560" class="ln">  7560	</span>	return false
<span id="L7561" class="ln">  7561	</span>}
<span id="L7562" class="ln">  7562	</span>
<span id="L7563" class="ln">  7563	</span>func (w *http2writeResHeaders) writeFrame(ctx http2writeContext) error {
<span id="L7564" class="ln">  7564	</span>	enc, buf := ctx.HeaderEncoder()
<span id="L7565" class="ln">  7565	</span>	buf.Reset()
<span id="L7566" class="ln">  7566	</span>
<span id="L7567" class="ln">  7567	</span>	if w.httpResCode != 0 {
<span id="L7568" class="ln">  7568	</span>		http2encKV(enc, &#34;:status&#34;, http2httpCodeString(w.httpResCode))
<span id="L7569" class="ln">  7569	</span>	}
<span id="L7570" class="ln">  7570	</span>
<span id="L7571" class="ln">  7571	</span>	http2encodeHeaders(enc, w.h, w.trailers)
<span id="L7572" class="ln">  7572	</span>
<span id="L7573" class="ln">  7573	</span>	if w.contentType != &#34;&#34; {
<span id="L7574" class="ln">  7574	</span>		http2encKV(enc, &#34;content-type&#34;, w.contentType)
<span id="L7575" class="ln">  7575	</span>	}
<span id="L7576" class="ln">  7576	</span>	if w.contentLength != &#34;&#34; {
<span id="L7577" class="ln">  7577	</span>		http2encKV(enc, &#34;content-length&#34;, w.contentLength)
<span id="L7578" class="ln">  7578	</span>	}
<span id="L7579" class="ln">  7579	</span>	if w.date != &#34;&#34; {
<span id="L7580" class="ln">  7580	</span>		http2encKV(enc, &#34;date&#34;, w.date)
<span id="L7581" class="ln">  7581	</span>	}
<span id="L7582" class="ln">  7582	</span>
<span id="L7583" class="ln">  7583	</span>	headerBlock := buf.Bytes()
<span id="L7584" class="ln">  7584	</span>	if len(headerBlock) == 0 &amp;&amp; w.trailers == nil {
<span id="L7585" class="ln">  7585	</span>		panic(&#34;unexpected empty hpack&#34;)
<span id="L7586" class="ln">  7586	</span>	}
<span id="L7587" class="ln">  7587	</span>
<span id="L7588" class="ln">  7588	</span>	return http2splitHeaderBlock(ctx, headerBlock, w.writeHeaderBlock)
<span id="L7589" class="ln">  7589	</span>}
<span id="L7590" class="ln">  7590	</span>
<span id="L7591" class="ln">  7591	</span>func (w *http2writeResHeaders) writeHeaderBlock(ctx http2writeContext, frag []byte, firstFrag, lastFrag bool) error {
<span id="L7592" class="ln">  7592	</span>	if firstFrag {
<span id="L7593" class="ln">  7593	</span>		return ctx.Framer().WriteHeaders(http2HeadersFrameParam{
<span id="L7594" class="ln">  7594	</span>			StreamID:      w.streamID,
<span id="L7595" class="ln">  7595	</span>			BlockFragment: frag,
<span id="L7596" class="ln">  7596	</span>			EndStream:     w.endStream,
<span id="L7597" class="ln">  7597	</span>			EndHeaders:    lastFrag,
<span id="L7598" class="ln">  7598	</span>		})
<span id="L7599" class="ln">  7599	</span>	} else {
<span id="L7600" class="ln">  7600	</span>		return ctx.Framer().WriteContinuation(w.streamID, lastFrag, frag)
<span id="L7601" class="ln">  7601	</span>	}
<span id="L7602" class="ln">  7602	</span>}
<span id="L7603" class="ln">  7603	</span>
<span id="L7604" class="ln">  7604	</span><span class="comment">// writePushPromise is a request to write a PUSH_PROMISE and 0+ CONTINUATION frames.</span>
<span id="L7605" class="ln">  7605	</span>type http2writePushPromise struct {
<span id="L7606" class="ln">  7606	</span>	streamID uint32   <span class="comment">// pusher stream</span>
<span id="L7607" class="ln">  7607	</span>	method   string   <span class="comment">// for :method</span>
<span id="L7608" class="ln">  7608	</span>	url      *url.URL <span class="comment">// for :scheme, :authority, :path</span>
<span id="L7609" class="ln">  7609	</span>	h        Header
<span id="L7610" class="ln">  7610	</span>
<span id="L7611" class="ln">  7611	</span>	<span class="comment">// Creates an ID for a pushed stream. This runs on serveG just before</span>
<span id="L7612" class="ln">  7612	</span>	<span class="comment">// the frame is written. The returned ID is copied to promisedID.</span>
<span id="L7613" class="ln">  7613	</span>	allocatePromisedID func() (uint32, error)
<span id="L7614" class="ln">  7614	</span>	promisedID         uint32
<span id="L7615" class="ln">  7615	</span>}
<span id="L7616" class="ln">  7616	</span>
<span id="L7617" class="ln">  7617	</span>func (w *http2writePushPromise) staysWithinBuffer(max int) bool {
<span id="L7618" class="ln">  7618	</span>
<span id="L7619" class="ln">  7619	</span>	return false
<span id="L7620" class="ln">  7620	</span>}
<span id="L7621" class="ln">  7621	</span>
<span id="L7622" class="ln">  7622	</span>func (w *http2writePushPromise) writeFrame(ctx http2writeContext) error {
<span id="L7623" class="ln">  7623	</span>	enc, buf := ctx.HeaderEncoder()
<span id="L7624" class="ln">  7624	</span>	buf.Reset()
<span id="L7625" class="ln">  7625	</span>
<span id="L7626" class="ln">  7626	</span>	http2encKV(enc, &#34;:method&#34;, w.method)
<span id="L7627" class="ln">  7627	</span>	http2encKV(enc, &#34;:scheme&#34;, w.url.Scheme)
<span id="L7628" class="ln">  7628	</span>	http2encKV(enc, &#34;:authority&#34;, w.url.Host)
<span id="L7629" class="ln">  7629	</span>	http2encKV(enc, &#34;:path&#34;, w.url.RequestURI())
<span id="L7630" class="ln">  7630	</span>	http2encodeHeaders(enc, w.h, nil)
<span id="L7631" class="ln">  7631	</span>
<span id="L7632" class="ln">  7632	</span>	headerBlock := buf.Bytes()
<span id="L7633" class="ln">  7633	</span>	if len(headerBlock) == 0 {
<span id="L7634" class="ln">  7634	</span>		panic(&#34;unexpected empty hpack&#34;)
<span id="L7635" class="ln">  7635	</span>	}
<span id="L7636" class="ln">  7636	</span>
<span id="L7637" class="ln">  7637	</span>	return http2splitHeaderBlock(ctx, headerBlock, w.writeHeaderBlock)
<span id="L7638" class="ln">  7638	</span>}
<span id="L7639" class="ln">  7639	</span>
<span id="L7640" class="ln">  7640	</span>func (w *http2writePushPromise) writeHeaderBlock(ctx http2writeContext, frag []byte, firstFrag, lastFrag bool) error {
<span id="L7641" class="ln">  7641	</span>	if firstFrag {
<span id="L7642" class="ln">  7642	</span>		return ctx.Framer().WritePushPromise(http2PushPromiseParam{
<span id="L7643" class="ln">  7643	</span>			StreamID:      w.streamID,
<span id="L7644" class="ln">  7644	</span>			PromiseID:     w.promisedID,
<span id="L7645" class="ln">  7645	</span>			BlockFragment: frag,
<span id="L7646" class="ln">  7646	</span>			EndHeaders:    lastFrag,
<span id="L7647" class="ln">  7647	</span>		})
<span id="L7648" class="ln">  7648	</span>	} else {
<span id="L7649" class="ln">  7649	</span>		return ctx.Framer().WriteContinuation(w.streamID, lastFrag, frag)
<span id="L7650" class="ln">  7650	</span>	}
<span id="L7651" class="ln">  7651	</span>}
<span id="L7652" class="ln">  7652	</span>
<span id="L7653" class="ln">  7653	</span>type http2write100ContinueHeadersFrame struct {
<span id="L7654" class="ln">  7654	</span>	streamID uint32
<span id="L7655" class="ln">  7655	</span>}
<span id="L7656" class="ln">  7656	</span>
<span id="L7657" class="ln">  7657	</span>func (w http2write100ContinueHeadersFrame) writeFrame(ctx http2writeContext) error {
<span id="L7658" class="ln">  7658	</span>	enc, buf := ctx.HeaderEncoder()
<span id="L7659" class="ln">  7659	</span>	buf.Reset()
<span id="L7660" class="ln">  7660	</span>	http2encKV(enc, &#34;:status&#34;, &#34;100&#34;)
<span id="L7661" class="ln">  7661	</span>	return ctx.Framer().WriteHeaders(http2HeadersFrameParam{
<span id="L7662" class="ln">  7662	</span>		StreamID:      w.streamID,
<span id="L7663" class="ln">  7663	</span>		BlockFragment: buf.Bytes(),
<span id="L7664" class="ln">  7664	</span>		EndStream:     false,
<span id="L7665" class="ln">  7665	</span>		EndHeaders:    true,
<span id="L7666" class="ln">  7666	</span>	})
<span id="L7667" class="ln">  7667	</span>}
<span id="L7668" class="ln">  7668	</span>
<span id="L7669" class="ln">  7669	</span>func (w http2write100ContinueHeadersFrame) staysWithinBuffer(max int) bool {
<span id="L7670" class="ln">  7670	</span>
<span id="L7671" class="ln">  7671	</span>	return 9+2*(len(&#34;:status&#34;)+len(&#34;100&#34;)) &lt;= max
<span id="L7672" class="ln">  7672	</span>}
<span id="L7673" class="ln">  7673	</span>
<span id="L7674" class="ln">  7674	</span>type http2writeWindowUpdate struct {
<span id="L7675" class="ln">  7675	</span>	streamID uint32 <span class="comment">// or 0 for conn-level</span>
<span id="L7676" class="ln">  7676	</span>	n        uint32
<span id="L7677" class="ln">  7677	</span>}
<span id="L7678" class="ln">  7678	</span>
<span id="L7679" class="ln">  7679	</span>func (wu http2writeWindowUpdate) staysWithinBuffer(max int) bool { return http2frameHeaderLen+4 &lt;= max }
<span id="L7680" class="ln">  7680	</span>
<span id="L7681" class="ln">  7681	</span>func (wu http2writeWindowUpdate) writeFrame(ctx http2writeContext) error {
<span id="L7682" class="ln">  7682	</span>	return ctx.Framer().WriteWindowUpdate(wu.streamID, wu.n)
<span id="L7683" class="ln">  7683	</span>}
<span id="L7684" class="ln">  7684	</span>
<span id="L7685" class="ln">  7685	</span><span class="comment">// encodeHeaders encodes an http.Header. If keys is not nil, then (k, h[k])</span>
<span id="L7686" class="ln">  7686	</span><span class="comment">// is encoded only only if k is in keys.</span>
<span id="L7687" class="ln">  7687	</span>func http2encodeHeaders(enc *hpack.Encoder, h Header, keys []string) {
<span id="L7688" class="ln">  7688	</span>	if keys == nil {
<span id="L7689" class="ln">  7689	</span>		sorter := http2sorterPool.Get().(*http2sorter)
<span id="L7690" class="ln">  7690	</span>
<span id="L7691" class="ln">  7691	</span>		defer http2sorterPool.Put(sorter)
<span id="L7692" class="ln">  7692	</span>		keys = sorter.Keys(h)
<span id="L7693" class="ln">  7693	</span>	}
<span id="L7694" class="ln">  7694	</span>	for _, k := range keys {
<span id="L7695" class="ln">  7695	</span>		vv := h[k]
<span id="L7696" class="ln">  7696	</span>		k = http2lowerHeader(k)
<span id="L7697" class="ln">  7697	</span>		if !http2validWireHeaderFieldName(k) {
<span id="L7698" class="ln">  7698	</span>
<span id="L7699" class="ln">  7699	</span>			continue
<span id="L7700" class="ln">  7700	</span>		}
<span id="L7701" class="ln">  7701	</span>		isTE := k == &#34;transfer-encoding&#34;
<span id="L7702" class="ln">  7702	</span>		for _, v := range vv {
<span id="L7703" class="ln">  7703	</span>			if !httplex.ValidHeaderFieldValue(v) {
<span id="L7704" class="ln">  7704	</span>
<span id="L7705" class="ln">  7705	</span>				continue
<span id="L7706" class="ln">  7706	</span>			}
<span id="L7707" class="ln">  7707	</span>
<span id="L7708" class="ln">  7708	</span>			if isTE &amp;&amp; v != &#34;trailers&#34; {
<span id="L7709" class="ln">  7709	</span>				continue
<span id="L7710" class="ln">  7710	</span>			}
<span id="L7711" class="ln">  7711	</span>			http2encKV(enc, k, v)
<span id="L7712" class="ln">  7712	</span>		}
<span id="L7713" class="ln">  7713	</span>	}
<span id="L7714" class="ln">  7714	</span>}
<span id="L7715" class="ln">  7715	</span>
<span id="L7716" class="ln">  7716	</span><span class="comment">// WriteScheduler is the interface implemented by HTTP/2 write schedulers.</span>
<span id="L7717" class="ln">  7717	</span><span class="comment">// Methods are never called concurrently.</span>
<span id="L7718" class="ln">  7718	</span>type http2WriteScheduler interface {
<span id="L7719" class="ln">  7719	</span>	<span class="comment">// OpenStream opens a new stream in the write scheduler.</span>
<span id="L7720" class="ln">  7720	</span>	<span class="comment">// It is illegal to call this with streamID=0 or with a streamID that is</span>
<span id="L7721" class="ln">  7721	</span>	<span class="comment">// already open -- the call may panic.</span>
<span id="L7722" class="ln">  7722	</span>	OpenStream(streamID uint32, options http2OpenStreamOptions)
<span id="L7723" class="ln">  7723	</span>
<span id="L7724" class="ln">  7724	</span>	<span class="comment">// CloseStream closes a stream in the write scheduler. Any frames queued on</span>
<span id="L7725" class="ln">  7725	</span>	<span class="comment">// this stream should be discarded. It is illegal to call this on a stream</span>
<span id="L7726" class="ln">  7726	</span>	<span class="comment">// that is not open -- the call may panic.</span>
<span id="L7727" class="ln">  7727	</span>	CloseStream(streamID uint32)
<span id="L7728" class="ln">  7728	</span>
<span id="L7729" class="ln">  7729	</span>	<span class="comment">// AdjustStream adjusts the priority of the given stream. This may be called</span>
<span id="L7730" class="ln">  7730	</span>	<span class="comment">// on a stream that has not yet been opened or has been closed. Note that</span>
<span id="L7731" class="ln">  7731	</span>	<span class="comment">// RFC 7540 allows PRIORITY frames to be sent on streams in any state. See:</span>
<span id="L7732" class="ln">  7732	</span>	<span class="comment">// https://tools.ietf.org/html/rfc7540#section-5.1</span>
<span id="L7733" class="ln">  7733	</span>	AdjustStream(streamID uint32, priority http2PriorityParam)
<span id="L7734" class="ln">  7734	</span>
<span id="L7735" class="ln">  7735	</span>	<span class="comment">// Push queues a frame in the scheduler. In most cases, this will not be</span>
<span id="L7736" class="ln">  7736	</span>	<span class="comment">// called with wr.StreamID()!=0 unless that stream is currently open. The one</span>
<span id="L7737" class="ln">  7737	</span>	<span class="comment">// exception is RST_STREAM frames, which may be sent on idle or closed streams.</span>
<span id="L7738" class="ln">  7738	</span>	Push(wr http2FrameWriteRequest)
<span id="L7739" class="ln">  7739	</span>
<span id="L7740" class="ln">  7740	</span>	<span class="comment">// Pop dequeues the next frame to write. Returns false if no frames can</span>
<span id="L7741" class="ln">  7741	</span>	<span class="comment">// be written. Frames with a given wr.StreamID() are Pop&#39;d in the same</span>
<span id="L7742" class="ln">  7742	</span>	<span class="comment">// order they are Push&#39;d.</span>
<span id="L7743" class="ln">  7743	</span>	Pop() (wr http2FrameWriteRequest, ok bool)
<span id="L7744" class="ln">  7744	</span>}
<span id="L7745" class="ln">  7745	</span>
<span id="L7746" class="ln">  7746	</span><span class="comment">// OpenStreamOptions specifies extra options for WriteScheduler.OpenStream.</span>
<span id="L7747" class="ln">  7747	</span>type http2OpenStreamOptions struct {
<span id="L7748" class="ln">  7748	</span>	<span class="comment">// PusherID is zero if the stream was initiated by the client. Otherwise,</span>
<span id="L7749" class="ln">  7749	</span>	<span class="comment">// PusherID names the stream that pushed the newly opened stream.</span>
<span id="L7750" class="ln">  7750	</span>	PusherID uint32
<span id="L7751" class="ln">  7751	</span>}
<span id="L7752" class="ln">  7752	</span>
<span id="L7753" class="ln">  7753	</span><span class="comment">// FrameWriteRequest is a request to write a frame.</span>
<span id="L7754" class="ln">  7754	</span>type http2FrameWriteRequest struct {
<span id="L7755" class="ln">  7755	</span>	<span class="comment">// write is the interface value that does the writing, once the</span>
<span id="L7756" class="ln">  7756	</span>	<span class="comment">// WriteScheduler has selected this frame to write. The write</span>
<span id="L7757" class="ln">  7757	</span>	<span class="comment">// functions are all defined in write.go.</span>
<span id="L7758" class="ln">  7758	</span>	write http2writeFramer
<span id="L7759" class="ln">  7759	</span>
<span id="L7760" class="ln">  7760	</span>	<span class="comment">// stream is the stream on which this frame will be written.</span>
<span id="L7761" class="ln">  7761	</span>	<span class="comment">// nil for non-stream frames like PING and SETTINGS.</span>
<span id="L7762" class="ln">  7762	</span>	stream *http2stream
<span id="L7763" class="ln">  7763	</span>
<span id="L7764" class="ln">  7764	</span>	<span class="comment">// done, if non-nil, must be a buffered channel with space for</span>
<span id="L7765" class="ln">  7765	</span>	<span class="comment">// 1 message and is sent the return value from write (or an</span>
<span id="L7766" class="ln">  7766	</span>	<span class="comment">// earlier error) when the frame has been written.</span>
<span id="L7767" class="ln">  7767	</span>	done chan error
<span id="L7768" class="ln">  7768	</span>}
<span id="L7769" class="ln">  7769	</span>
<span id="L7770" class="ln">  7770	</span><span class="comment">// StreamID returns the id of the stream this frame will be written to.</span>
<span id="L7771" class="ln">  7771	</span><span class="comment">// 0 is used for non-stream frames such as PING and SETTINGS.</span>
<span id="L7772" class="ln">  7772	</span>func (wr http2FrameWriteRequest) StreamID() uint32 {
<span id="L7773" class="ln">  7773	</span>	if wr.stream == nil {
<span id="L7774" class="ln">  7774	</span>		if se, ok := wr.write.(http2StreamError); ok {
<span id="L7775" class="ln">  7775	</span>
<span id="L7776" class="ln">  7776	</span>			return se.StreamID
<span id="L7777" class="ln">  7777	</span>		}
<span id="L7778" class="ln">  7778	</span>		return 0
<span id="L7779" class="ln">  7779	</span>	}
<span id="L7780" class="ln">  7780	</span>	return wr.stream.id
<span id="L7781" class="ln">  7781	</span>}
<span id="L7782" class="ln">  7782	</span>
<span id="L7783" class="ln">  7783	</span><span class="comment">// DataSize returns the number of flow control bytes that must be consumed</span>
<span id="L7784" class="ln">  7784	</span><span class="comment">// to write this entire frame. This is 0 for non-DATA frames.</span>
<span id="L7785" class="ln">  7785	</span>func (wr http2FrameWriteRequest) DataSize() int {
<span id="L7786" class="ln">  7786	</span>	if wd, ok := wr.write.(*http2writeData); ok {
<span id="L7787" class="ln">  7787	</span>		return len(wd.p)
<span id="L7788" class="ln">  7788	</span>	}
<span id="L7789" class="ln">  7789	</span>	return 0
<span id="L7790" class="ln">  7790	</span>}
<span id="L7791" class="ln">  7791	</span>
<span id="L7792" class="ln">  7792	</span><span class="comment">// Consume consumes min(n, available) bytes from this frame, where available</span>
<span id="L7793" class="ln">  7793	</span><span class="comment">// is the number of flow control bytes available on the stream. Consume returns</span>
<span id="L7794" class="ln">  7794	</span><span class="comment">// 0, 1, or 2 frames, where the integer return value gives the number of frames</span>
<span id="L7795" class="ln">  7795	</span><span class="comment">// returned.</span>
<span id="L7796" class="ln">  7796	</span><span class="comment">//</span>
<span id="L7797" class="ln">  7797	</span><span class="comment">// If flow control prevents consuming any bytes, this returns (_, _, 0). If</span>
<span id="L7798" class="ln">  7798	</span><span class="comment">// the entire frame was consumed, this returns (wr, _, 1). Otherwise, this</span>
<span id="L7799" class="ln">  7799	</span><span class="comment">// returns (consumed, rest, 2), where &#39;consumed&#39; contains the consumed bytes and</span>
<span id="L7800" class="ln">  7800	</span><span class="comment">// &#39;rest&#39; contains the remaining bytes. The consumed bytes are deducted from the</span>
<span id="L7801" class="ln">  7801	</span><span class="comment">// underlying stream&#39;s flow control budget.</span>
<span id="L7802" class="ln">  7802	</span>func (wr http2FrameWriteRequest) Consume(n int32) (http2FrameWriteRequest, http2FrameWriteRequest, int) {
<span id="L7803" class="ln">  7803	</span>	var empty http2FrameWriteRequest
<span id="L7804" class="ln">  7804	</span>
<span id="L7805" class="ln">  7805	</span>	wd, ok := wr.write.(*http2writeData)
<span id="L7806" class="ln">  7806	</span>	if !ok || len(wd.p) == 0 {
<span id="L7807" class="ln">  7807	</span>		return wr, empty, 1
<span id="L7808" class="ln">  7808	</span>	}
<span id="L7809" class="ln">  7809	</span>
<span id="L7810" class="ln">  7810	</span>	allowed := wr.stream.flow.available()
<span id="L7811" class="ln">  7811	</span>	if n &lt; allowed {
<span id="L7812" class="ln">  7812	</span>		allowed = n
<span id="L7813" class="ln">  7813	</span>	}
<span id="L7814" class="ln">  7814	</span>	if wr.stream.sc.maxFrameSize &lt; allowed {
<span id="L7815" class="ln">  7815	</span>		allowed = wr.stream.sc.maxFrameSize
<span id="L7816" class="ln">  7816	</span>	}
<span id="L7817" class="ln">  7817	</span>	if allowed &lt;= 0 {
<span id="L7818" class="ln">  7818	</span>		return empty, empty, 0
<span id="L7819" class="ln">  7819	</span>	}
<span id="L7820" class="ln">  7820	</span>	if len(wd.p) &gt; int(allowed) {
<span id="L7821" class="ln">  7821	</span>		wr.stream.flow.take(allowed)
<span id="L7822" class="ln">  7822	</span>		consumed := http2FrameWriteRequest{
<span id="L7823" class="ln">  7823	</span>			stream: wr.stream,
<span id="L7824" class="ln">  7824	</span>			write: &amp;http2writeData{
<span id="L7825" class="ln">  7825	</span>				streamID: wd.streamID,
<span id="L7826" class="ln">  7826	</span>				p:        wd.p[:allowed],
<span id="L7827" class="ln">  7827	</span>
<span id="L7828" class="ln">  7828	</span>				endStream: false,
<span id="L7829" class="ln">  7829	</span>			},
<span id="L7830" class="ln">  7830	</span>
<span id="L7831" class="ln">  7831	</span>			done: nil,
<span id="L7832" class="ln">  7832	</span>		}
<span id="L7833" class="ln">  7833	</span>		rest := http2FrameWriteRequest{
<span id="L7834" class="ln">  7834	</span>			stream: wr.stream,
<span id="L7835" class="ln">  7835	</span>			write: &amp;http2writeData{
<span id="L7836" class="ln">  7836	</span>				streamID:  wd.streamID,
<span id="L7837" class="ln">  7837	</span>				p:         wd.p[allowed:],
<span id="L7838" class="ln">  7838	</span>				endStream: wd.endStream,
<span id="L7839" class="ln">  7839	</span>			},
<span id="L7840" class="ln">  7840	</span>			done: wr.done,
<span id="L7841" class="ln">  7841	</span>		}
<span id="L7842" class="ln">  7842	</span>		return consumed, rest, 2
<span id="L7843" class="ln">  7843	</span>	}
<span id="L7844" class="ln">  7844	</span>
<span id="L7845" class="ln">  7845	</span>	wr.stream.flow.take(int32(len(wd.p)))
<span id="L7846" class="ln">  7846	</span>	return wr, empty, 1
<span id="L7847" class="ln">  7847	</span>}
<span id="L7848" class="ln">  7848	</span>
<span id="L7849" class="ln">  7849	</span><span class="comment">// String is for debugging only.</span>
<span id="L7850" class="ln">  7850	</span>func (wr http2FrameWriteRequest) String() string {
<span id="L7851" class="ln">  7851	</span>	var des string
<span id="L7852" class="ln">  7852	</span>	if s, ok := wr.write.(fmt.Stringer); ok {
<span id="L7853" class="ln">  7853	</span>		des = s.String()
<span id="L7854" class="ln">  7854	</span>	} else {
<span id="L7855" class="ln">  7855	</span>		des = fmt.Sprintf(&#34;%T&#34;, wr.write)
<span id="L7856" class="ln">  7856	</span>	}
<span id="L7857" class="ln">  7857	</span>	return fmt.Sprintf(&#34;[FrameWriteRequest stream=%d, ch=%v, writer=%v]&#34;, wr.StreamID(), wr.done != nil, des)
<span id="L7858" class="ln">  7858	</span>}
<span id="L7859" class="ln">  7859	</span>
<span id="L7860" class="ln">  7860	</span><span class="comment">// replyToWriter sends err to wr.done and panics if the send must block</span>
<span id="L7861" class="ln">  7861	</span><span class="comment">// This does nothing if wr.done is nil.</span>
<span id="L7862" class="ln">  7862	</span>func (wr *http2FrameWriteRequest) replyToWriter(err error) {
<span id="L7863" class="ln">  7863	</span>	if wr.done == nil {
<span id="L7864" class="ln">  7864	</span>		return
<span id="L7865" class="ln">  7865	</span>	}
<span id="L7866" class="ln">  7866	</span>	select {
<span id="L7867" class="ln">  7867	</span>	case wr.done &lt;- err:
<span id="L7868" class="ln">  7868	</span>	default:
<span id="L7869" class="ln">  7869	</span>		panic(fmt.Sprintf(&#34;unbuffered done channel passed in for type %T&#34;, wr.write))
<span id="L7870" class="ln">  7870	</span>	}
<span id="L7871" class="ln">  7871	</span>	wr.write = nil
<span id="L7872" class="ln">  7872	</span>}
<span id="L7873" class="ln">  7873	</span>
<span id="L7874" class="ln">  7874	</span><span class="comment">// writeQueue is used by implementations of WriteScheduler.</span>
<span id="L7875" class="ln">  7875	</span>type http2writeQueue struct {
<span id="L7876" class="ln">  7876	</span>	s []http2FrameWriteRequest
<span id="L7877" class="ln">  7877	</span>}
<span id="L7878" class="ln">  7878	</span>
<span id="L7879" class="ln">  7879	</span>func (q *http2writeQueue) empty() bool { return len(q.s) == 0 }
<span id="L7880" class="ln">  7880	</span>
<span id="L7881" class="ln">  7881	</span>func (q *http2writeQueue) push(wr http2FrameWriteRequest) {
<span id="L7882" class="ln">  7882	</span>	q.s = append(q.s, wr)
<span id="L7883" class="ln">  7883	</span>}
<span id="L7884" class="ln">  7884	</span>
<span id="L7885" class="ln">  7885	</span>func (q *http2writeQueue) shift() http2FrameWriteRequest {
<span id="L7886" class="ln">  7886	</span>	if len(q.s) == 0 {
<span id="L7887" class="ln">  7887	</span>		panic(&#34;invalid use of queue&#34;)
<span id="L7888" class="ln">  7888	</span>	}
<span id="L7889" class="ln">  7889	</span>	wr := q.s[0]
<span id="L7890" class="ln">  7890	</span>
<span id="L7891" class="ln">  7891	</span>	copy(q.s, q.s[1:])
<span id="L7892" class="ln">  7892	</span>	q.s[len(q.s)-1] = http2FrameWriteRequest{}
<span id="L7893" class="ln">  7893	</span>	q.s = q.s[:len(q.s)-1]
<span id="L7894" class="ln">  7894	</span>	return wr
<span id="L7895" class="ln">  7895	</span>}
<span id="L7896" class="ln">  7896	</span>
<span id="L7897" class="ln">  7897	</span><span class="comment">// consume consumes up to n bytes from q.s[0]. If the frame is</span>
<span id="L7898" class="ln">  7898	</span><span class="comment">// entirely consumed, it is removed from the queue. If the frame</span>
<span id="L7899" class="ln">  7899	</span><span class="comment">// is partially consumed, the frame is kept with the consumed</span>
<span id="L7900" class="ln">  7900	</span><span class="comment">// bytes removed. Returns true iff any bytes were consumed.</span>
<span id="L7901" class="ln">  7901	</span>func (q *http2writeQueue) consume(n int32) (http2FrameWriteRequest, bool) {
<span id="L7902" class="ln">  7902	</span>	if len(q.s) == 0 {
<span id="L7903" class="ln">  7903	</span>		return http2FrameWriteRequest{}, false
<span id="L7904" class="ln">  7904	</span>	}
<span id="L7905" class="ln">  7905	</span>	consumed, rest, numresult := q.s[0].Consume(n)
<span id="L7906" class="ln">  7906	</span>	switch numresult {
<span id="L7907" class="ln">  7907	</span>	case 0:
<span id="L7908" class="ln">  7908	</span>		return http2FrameWriteRequest{}, false
<span id="L7909" class="ln">  7909	</span>	case 1:
<span id="L7910" class="ln">  7910	</span>		q.shift()
<span id="L7911" class="ln">  7911	</span>	case 2:
<span id="L7912" class="ln">  7912	</span>		q.s[0] = rest
<span id="L7913" class="ln">  7913	</span>	}
<span id="L7914" class="ln">  7914	</span>	return consumed, true
<span id="L7915" class="ln">  7915	</span>}
<span id="L7916" class="ln">  7916	</span>
<span id="L7917" class="ln">  7917	</span>type http2writeQueuePool []*http2writeQueue
<span id="L7918" class="ln">  7918	</span>
<span id="L7919" class="ln">  7919	</span><span class="comment">// put inserts an unused writeQueue into the pool.</span>
<span id="L7920" class="ln">  7920	</span>func (p *http2writeQueuePool) put(q *http2writeQueue) {
<span id="L7921" class="ln">  7921	</span>	for i := range q.s {
<span id="L7922" class="ln">  7922	</span>		q.s[i] = http2FrameWriteRequest{}
<span id="L7923" class="ln">  7923	</span>	}
<span id="L7924" class="ln">  7924	</span>	q.s = q.s[:0]
<span id="L7925" class="ln">  7925	</span>	*p = append(*p, q)
<span id="L7926" class="ln">  7926	</span>}
<span id="L7927" class="ln">  7927	</span>
<span id="L7928" class="ln">  7928	</span><span class="comment">// get returns an empty writeQueue.</span>
<span id="L7929" class="ln">  7929	</span>func (p *http2writeQueuePool) get() *http2writeQueue {
<span id="L7930" class="ln">  7930	</span>	ln := len(*p)
<span id="L7931" class="ln">  7931	</span>	if ln == 0 {
<span id="L7932" class="ln">  7932	</span>		return new(http2writeQueue)
<span id="L7933" class="ln">  7933	</span>	}
<span id="L7934" class="ln">  7934	</span>	x := ln - 1
<span id="L7935" class="ln">  7935	</span>	q := (*p)[x]
<span id="L7936" class="ln">  7936	</span>	(*p)[x] = nil
<span id="L7937" class="ln">  7937	</span>	*p = (*p)[:x]
<span id="L7938" class="ln">  7938	</span>	return q
<span id="L7939" class="ln">  7939	</span>}
<span id="L7940" class="ln">  7940	</span>
<span id="L7941" class="ln">  7941	</span><span class="comment">// RFC 7540, Section 5.3.5: the default weight is 16.</span>
<span id="L7942" class="ln">  7942	</span>const http2priorityDefaultWeight = 15 <span class="comment">// 16 = 15 + 1</span>
<span id="L7943" class="ln">  7943	</span>
<span id="L7944" class="ln">  7944	</span><span class="comment">// PriorityWriteSchedulerConfig configures a priorityWriteScheduler.</span>
<span id="L7945" class="ln">  7945	</span>type http2PriorityWriteSchedulerConfig struct {
<span id="L7946" class="ln">  7946	</span>	<span class="comment">// MaxClosedNodesInTree controls the maximum number of closed streams to</span>
<span id="L7947" class="ln">  7947	</span>	<span class="comment">// retain in the priority tree. Setting this to zero saves a small amount</span>
<span id="L7948" class="ln">  7948	</span>	<span class="comment">// of memory at the cost of performance.</span>
<span id="L7949" class="ln">  7949	</span>	<span class="comment">//</span>
<span id="L7950" class="ln">  7950	</span>	<span class="comment">// See RFC 7540, Section 5.3.4:</span>
<span id="L7951" class="ln">  7951	</span>	<span class="comment">//   &#34;It is possible for a stream to become closed while prioritization</span>
<span id="L7952" class="ln">  7952	</span>	<span class="comment">//   information ... is in transit. ... This potentially creates suboptimal</span>
<span id="L7953" class="ln">  7953	</span>	<span class="comment">//   prioritization, since the stream could be given a priority that is</span>
<span id="L7954" class="ln">  7954	</span>	<span class="comment">//   different from what is intended. To avoid these problems, an endpoint</span>
<span id="L7955" class="ln">  7955	</span>	<span class="comment">//   SHOULD retain stream prioritization state for a period after streams</span>
<span id="L7956" class="ln">  7956	</span>	<span class="comment">//   become closed. The longer state is retained, the lower the chance that</span>
<span id="L7957" class="ln">  7957	</span>	<span class="comment">//   streams are assigned incorrect or default priority values.&#34;</span>
<span id="L7958" class="ln">  7958	</span>	MaxClosedNodesInTree int
<span id="L7959" class="ln">  7959	</span>
<span id="L7960" class="ln">  7960	</span>	<span class="comment">// MaxIdleNodesInTree controls the maximum number of idle streams to</span>
<span id="L7961" class="ln">  7961	</span>	<span class="comment">// retain in the priority tree. Setting this to zero saves a small amount</span>
<span id="L7962" class="ln">  7962	</span>	<span class="comment">// of memory at the cost of performance.</span>
<span id="L7963" class="ln">  7963	</span>	<span class="comment">//</span>
<span id="L7964" class="ln">  7964	</span>	<span class="comment">// See RFC 7540, Section 5.3.4:</span>
<span id="L7965" class="ln">  7965	</span>	<span class="comment">//   Similarly, streams that are in the &#34;idle&#34; state can be assigned</span>
<span id="L7966" class="ln">  7966	</span>	<span class="comment">//   priority or become a parent of other streams. This allows for the</span>
<span id="L7967" class="ln">  7967	</span>	<span class="comment">//   creation of a grouping node in the dependency tree, which enables</span>
<span id="L7968" class="ln">  7968	</span>	<span class="comment">//   more flexible expressions of priority. Idle streams begin with a</span>
<span id="L7969" class="ln">  7969	</span>	<span class="comment">//   default priority (Section 5.3.5).</span>
<span id="L7970" class="ln">  7970	</span>	MaxIdleNodesInTree int
<span id="L7971" class="ln">  7971	</span>
<span id="L7972" class="ln">  7972	</span>	<span class="comment">// ThrottleOutOfOrderWrites enables write throttling to help ensure that</span>
<span id="L7973" class="ln">  7973	</span>	<span class="comment">// data is delivered in priority order. This works around a race where</span>
<span id="L7974" class="ln">  7974	</span>	<span class="comment">// stream B depends on stream A and both streams are about to call Write</span>
<span id="L7975" class="ln">  7975	</span>	<span class="comment">// to queue DATA frames. If B wins the race, a naive scheduler would eagerly</span>
<span id="L7976" class="ln">  7976	</span>	<span class="comment">// write as much data from B as possible, but this is suboptimal because A</span>
<span id="L7977" class="ln">  7977	</span>	<span class="comment">// is a higher-priority stream. With throttling enabled, we write a small</span>
<span id="L7978" class="ln">  7978	</span>	<span class="comment">// amount of data from B to minimize the amount of bandwidth that B can</span>
<span id="L7979" class="ln">  7979	</span>	<span class="comment">// steal from A.</span>
<span id="L7980" class="ln">  7980	</span>	ThrottleOutOfOrderWrites bool
<span id="L7981" class="ln">  7981	</span>}
<span id="L7982" class="ln">  7982	</span>
<span id="L7983" class="ln">  7983	</span><span class="comment">// NewPriorityWriteScheduler constructs a WriteScheduler that schedules</span>
<span id="L7984" class="ln">  7984	</span><span class="comment">// frames by following HTTP/2 priorities as described in RFC 7340 Section 5.3.</span>
<span id="L7985" class="ln">  7985	</span><span class="comment">// If cfg is nil, default options are used.</span>
<span id="L7986" class="ln">  7986	</span>func http2NewPriorityWriteScheduler(cfg *http2PriorityWriteSchedulerConfig) http2WriteScheduler {
<span id="L7987" class="ln">  7987	</span>	if cfg == nil {
<span id="L7988" class="ln">  7988	</span>
<span id="L7989" class="ln">  7989	</span>		cfg = &amp;http2PriorityWriteSchedulerConfig{
<span id="L7990" class="ln">  7990	</span>			MaxClosedNodesInTree:     10,
<span id="L7991" class="ln">  7991	</span>			MaxIdleNodesInTree:       10,
<span id="L7992" class="ln">  7992	</span>			ThrottleOutOfOrderWrites: false,
<span id="L7993" class="ln">  7993	</span>		}
<span id="L7994" class="ln">  7994	</span>	}
<span id="L7995" class="ln">  7995	</span>
<span id="L7996" class="ln">  7996	</span>	ws := &amp;http2priorityWriteScheduler{
<span id="L7997" class="ln">  7997	</span>		nodes:                make(map[uint32]*http2priorityNode),
<span id="L7998" class="ln">  7998	</span>		maxClosedNodesInTree: cfg.MaxClosedNodesInTree,
<span id="L7999" class="ln">  7999	</span>		maxIdleNodesInTree:   cfg.MaxIdleNodesInTree,
<span id="L8000" class="ln">  8000	</span>		enableWriteThrottle:  cfg.ThrottleOutOfOrderWrites,
<span id="L8001" class="ln">  8001	</span>	}
<span id="L8002" class="ln">  8002	</span>	ws.nodes[0] = &amp;ws.root
<span id="L8003" class="ln">  8003	</span>	if cfg.ThrottleOutOfOrderWrites {
<span id="L8004" class="ln">  8004	</span>		ws.writeThrottleLimit = 1024
<span id="L8005" class="ln">  8005	</span>	} else {
<span id="L8006" class="ln">  8006	</span>		ws.writeThrottleLimit = math.MaxInt32
<span id="L8007" class="ln">  8007	</span>	}
<span id="L8008" class="ln">  8008	</span>	return ws
<span id="L8009" class="ln">  8009	</span>}
<span id="L8010" class="ln">  8010	</span>
<span id="L8011" class="ln">  8011	</span>type http2priorityNodeState int
<span id="L8012" class="ln">  8012	</span>
<span id="L8013" class="ln">  8013	</span>const (
<span id="L8014" class="ln">  8014	</span>	http2priorityNodeOpen http2priorityNodeState = iota
<span id="L8015" class="ln">  8015	</span>	http2priorityNodeClosed
<span id="L8016" class="ln">  8016	</span>	http2priorityNodeIdle
<span id="L8017" class="ln">  8017	</span>)
<span id="L8018" class="ln">  8018	</span>
<span id="L8019" class="ln">  8019	</span><span class="comment">// priorityNode is a node in an HTTP/2 priority tree.</span>
<span id="L8020" class="ln">  8020	</span><span class="comment">// Each node is associated with a single stream ID.</span>
<span id="L8021" class="ln">  8021	</span><span class="comment">// See RFC 7540, Section 5.3.</span>
<span id="L8022" class="ln">  8022	</span>type http2priorityNode struct {
<span id="L8023" class="ln">  8023	</span>	q            http2writeQueue        <span class="comment">// queue of pending frames to write</span>
<span id="L8024" class="ln">  8024	</span>	id           uint32                 <span class="comment">// id of the stream, or 0 for the root of the tree</span>
<span id="L8025" class="ln">  8025	</span>	weight       uint8                  <span class="comment">// the actual weight is weight+1, so the value is in [1,256]</span>
<span id="L8026" class="ln">  8026	</span>	state        http2priorityNodeState <span class="comment">// open | closed | idle</span>
<span id="L8027" class="ln">  8027	</span>	bytes        int64                  <span class="comment">// number of bytes written by this node, or 0 if closed</span>
<span id="L8028" class="ln">  8028	</span>	subtreeBytes int64                  <span class="comment">// sum(node.bytes) of all nodes in this subtree</span>
<span id="L8029" class="ln">  8029	</span>
<span id="L8030" class="ln">  8030	</span>	<span class="comment">// These links form the priority tree.</span>
<span id="L8031" class="ln">  8031	</span>	parent     *http2priorityNode
<span id="L8032" class="ln">  8032	</span>	kids       *http2priorityNode <span class="comment">// start of the kids list</span>
<span id="L8033" class="ln">  8033	</span>	prev, next *http2priorityNode <span class="comment">// doubly-linked list of siblings</span>
<span id="L8034" class="ln">  8034	</span>}
<span id="L8035" class="ln">  8035	</span>
<span id="L8036" class="ln">  8036	</span>func (n *http2priorityNode) setParent(parent *http2priorityNode) {
<span id="L8037" class="ln">  8037	</span>	if n == parent {
<span id="L8038" class="ln">  8038	</span>		panic(&#34;setParent to self&#34;)
<span id="L8039" class="ln">  8039	</span>	}
<span id="L8040" class="ln">  8040	</span>	if n.parent == parent {
<span id="L8041" class="ln">  8041	</span>		return
<span id="L8042" class="ln">  8042	</span>	}
<span id="L8043" class="ln">  8043	</span>
<span id="L8044" class="ln">  8044	</span>	if parent := n.parent; parent != nil {
<span id="L8045" class="ln">  8045	</span>		if n.prev == nil {
<span id="L8046" class="ln">  8046	</span>			parent.kids = n.next
<span id="L8047" class="ln">  8047	</span>		} else {
<span id="L8048" class="ln">  8048	</span>			n.prev.next = n.next
<span id="L8049" class="ln">  8049	</span>		}
<span id="L8050" class="ln">  8050	</span>		if n.next != nil {
<span id="L8051" class="ln">  8051	</span>			n.next.prev = n.prev
<span id="L8052" class="ln">  8052	</span>		}
<span id="L8053" class="ln">  8053	</span>	}
<span id="L8054" class="ln">  8054	</span>
<span id="L8055" class="ln">  8055	</span>	n.parent = parent
<span id="L8056" class="ln">  8056	</span>	if parent == nil {
<span id="L8057" class="ln">  8057	</span>		n.next = nil
<span id="L8058" class="ln">  8058	</span>		n.prev = nil
<span id="L8059" class="ln">  8059	</span>	} else {
<span id="L8060" class="ln">  8060	</span>		n.next = parent.kids
<span id="L8061" class="ln">  8061	</span>		n.prev = nil
<span id="L8062" class="ln">  8062	</span>		if n.next != nil {
<span id="L8063" class="ln">  8063	</span>			n.next.prev = n
<span id="L8064" class="ln">  8064	</span>		}
<span id="L8065" class="ln">  8065	</span>		parent.kids = n
<span id="L8066" class="ln">  8066	</span>	}
<span id="L8067" class="ln">  8067	</span>}
<span id="L8068" class="ln">  8068	</span>
<span id="L8069" class="ln">  8069	</span>func (n *http2priorityNode) addBytes(b int64) {
<span id="L8070" class="ln">  8070	</span>	n.bytes += b
<span id="L8071" class="ln">  8071	</span>	for ; n != nil; n = n.parent {
<span id="L8072" class="ln">  8072	</span>		n.subtreeBytes += b
<span id="L8073" class="ln">  8073	</span>	}
<span id="L8074" class="ln">  8074	</span>}
<span id="L8075" class="ln">  8075	</span>
<span id="L8076" class="ln">  8076	</span><span class="comment">// walkReadyInOrder iterates over the tree in priority order, calling f for each node</span>
<span id="L8077" class="ln">  8077	</span><span class="comment">// with a non-empty write queue. When f returns true, this funcion returns true and the</span>
<span id="L8078" class="ln">  8078	</span><span class="comment">// walk halts. tmp is used as scratch space for sorting.</span>
<span id="L8079" class="ln">  8079	</span><span class="comment">//</span>
<span id="L8080" class="ln">  8080	</span><span class="comment">// f(n, openParent) takes two arguments: the node to visit, n, and a bool that is true</span>
<span id="L8081" class="ln">  8081	</span><span class="comment">// if any ancestor p of n is still open (ignoring the root node).</span>
<span id="L8082" class="ln">  8082	</span>func (n *http2priorityNode) walkReadyInOrder(openParent bool, tmp *[]*http2priorityNode, f func(*http2priorityNode, bool) bool) bool {
<span id="L8083" class="ln">  8083	</span>	if !n.q.empty() &amp;&amp; f(n, openParent) {
<span id="L8084" class="ln">  8084	</span>		return true
<span id="L8085" class="ln">  8085	</span>	}
<span id="L8086" class="ln">  8086	</span>	if n.kids == nil {
<span id="L8087" class="ln">  8087	</span>		return false
<span id="L8088" class="ln">  8088	</span>	}
<span id="L8089" class="ln">  8089	</span>
<span id="L8090" class="ln">  8090	</span>	if n.id != 0 {
<span id="L8091" class="ln">  8091	</span>		openParent = openParent || (n.state == http2priorityNodeOpen)
<span id="L8092" class="ln">  8092	</span>	}
<span id="L8093" class="ln">  8093	</span>
<span id="L8094" class="ln">  8094	</span>	w := n.kids.weight
<span id="L8095" class="ln">  8095	</span>	needSort := false
<span id="L8096" class="ln">  8096	</span>	for k := n.kids.next; k != nil; k = k.next {
<span id="L8097" class="ln">  8097	</span>		if k.weight != w {
<span id="L8098" class="ln">  8098	</span>			needSort = true
<span id="L8099" class="ln">  8099	</span>			break
<span id="L8100" class="ln">  8100	</span>		}
<span id="L8101" class="ln">  8101	</span>	}
<span id="L8102" class="ln">  8102	</span>	if !needSort {
<span id="L8103" class="ln">  8103	</span>		for k := n.kids; k != nil; k = k.next {
<span id="L8104" class="ln">  8104	</span>			if k.walkReadyInOrder(openParent, tmp, f) {
<span id="L8105" class="ln">  8105	</span>				return true
<span id="L8106" class="ln">  8106	</span>			}
<span id="L8107" class="ln">  8107	</span>		}
<span id="L8108" class="ln">  8108	</span>		return false
<span id="L8109" class="ln">  8109	</span>	}
<span id="L8110" class="ln">  8110	</span>
<span id="L8111" class="ln">  8111	</span>	*tmp = (*tmp)[:0]
<span id="L8112" class="ln">  8112	</span>	for n.kids != nil {
<span id="L8113" class="ln">  8113	</span>		*tmp = append(*tmp, n.kids)
<span id="L8114" class="ln">  8114	</span>		n.kids.setParent(nil)
<span id="L8115" class="ln">  8115	</span>	}
<span id="L8116" class="ln">  8116	</span>	sort.Sort(http2sortPriorityNodeSiblings(*tmp))
<span id="L8117" class="ln">  8117	</span>	for i := len(*tmp) - 1; i &gt;= 0; i-- {
<span id="L8118" class="ln">  8118	</span>		(*tmp)[i].setParent(n)
<span id="L8119" class="ln">  8119	</span>	}
<span id="L8120" class="ln">  8120	</span>	for k := n.kids; k != nil; k = k.next {
<span id="L8121" class="ln">  8121	</span>		if k.walkReadyInOrder(openParent, tmp, f) {
<span id="L8122" class="ln">  8122	</span>			return true
<span id="L8123" class="ln">  8123	</span>		}
<span id="L8124" class="ln">  8124	</span>	}
<span id="L8125" class="ln">  8125	</span>	return false
<span id="L8126" class="ln">  8126	</span>}
<span id="L8127" class="ln">  8127	</span>
<span id="L8128" class="ln">  8128	</span>type http2sortPriorityNodeSiblings []*http2priorityNode
<span id="L8129" class="ln">  8129	</span>
<span id="L8130" class="ln">  8130	</span>func (z http2sortPriorityNodeSiblings) Len() int { return len(z) }
<span id="L8131" class="ln">  8131	</span>
<span id="L8132" class="ln">  8132	</span>func (z http2sortPriorityNodeSiblings) Swap(i, k int) { z[i], z[k] = z[k], z[i] }
<span id="L8133" class="ln">  8133	</span>
<span id="L8134" class="ln">  8134	</span>func (z http2sortPriorityNodeSiblings) Less(i, k int) bool {
<span id="L8135" class="ln">  8135	</span>
<span id="L8136" class="ln">  8136	</span>	wi, bi := float64(z[i].weight+1), float64(z[i].subtreeBytes)
<span id="L8137" class="ln">  8137	</span>	wk, bk := float64(z[k].weight+1), float64(z[k].subtreeBytes)
<span id="L8138" class="ln">  8138	</span>	if bi == 0 &amp;&amp; bk == 0 {
<span id="L8139" class="ln">  8139	</span>		return wi &gt;= wk
<span id="L8140" class="ln">  8140	</span>	}
<span id="L8141" class="ln">  8141	</span>	if bk == 0 {
<span id="L8142" class="ln">  8142	</span>		return false
<span id="L8143" class="ln">  8143	</span>	}
<span id="L8144" class="ln">  8144	</span>	return bi/bk &lt;= wi/wk
<span id="L8145" class="ln">  8145	</span>}
<span id="L8146" class="ln">  8146	</span>
<span id="L8147" class="ln">  8147	</span>type http2priorityWriteScheduler struct {
<span id="L8148" class="ln">  8148	</span>	<span class="comment">// root is the root of the priority tree, where root.id = 0.</span>
<span id="L8149" class="ln">  8149	</span>	<span class="comment">// The root queues control frames that are not associated with any stream.</span>
<span id="L8150" class="ln">  8150	</span>	root http2priorityNode
<span id="L8151" class="ln">  8151	</span>
<span id="L8152" class="ln">  8152	</span>	<span class="comment">// nodes maps stream ids to priority tree nodes.</span>
<span id="L8153" class="ln">  8153	</span>	nodes map[uint32]*http2priorityNode
<span id="L8154" class="ln">  8154	</span>
<span id="L8155" class="ln">  8155	</span>	<span class="comment">// maxID is the maximum stream id in nodes.</span>
<span id="L8156" class="ln">  8156	</span>	maxID uint32
<span id="L8157" class="ln">  8157	</span>
<span id="L8158" class="ln">  8158	</span>	<span class="comment">// lists of nodes that have been closed or are idle, but are kept in</span>
<span id="L8159" class="ln">  8159	</span>	<span class="comment">// the tree for improved prioritization. When the lengths exceed either</span>
<span id="L8160" class="ln">  8160	</span>	<span class="comment">// maxClosedNodesInTree or maxIdleNodesInTree, old nodes are discarded.</span>
<span id="L8161" class="ln">  8161	</span>	closedNodes, idleNodes []*http2priorityNode
<span id="L8162" class="ln">  8162	</span>
<span id="L8163" class="ln">  8163	</span>	<span class="comment">// From the config.</span>
<span id="L8164" class="ln">  8164	</span>	maxClosedNodesInTree int
<span id="L8165" class="ln">  8165	</span>	maxIdleNodesInTree   int
<span id="L8166" class="ln">  8166	</span>	writeThrottleLimit   int32
<span id="L8167" class="ln">  8167	</span>	enableWriteThrottle  bool
<span id="L8168" class="ln">  8168	</span>
<span id="L8169" class="ln">  8169	</span>	<span class="comment">// tmp is scratch space for priorityNode.walkReadyInOrder to reduce allocations.</span>
<span id="L8170" class="ln">  8170	</span>	tmp []*http2priorityNode
<span id="L8171" class="ln">  8171	</span>
<span id="L8172" class="ln">  8172	</span>	<span class="comment">// pool of empty queues for reuse.</span>
<span id="L8173" class="ln">  8173	</span>	queuePool http2writeQueuePool
<span id="L8174" class="ln">  8174	</span>}
<span id="L8175" class="ln">  8175	</span>
<span id="L8176" class="ln">  8176	</span>func (ws *http2priorityWriteScheduler) OpenStream(streamID uint32, options http2OpenStreamOptions) {
<span id="L8177" class="ln">  8177	</span>
<span id="L8178" class="ln">  8178	</span>	if curr := ws.nodes[streamID]; curr != nil {
<span id="L8179" class="ln">  8179	</span>		if curr.state != http2priorityNodeIdle {
<span id="L8180" class="ln">  8180	</span>			panic(fmt.Sprintf(&#34;stream %d already opened&#34;, streamID))
<span id="L8181" class="ln">  8181	</span>		}
<span id="L8182" class="ln">  8182	</span>		curr.state = http2priorityNodeOpen
<span id="L8183" class="ln">  8183	</span>		return
<span id="L8184" class="ln">  8184	</span>	}
<span id="L8185" class="ln">  8185	</span>
<span id="L8186" class="ln">  8186	</span>	parent := ws.nodes[options.PusherID]
<span id="L8187" class="ln">  8187	</span>	if parent == nil {
<span id="L8188" class="ln">  8188	</span>		parent = &amp;ws.root
<span id="L8189" class="ln">  8189	</span>	}
<span id="L8190" class="ln">  8190	</span>	n := &amp;http2priorityNode{
<span id="L8191" class="ln">  8191	</span>		q:      *ws.queuePool.get(),
<span id="L8192" class="ln">  8192	</span>		id:     streamID,
<span id="L8193" class="ln">  8193	</span>		weight: http2priorityDefaultWeight,
<span id="L8194" class="ln">  8194	</span>		state:  http2priorityNodeOpen,
<span id="L8195" class="ln">  8195	</span>	}
<span id="L8196" class="ln">  8196	</span>	n.setParent(parent)
<span id="L8197" class="ln">  8197	</span>	ws.nodes[streamID] = n
<span id="L8198" class="ln">  8198	</span>	if streamID &gt; ws.maxID {
<span id="L8199" class="ln">  8199	</span>		ws.maxID = streamID
<span id="L8200" class="ln">  8200	</span>	}
<span id="L8201" class="ln">  8201	</span>}
<span id="L8202" class="ln">  8202	</span>
<span id="L8203" class="ln">  8203	</span>func (ws *http2priorityWriteScheduler) CloseStream(streamID uint32) {
<span id="L8204" class="ln">  8204	</span>	if streamID == 0 {
<span id="L8205" class="ln">  8205	</span>		panic(&#34;violation of WriteScheduler interface: cannot close stream 0&#34;)
<span id="L8206" class="ln">  8206	</span>	}
<span id="L8207" class="ln">  8207	</span>	if ws.nodes[streamID] == nil {
<span id="L8208" class="ln">  8208	</span>		panic(fmt.Sprintf(&#34;violation of WriteScheduler interface: unknown stream %d&#34;, streamID))
<span id="L8209" class="ln">  8209	</span>	}
<span id="L8210" class="ln">  8210	</span>	if ws.nodes[streamID].state != http2priorityNodeOpen {
<span id="L8211" class="ln">  8211	</span>		panic(fmt.Sprintf(&#34;violation of WriteScheduler interface: stream %d already closed&#34;, streamID))
<span id="L8212" class="ln">  8212	</span>	}
<span id="L8213" class="ln">  8213	</span>
<span id="L8214" class="ln">  8214	</span>	n := ws.nodes[streamID]
<span id="L8215" class="ln">  8215	</span>	n.state = http2priorityNodeClosed
<span id="L8216" class="ln">  8216	</span>	n.addBytes(-n.bytes)
<span id="L8217" class="ln">  8217	</span>
<span id="L8218" class="ln">  8218	</span>	q := n.q
<span id="L8219" class="ln">  8219	</span>	ws.queuePool.put(&amp;q)
<span id="L8220" class="ln">  8220	</span>	n.q.s = nil
<span id="L8221" class="ln">  8221	</span>	if ws.maxClosedNodesInTree &gt; 0 {
<span id="L8222" class="ln">  8222	</span>		ws.addClosedOrIdleNode(&amp;ws.closedNodes, ws.maxClosedNodesInTree, n)
<span id="L8223" class="ln">  8223	</span>	} else {
<span id="L8224" class="ln">  8224	</span>		ws.removeNode(n)
<span id="L8225" class="ln">  8225	</span>	}
<span id="L8226" class="ln">  8226	</span>}
<span id="L8227" class="ln">  8227	</span>
<span id="L8228" class="ln">  8228	</span>func (ws *http2priorityWriteScheduler) AdjustStream(streamID uint32, priority http2PriorityParam) {
<span id="L8229" class="ln">  8229	</span>	if streamID == 0 {
<span id="L8230" class="ln">  8230	</span>		panic(&#34;adjustPriority on root&#34;)
<span id="L8231" class="ln">  8231	</span>	}
<span id="L8232" class="ln">  8232	</span>
<span id="L8233" class="ln">  8233	</span>	n := ws.nodes[streamID]
<span id="L8234" class="ln">  8234	</span>	if n == nil {
<span id="L8235" class="ln">  8235	</span>		if streamID &lt;= ws.maxID || ws.maxIdleNodesInTree == 0 {
<span id="L8236" class="ln">  8236	</span>			return
<span id="L8237" class="ln">  8237	</span>		}
<span id="L8238" class="ln">  8238	</span>		ws.maxID = streamID
<span id="L8239" class="ln">  8239	</span>		n = &amp;http2priorityNode{
<span id="L8240" class="ln">  8240	</span>			q:      *ws.queuePool.get(),
<span id="L8241" class="ln">  8241	</span>			id:     streamID,
<span id="L8242" class="ln">  8242	</span>			weight: http2priorityDefaultWeight,
<span id="L8243" class="ln">  8243	</span>			state:  http2priorityNodeIdle,
<span id="L8244" class="ln">  8244	</span>		}
<span id="L8245" class="ln">  8245	</span>		n.setParent(&amp;ws.root)
<span id="L8246" class="ln">  8246	</span>		ws.nodes[streamID] = n
<span id="L8247" class="ln">  8247	</span>		ws.addClosedOrIdleNode(&amp;ws.idleNodes, ws.maxIdleNodesInTree, n)
<span id="L8248" class="ln">  8248	</span>	}
<span id="L8249" class="ln">  8249	</span>
<span id="L8250" class="ln">  8250	</span>	parent := ws.nodes[priority.StreamDep]
<span id="L8251" class="ln">  8251	</span>	if parent == nil {
<span id="L8252" class="ln">  8252	</span>		n.setParent(&amp;ws.root)
<span id="L8253" class="ln">  8253	</span>		n.weight = http2priorityDefaultWeight
<span id="L8254" class="ln">  8254	</span>		return
<span id="L8255" class="ln">  8255	</span>	}
<span id="L8256" class="ln">  8256	</span>
<span id="L8257" class="ln">  8257	</span>	if n == parent {
<span id="L8258" class="ln">  8258	</span>		return
<span id="L8259" class="ln">  8259	</span>	}
<span id="L8260" class="ln">  8260	</span>
<span id="L8261" class="ln">  8261	</span>	for x := parent.parent; x != nil; x = x.parent {
<span id="L8262" class="ln">  8262	</span>		if x == n {
<span id="L8263" class="ln">  8263	</span>			parent.setParent(n.parent)
<span id="L8264" class="ln">  8264	</span>			break
<span id="L8265" class="ln">  8265	</span>		}
<span id="L8266" class="ln">  8266	</span>	}
<span id="L8267" class="ln">  8267	</span>
<span id="L8268" class="ln">  8268	</span>	if priority.Exclusive {
<span id="L8269" class="ln">  8269	</span>		k := parent.kids
<span id="L8270" class="ln">  8270	</span>		for k != nil {
<span id="L8271" class="ln">  8271	</span>			next := k.next
<span id="L8272" class="ln">  8272	</span>			if k != n {
<span id="L8273" class="ln">  8273	</span>				k.setParent(n)
<span id="L8274" class="ln">  8274	</span>			}
<span id="L8275" class="ln">  8275	</span>			k = next
<span id="L8276" class="ln">  8276	</span>		}
<span id="L8277" class="ln">  8277	</span>	}
<span id="L8278" class="ln">  8278	</span>
<span id="L8279" class="ln">  8279	</span>	n.setParent(parent)
<span id="L8280" class="ln">  8280	</span>	n.weight = priority.Weight
<span id="L8281" class="ln">  8281	</span>}
<span id="L8282" class="ln">  8282	</span>
<span id="L8283" class="ln">  8283	</span>func (ws *http2priorityWriteScheduler) Push(wr http2FrameWriteRequest) {
<span id="L8284" class="ln">  8284	</span>	var n *http2priorityNode
<span id="L8285" class="ln">  8285	</span>	if id := wr.StreamID(); id == 0 {
<span id="L8286" class="ln">  8286	</span>		n = &amp;ws.root
<span id="L8287" class="ln">  8287	</span>	} else {
<span id="L8288" class="ln">  8288	</span>		n = ws.nodes[id]
<span id="L8289" class="ln">  8289	</span>		if n == nil {
<span id="L8290" class="ln">  8290	</span>
<span id="L8291" class="ln">  8291	</span>			if wr.DataSize() &gt; 0 {
<span id="L8292" class="ln">  8292	</span>				panic(&#34;add DATA on non-open stream&#34;)
<span id="L8293" class="ln">  8293	</span>			}
<span id="L8294" class="ln">  8294	</span>			n = &amp;ws.root
<span id="L8295" class="ln">  8295	</span>		}
<span id="L8296" class="ln">  8296	</span>	}
<span id="L8297" class="ln">  8297	</span>	n.q.push(wr)
<span id="L8298" class="ln">  8298	</span>}
<span id="L8299" class="ln">  8299	</span>
<span id="L8300" class="ln">  8300	</span>func (ws *http2priorityWriteScheduler) Pop() (wr http2FrameWriteRequest, ok bool) {
<span id="L8301" class="ln">  8301	</span>	ws.root.walkReadyInOrder(false, &amp;ws.tmp, func(n *http2priorityNode, openParent bool) bool {
<span id="L8302" class="ln">  8302	</span>		limit := int32(math.MaxInt32)
<span id="L8303" class="ln">  8303	</span>		if openParent {
<span id="L8304" class="ln">  8304	</span>			limit = ws.writeThrottleLimit
<span id="L8305" class="ln">  8305	</span>		}
<span id="L8306" class="ln">  8306	</span>		wr, ok = n.q.consume(limit)
<span id="L8307" class="ln">  8307	</span>		if !ok {
<span id="L8308" class="ln">  8308	</span>			return false
<span id="L8309" class="ln">  8309	</span>		}
<span id="L8310" class="ln">  8310	</span>		n.addBytes(int64(wr.DataSize()))
<span id="L8311" class="ln">  8311	</span>
<span id="L8312" class="ln">  8312	</span>		if openParent {
<span id="L8313" class="ln">  8313	</span>			ws.writeThrottleLimit += 1024
<span id="L8314" class="ln">  8314	</span>			if ws.writeThrottleLimit &lt; 0 {
<span id="L8315" class="ln">  8315	</span>				ws.writeThrottleLimit = math.MaxInt32
<span id="L8316" class="ln">  8316	</span>			}
<span id="L8317" class="ln">  8317	</span>		} else if ws.enableWriteThrottle {
<span id="L8318" class="ln">  8318	</span>			ws.writeThrottleLimit = 1024
<span id="L8319" class="ln">  8319	</span>		}
<span id="L8320" class="ln">  8320	</span>		return true
<span id="L8321" class="ln">  8321	</span>	})
<span id="L8322" class="ln">  8322	</span>	return wr, ok
<span id="L8323" class="ln">  8323	</span>}
<span id="L8324" class="ln">  8324	</span>
<span id="L8325" class="ln">  8325	</span>func (ws *http2priorityWriteScheduler) addClosedOrIdleNode(list *[]*http2priorityNode, maxSize int, n *http2priorityNode) {
<span id="L8326" class="ln">  8326	</span>	if maxSize == 0 {
<span id="L8327" class="ln">  8327	</span>		return
<span id="L8328" class="ln">  8328	</span>	}
<span id="L8329" class="ln">  8329	</span>	if len(*list) == maxSize {
<span id="L8330" class="ln">  8330	</span>
<span id="L8331" class="ln">  8331	</span>		ws.removeNode((*list)[0])
<span id="L8332" class="ln">  8332	</span>		x := (*list)[1:]
<span id="L8333" class="ln">  8333	</span>		copy(*list, x)
<span id="L8334" class="ln">  8334	</span>		*list = (*list)[:len(x)]
<span id="L8335" class="ln">  8335	</span>	}
<span id="L8336" class="ln">  8336	</span>	*list = append(*list, n)
<span id="L8337" class="ln">  8337	</span>}
<span id="L8338" class="ln">  8338	</span>
<span id="L8339" class="ln">  8339	</span>func (ws *http2priorityWriteScheduler) removeNode(n *http2priorityNode) {
<span id="L8340" class="ln">  8340	</span>	for k := n.kids; k != nil; k = k.next {
<span id="L8341" class="ln">  8341	</span>		k.setParent(n.parent)
<span id="L8342" class="ln">  8342	</span>	}
<span id="L8343" class="ln">  8343	</span>	n.setParent(nil)
<span id="L8344" class="ln">  8344	</span>	delete(ws.nodes, n.id)
<span id="L8345" class="ln">  8345	</span>}
<span id="L8346" class="ln">  8346	</span>
<span id="L8347" class="ln">  8347	</span><span class="comment">// NewRandomWriteScheduler constructs a WriteScheduler that ignores HTTP/2</span>
<span id="L8348" class="ln">  8348	</span><span class="comment">// priorities. Control frames like SETTINGS and PING are written before DATA</span>
<span id="L8349" class="ln">  8349	</span><span class="comment">// frames, but if no control frames are queued and multiple streams have queued</span>
<span id="L8350" class="ln">  8350	</span><span class="comment">// HEADERS or DATA frames, Pop selects a ready stream arbitrarily.</span>
<span id="L8351" class="ln">  8351	</span>func http2NewRandomWriteScheduler() http2WriteScheduler {
<span id="L8352" class="ln">  8352	</span>	return &amp;http2randomWriteScheduler{sq: make(map[uint32]*http2writeQueue)}
<span id="L8353" class="ln">  8353	</span>}
<span id="L8354" class="ln">  8354	</span>
<span id="L8355" class="ln">  8355	</span>type http2randomWriteScheduler struct {
<span id="L8356" class="ln">  8356	</span>	<span class="comment">// zero are frames not associated with a specific stream.</span>
<span id="L8357" class="ln">  8357	</span>	zero http2writeQueue
<span id="L8358" class="ln">  8358	</span>
<span id="L8359" class="ln">  8359	</span>	<span class="comment">// sq contains the stream-specific queues, keyed by stream ID.</span>
<span id="L8360" class="ln">  8360	</span>	<span class="comment">// When a stream is idle or closed, it&#39;s deleted from the map.</span>
<span id="L8361" class="ln">  8361	</span>	sq map[uint32]*http2writeQueue
<span id="L8362" class="ln">  8362	</span>
<span id="L8363" class="ln">  8363	</span>	<span class="comment">// pool of empty queues for reuse.</span>
<span id="L8364" class="ln">  8364	</span>	queuePool http2writeQueuePool
<span id="L8365" class="ln">  8365	</span>}
<span id="L8366" class="ln">  8366	</span>
<span id="L8367" class="ln">  8367	</span>func (ws *http2randomWriteScheduler) OpenStream(streamID uint32, options http2OpenStreamOptions) {
<span id="L8368" class="ln">  8368	</span>
<span id="L8369" class="ln">  8369	</span>}
<span id="L8370" class="ln">  8370	</span>
<span id="L8371" class="ln">  8371	</span>func (ws *http2randomWriteScheduler) CloseStream(streamID uint32) {
<span id="L8372" class="ln">  8372	</span>	q, ok := ws.sq[streamID]
<span id="L8373" class="ln">  8373	</span>	if !ok {
<span id="L8374" class="ln">  8374	</span>		return
<span id="L8375" class="ln">  8375	</span>	}
<span id="L8376" class="ln">  8376	</span>	delete(ws.sq, streamID)
<span id="L8377" class="ln">  8377	</span>	ws.queuePool.put(q)
<span id="L8378" class="ln">  8378	</span>}
<span id="L8379" class="ln">  8379	</span>
<span id="L8380" class="ln">  8380	</span>func (ws *http2randomWriteScheduler) AdjustStream(streamID uint32, priority http2PriorityParam) {
<span id="L8381" class="ln">  8381	</span>
<span id="L8382" class="ln">  8382	</span>}
<span id="L8383" class="ln">  8383	</span>
<span id="L8384" class="ln">  8384	</span>func (ws *http2randomWriteScheduler) Push(wr http2FrameWriteRequest) {
<span id="L8385" class="ln">  8385	</span>	id := wr.StreamID()
<span id="L8386" class="ln">  8386	</span>	if id == 0 {
<span id="L8387" class="ln">  8387	</span>		ws.zero.push(wr)
<span id="L8388" class="ln">  8388	</span>		return
<span id="L8389" class="ln">  8389	</span>	}
<span id="L8390" class="ln">  8390	</span>	q, ok := ws.sq[id]
<span id="L8391" class="ln">  8391	</span>	if !ok {
<span id="L8392" class="ln">  8392	</span>		q = ws.queuePool.get()
<span id="L8393" class="ln">  8393	</span>		ws.sq[id] = q
<span id="L8394" class="ln">  8394	</span>	}
<span id="L8395" class="ln">  8395	</span>	q.push(wr)
<span id="L8396" class="ln">  8396	</span>}
<span id="L8397" class="ln">  8397	</span>
<span id="L8398" class="ln">  8398	</span>func (ws *http2randomWriteScheduler) Pop() (http2FrameWriteRequest, bool) {
<span id="L8399" class="ln">  8399	</span>
<span id="L8400" class="ln">  8400	</span>	if !ws.zero.empty() {
<span id="L8401" class="ln">  8401	</span>		return ws.zero.shift(), true
<span id="L8402" class="ln">  8402	</span>	}
<span id="L8403" class="ln">  8403	</span>
<span id="L8404" class="ln">  8404	</span>	for _, q := range ws.sq {
<span id="L8405" class="ln">  8405	</span>		if wr, ok := q.consume(math.MaxInt32); ok {
<span id="L8406" class="ln">  8406	</span>			return wr, true
<span id="L8407" class="ln">  8407	</span>		}
<span id="L8408" class="ln">  8408	</span>	}
<span id="L8409" class="ln">  8409	</span>	return http2FrameWriteRequest{}, false
<span id="L8410" class="ln">  8410	</span>}
<span id="L8411" class="ln">  8411	</span>
</pre><p><a href="h2_bundle.go%3Fm=text">View as plain text</a></p>

<div id="footer">
Build version go1.8.1.<br>
Except as <a href="https://developers.google.com/site-policies#restrictions">noted</a>,
the content of this page is licensed under the
Creative Commons Attribution 3.0 License,
and code is licensed under a <a href="http://localhost:6060/LICENSE">BSD license</a>.<br>
<a href="http://localhost:6060/doc/tos.html">Terms of Service</a> | 
<a href="http://www.google.com/intl/en/policies/privacy/">Privacy Policy</a>
</div>

</div><!-- .container -->
</div><!-- #page -->

<!-- TODO(adonovan): load these from <head> using "defer" attribute? -->
<script type="text/javascript" src="../../../lib/godoc/jquery.js"></script>
<script type="text/javascript" src="../../../lib/godoc/jquery.treeview.js"></script>
<script type="text/javascript" src="../../../lib/godoc/jquery.treeview.edit.js"></script>


<script>var goVersion = "go1.8.1";</script>
<script type="text/javascript" src="../../../lib/godoc/godocs.js"></script>

</body>
</html>

